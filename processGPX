#! /usr/bin/env perl -w
use strict;
use Getopt::Long;
use Geo::Gpx;
use XML::Descent;  # for extension tags
use POSIX qw(floor);
use Date::Parse;
use Pod::Usage;

# version 0.33: add start and finishing circuits
# version 0.34: add circle fitting
# version 0.35: add straight line fitting
# version 0.36: shifted turn-arounds to after min radius
# version 0.37: autospacing considers minRadius
# version 0.38: fixed bug in speed model
# version 0.39: add named segments
my $version = 0.39;  # make sure this matches pod value

my $number_regexp =
  '[+-]?\d*(?:\d|(?:\.\d+))(?:[eE][-+]?\d+)?';

$0 =~ s(.*/)();

# a function which transitions from 1 (x = -1) to 1/2 (x = 0) to 0 ( x = 1 )
my $pi2 = atan2(1, 0);
sub transition {
  my $x = shift;
  return (
          ($x < -1) ? 1 :
          ($x > 1) ? 0 :
          (1 - sin($x * $pi2)) / 2
         );
}

# set the suffix of a filename
sub setFileNameSuffix {
  my $f = shift;
  my $suffix = shift;
  (my $f2 = $f) =~ s/\.(\w\w\w?\w?)$/$suffix/;
  $f2 .= $suffix if ($f2 eq $f);
  return($f2);
}

# find distance between lat, lng points
my $pi          = atan2(0, -1);
my $twopi       = 2 * $pi;
my $sqrt2       = sqrt(2);
my $ln2         = log(2);
my $sqrt2pi     = sqrt(2 * $pi);
my $rEarth      = 20037392 / $pi;
my $deg2rad     = $pi / 180;
my $lat2y       = $rEarth * $deg2rad;

sub reduceAngle {
  my $theta = shift;
  $theta -= $twopi * floor(0.5 + $theta / $twopi);
  return $theta;
}

sub averageAngles {
  my $d1 = shift;
  my $d2 = shift;
  return reduceAngle( $d1 + 0.5 * reduceAngle($d2 - $d1) );
}

sub deltaAngle {
  my $d1 = shift;
  my $d2 = shift;
  return reduceAngle( $d2 - $d1 );
}

sub latlngDistance {
  my $p1 = shift;
  my $p2 = shift;
  my $lat1 = $deg2rad * $p1->{lat};
  my $lat2 = $deg2rad * $p2->{lat};
  my $lng1 = $deg2rad * $p1->{lon};
  my $lng2 = $deg2rad * $p2->{lon};
  my $dlng = $lng2 - $lng1;
  my $dlat = $lat2 - $lat1;
  my $a = sin($dlat / 2) ** 2 + cos($lat1) * cos($lat2) * sin($dlng / 2) ** 2;
  my $d = 2 * $rEarth * atan2( sqrt($a), sqrt(1-$a) );
  return $d;
}

sub pointsAreClose {
  my $p1 = shift;
  my $p2 = shift;
  my $sMax = shift // 0.05;
  my $zMax = shift // 1;
  my $dz = ((defined $p1->{ele}) && (defined $p2->{ele})) ? ($p2->{ele} - $p1->{ele}) : 0;
  return (abs($dz < $zMax) && (latlngDistance($p1, $p2) < $sMax));
}

sub dotProduct {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $p4 = shift;
  my $dot = (($p2->[1] - $p1->[1]) * ($p4->[1] - $p3->[1]) + ($p2->[0] - $p1->[0]) * ($p4->[0] - $p3->[0])) /
    sqrt( ( ($p2->[1] - $p1->[1]) ** 2 + ($p2->[0] - $p1->[0]) ** 2 ) * ( ($p4->[1] - $p3->[1]) ** 2 + ($p4->[0] - $p3->[0]) ** 2 ) );
  return $dot;
}

sub latlngDotProduct {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $p4 = shift;
  my ($dx12, $dy12) = latlng2dxdy($p1, $p2);
  my ($dx34, $dy34) = latlng2dxdy($p3, $p4);
  my $denom = sqrt(($dx12 ** 2 + $dy12 ** 2) * ($dx34 ** 2 + $dy34 ** 2));
  return ( ($denom == 0) ? undef : ($dx12 * $dx34 + $dy12 * $dy34) / $denom );
}

sub crossProduct {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $p4 = shift;
  my $dx12 = $p2->[0] - $p1->[0];
  my $dx34 = $p4->[0] - $p3->[0];
  my $dy12 = $p2->[1] - $p1->[1];
  my $dy34 = $p4->[1] - $p3->[1];
  my $denom = sqrt(($dx12 ** 2 + $dy12 ** 2) * ($dx34 ** 2 + $dy34 ** 2));
  return ( ($denom == 0) ? undef : ($dx12 * $dy34 - $dx34 * $dy12) / $denom );
}

sub latlngCrossProduct {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $p4 = shift;
  my ($dx12, $dy12) = latlng2dxdy($p1, $p2);
  my ($dx34, $dy34) = latlng2dxdy($p3, $p4);
  my $denom = sqrt(($dx12 ** 2 + $dy12 ** 2) * ($dx34 ** 2 + $dy34 ** 2));
  return ( ($denom == 0) ? undef : ($dx12 * $dy34 - $dx34 * $dy12) / $denom );
}

sub latlngAngle {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $s = latlngCrossProduct ($p1, $p2, $p2, $p3);
  my $c = latlngDotProduct ($p1, $p2, $p2, $p3);
  my $a = ((defined $s) && (defined $c)) ? reduceAngle(atan2($s, $c)) : undef;
  return $a;
}

# direction from p1 to p2
# 0 deg = eastward
# 90 deg: northward
# 180 deg: westward
# 270 deg: southward
sub latlngDirection {
  my $p1 = shift;
  my $p2 = shift;
  my ($dx, $dy) = latlng2dxdy($p1, $p2);
  return atan2($dy,$dx);
}

# the direction of a point p2, which is the average
# of the directions of the adjacent sgements
sub pointDirection {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  return averageAngles(latlngDirection($p1, $p2), latlngDirection($p2, $p3));
}

#
# shift a point by a given distance in a given direction
#
sub shiftPoint {
  my %var = @_;
  my $point = $var{point};
  my $direction = $var{direction};
  my $distance = $var{distance};

  my $c = cos($direction);
  my $s = sin($direction);

  # lane shift, 90 degrees
  my $dx = $s * $distance;
  my $dy = -$c * $distance;
  my $dlng = $dx / ($lat2y * cos($deg2rad * $point->{lat}));
  my $dlat = $dy / $lat2y;
  my %pNew = %$point;
  $pNew{lon} += $dlng;
  $pNew{lat} += $dlat;
  return \%pNew;
}

#
# shift a vertex by a given distance in a given direction
# the vertex is the intercection of two lines, each of
# which are shifted
#
sub shiftVertex {
  my %var = @_;
  my $point = $var{point};
  my $directions = $var{directions};
  my $distance = $var{distance};

  my $c1 = cos($directions->[0]);
  my $s1 = sin($directions->[0]);
  my $c2 = cos($directions->[1]);
  my $s2 = sin($directions->[1]);

  # lane shift, 90 degrees
  my $denom = $c1 * $s2 - $c2 * $s1;
  my ($dx, $dy);
  if (abs($denom) < 0.001) {
    $dx = ($s1 + $s2) * $distance / 2;
    $dy = -($c1 + $c2) * $distance / 2;
  } else {
    $dx = ($c1 - $c2) / $denom * $distance;
    $dy = ($s1 - $s2) / $denom * $distance;
  }
  my $dlng = $dx / ($lat2y * cos($deg2rad * $point->{lat}));
  my $dlat = $dy / $lat2y;
  my %pNew = %$point;
  $pNew{lon} += $dlng;
  $pNew{lat} += $dlat;
  return \%pNew;
}

sub latlng2dxdy {
  my $p1 = shift;
  my $p2 = shift;
  die("latlng2dxdy called with undefined point #1\n")
    unless (defined $p1);
  die("latlng2dxdy called with undefined point #2\n")
    unless (defined $p2);
  my $c1 = cos($deg2rad * $p1->{lat});
  my $c2 = cos($deg2rad * $p2->{lat});
  my $dlon = $p2->{lon} - $p1->{lon};
  $dlon -= 360 * floor(0.5 + $dlon / 360);
  my $dlat = $p2->{lat} - $p1->{lat};
  # note this allows for a 180 degree difference in latitude, which
  # is obviously problematic near a pole...  but it's a first
  # approximation
  $dlat -= 360 * floor(0.5 + $dlat / 360);
  my $dx = ($c1 + $c2) * $lat2y * $dlon / 2;
  my $dy = $lat2y * $dlat;
  return ($dx, $dy);
}

#
# point linearly interpolated between p1 and p2, with f the
# fraction of the distance to p2
# note since deleting repeated points results in the second point of a pair being deleted,
# for non-numeric fields, I need to assume interpolated points are associated with the
# latter point
# for segments, I need to have the interpolated interval be a fresh segment
#
sub interpolatePoint {
  my $p1 = shift;
  my $p2 = shift;
  my $f = shift;
  my %var = ();
  for my $k ( keys %$p1 ) {
    if ((defined $p1->{$k}) && (defined $p2->{$k})) {
      if ($k eq "segment" ) {
	if ( $p1->{$k} eq $p2->{$k} ) {
	  $var{$k} = $p1->{$k};
	} else {
	  $var{$k} = 0;
	}
      } elsif ((! (($p1->{$k} =~ /^$number_regexp$/o) && ($p2->{$k} =~ /^$number_regexp$/o)))) {
        $var{$k} = ($f < 0.5) ? $p1->{$k} : $p2->{$k};
      } else {
        $var{$k} = $p1->{$k} * (1 - $f) + $p2->{$k} * $f;
      }
    }
  }
  return \%var;
}

#
# return a new list of points and the index of a point at a given
# position.  The point is interpolated if necessary
#
sub pointAtPosition {
  my $s0     = shift;
  my $points = shift;
  my $isLoop = shift;

  my @pNew = ();

  addDistanceField(points=> $points) unless (exists $points->[0]->{distance});

  # handling of open loop
  my $courseDistance = $points->[-1]->{distance};
  $courseDistance += latlngDistance( $points->[-1], $points->[0] ) if ($isLoop);
  return if (($s0 < 0) || ($s0 > $courseDistance));

  my $pointAdded = 0;
  my $pIndex;
  for ( my $i = 1 ; $i <= $#$points; $i ++ ) {
    push @pNew, $points->[$i - 1];
    if ( ($s0 > 0) && ($points->[$i]->{distance} > $s0) && ($points->[$i - 1]->{distance} < $s0) ) {
      my $ds = $points->[$i]->{distance} - $points->[$i - 1]->{distance};
      my $f = ($s0 - $points->[$i - 1]->{distance}) / $ds;
      my $d1 = $f * $ds;
      my $d2 = (1 - $f) * $ds;
      if (($d1 < 0.01) && ($d1 < $ds / 2)) {
	$pIndex = $i - 1;
      } elsif (($d2 < 0.01) && ($d1 >= $ds / 2)) {
	$pIndex = $i;
      } else {
	push @pNew, interpolatePoint($points->[$i - 1], $points->[$i], $f);
	$pIndex = $#pNew;
      }
    }
    # add new point if necessary: only if we've not found the point yet
    if ( ($i == $#$points ) && (! $pointAdded) && (! (defined $pIndex)) ) {
      my %p = %{$points->[0]};
      $p{distance} = $courseDistance;
      push @{$points}, \%p;
      $pointAdded ++;
    }
  }

  # add the last point unless it was added here for interpolation
  push @pNew, $points->[-1] unless ($pointAdded);
  return (\@pNew, $pIndex);
}

# for splines...
# start at p1 aiming at p2, and from p2 to p3
# p2 is never reached (the corner is rounded)
sub interpolateCorner {
  my $points = shift;
  my $f = shift;

  my ($p1, $p2, $p3) = @$points;
  my $g = 1 - $f;

  my %var = ();
  my $f1 = $g ** 2;
  my $f2 = 2 * $f * $g;
  my $f3 = $f ** 2;
  for my $k ( keys %$p2 ) {
    if ((defined $p1->{$k}) && (defined $p2->{$k}) && (defined $p3->{$k})) {
      if ($k eq "segment" ) {
	if ( $p1->{$k} eq $p3->{$k} ) {
	  $var{$k} = $p1->{$k};
	} else {
	  $var{$k} = 0;
	}
      } elsif ((($p1->{$k} =~ /^$number_regexp$/o) && ($p2->{$k} =~ /^$number_regexp$/o))) {
	$var{$k} =
	  $f1 * $p1->{$k} +
	  $f2 * $p2->{$k} +
          $f3 * $p3->{$k}
	} else {
	  $var{$k} = ($f1 > $f3) ? $p1->{$k} : $p3->{$k};
	}
    }
  }
  return \%var;
}

# two-point corner interpolation
# corner is between p2 and p3
sub interpolateCorner4 {
  my $points = shift;
  my ($p1, $p2, $p3, $p4) = @$points;
  my $f  = shift;
  my $d2 = pointDirection($p1, $p2, $p3);
  my $d3 = pointDirection($p2, $p3, $p4);
  my ($dxi, $dyi) = pointIntercept($p2, $p3, $d2, $d3);
  my $pi = addVectorToPoint($p2, [$dxi, $dyi]);
  return interpolateCorner([$p2, $pi, $p3], $f);
}


#
# point intercept
#
# given two points p1 and p2, and two directions, d1 and d2, calculate
# the intercept of the lines in these directions passing thru these
# points
#
# parameteric formula for line:
# -s (x - x0) + c (y - y0) = 0
# if c = 1, s = 0 : y = y0
# if s = 1, c = 0 : x = y0
# if c = 1, s = 1 : (x - x0) = (y - y0)
# calculate intercept
# -s1 (x - x1) + c1 (y - y1) = 0
# -s2 (x - x2) + c2 (y - y2) = 0
# eliminate y...
# -s1 c2 (x - x1) + c1 c2 (y - y1) = 0
# +s2 c1 (x - x2) - c2 c1 (y - y2) = 0
# sum:
# s2 c1 (x - x2) - s1 c2 (x - x1) + c1 c2 (y1 - y2) = 0
# x =  ( s2 c1 x2 - s1 c2 x1 - c1 c2 (y2 - y1) ) / (s2 c1 - s1 c2)
# eliminate x...
# -s1 s2 (x - x1) + c1 s2 (y - y1) = 0
# +s2 s1 (x - x2) - c2 s1 (y - y2) = 0
# sum:
# y = ( s1 s2 (x2 - x1) - y2 c2 s1 + y1 c1 s2 ) / (s2 c1 - s1 c2)
#
# test 1:
# x1 = x2, y1 = y2
# x = (s2 c1 - s1 c2) x1 / (s2 c1 - s1 c2) = x1
# y = (s2 c1 - s1 c2) y1 / (s2 c1 - s1 c2) = y1
# pass!
#
# test 2:
# y1 = 0, x1 = 1, c1 = 0, s1 = 1, x2 = 0, y2 = 1, s2 = 0, c2 = 1
# x =   -1  / -1 = 1
# y =  - 1 / -1 = 1
# pass!
#
# test 3:
# x1 = -1, y1 = 0, x2 = 1, y2 = 0, s1 = 1, c1 = 1, s2 = 1, c2 = -1
# x =  0 / 2 = 0
# y = 2 / 2 =  1
# pass!
#
# test 4:
# y1 = -1, x1 = 0, y2 = 1, x2 = 0, s1 = 1, c1 = 1, s2 = -1, c2 = 1
# x = -2 / -2 =  1
# y = 0
# pass!

# inputs: GPX points
# outputs: distances from the first point
# two points, two directions, find intercept
sub pointIntercept {
  my $p1 = shift;
  my $p2 = shift;
  my $d1 = shift;
  my $d2 = shift;
  my ($c1, $s1) = ( cos($d1), sin($d1) );
  my ($c2, $s2) = ( cos($d2), sin($d2) );
  my ($dx, $dy) = latlng2dxdy($p1, $p2);
  my $denom = $s2 * $c1 - $s1 * $c2;
  my $dxi = ( $c1 * $s2 * $dx - $c1 * $c2 * $dy ) / $denom;
  my $dyi = ( $s1 * $s2 * $dx - $s1 * $c2 * $dy ) / $denom;
  return ($dxi, $dyi);
}

# given two segments, each with two points, return the normalized positions on
# the segments where the intersections occur
# this is used by the crossing code
# avoid near-parallel lines
# if they intersect, report the fractions of the intersection along the segments
# (2 values)
sub segmentIntercept {
  my $s12 = shift;
  my $s34 = shift;
  my ($p1, $p2) = @$s12;
  my ($p3, $p4) = @$s34;
  die("segmentIntercept called with undefined point #1\n")
    unless (defined $p1);
  die("segmentIntercept called with undefined point #2\n")
    unless (defined $p2);
  die("segmentIntercept called with undefined point #3\n")
    unless (defined $p3);
  die("segmentIntercept called with undefined point #4\n")
    unless (defined $p4);
  my ($x1, $y1) = (0, 0);
  my ($x2, $y2) = latlng2dxdy($p1, $p2);
  my ($x3, $y3) = latlng2dxdy($p1, $p3);
  my ($x4, $y4) = latlng2dxdy($p1, $p4);
  my ($dx12, $dy12) = ($x2, $y2);
  my ($dx34, $dy34) = latlng2dxdy($p3, $p4);

  my $denom = $dx34 * $dy12 - $dx12 * $dy34;
  my $a = ( ($dx12 ** 2 + $dy12 ** 2) * ($dx34 ** 2 + $dy34 ** 2) ) ** (1/2);

  # lines are parallel
  if (($a == 0) || (abs($denom) < 0.01 * $a)) {
    return ();
  }

  my $f12 = ($dx34 * ($y3 - $y1) - $dy34 * ($x3 - $x1)) / $denom;
  if (($f12 >= 0) && ($f12 < 1)) {
    my $x = $f12 * $x2 + (1 - $f12) * $x1;
    my $y = $f12 * $y2 + (1 - $f12) * $y1;
    my $f23 = ((abs ($x3 - $x4) > abs($y3 - $y4)) ? ($x - $x3) / ($x4 - $x3) : ($y - $y3) / ($y4 - $y3));
    if (($f23 >= 0) && ($f23 < 1)) {
      return ($f12, $f23);
    }
  }
  return ();
}

# add a vector to a point
# a single iteration will use the average cosine for the path rather than
# a starting cosine, just for maximal accuracy
# note there will be no elevation field for this point:
# that will need to be added somewhere else
sub addVectorToPoint {
  my $p = shift;
  my $v = shift;
  my ($dx, $dy) = @$v;
  my %p2;
  my $lon0 = $p->{lon};
  my $lat0 = $p->{lat};
  my $dlat = $dy / $lat2y;      # this is independent of latitude
  my $lat = $lat0 + $dlat;
  $lat -= 360 * floor( 0.5 + $lat / 360);

  die("ERROR -- attempted to cross beyond pole!\n")
    if (abs($lat) > 90);

  my $c = cos($deg2rad * ($lat0 + $dlat / 2));
  my $dlon = $dx / $c / $lat2y;
  my $lon = $lon0 + $dlon;
  $lon -= 360 * floor( 0.5 + $lat / 360);
  $p2{lat} = $lat;
  $p2{lon} = $lon;
  return \%p2;
}

# return points between p1 and p2 using a spline
# using angles at beginning and end of the inteval
sub splineInterpolation {
  my $p1 = shift;
  my $p2 = shift;
  my $d1 = shift;
  my $d2 = shift;
  my $dd = shift // ($pi / 16); # minimum angle for spline

  # calculate number of points based on the angle
  my $deltad  = reduceAngle($d2 - $d1);
  my $npoints = floor(abs($deltad) / $dd);

  # if the points are close, reduce the number of points: 1 point per 10 cm separation
  my $npointsMax = floor(latlngDistance($p1, $p2) / 0.1);
  $npoints = $npointsMax if ($npoints > $npointsMax);

  return [] unless ($npoints > 0);

  my @points;

  # distance between the points
  my $r = latlngDistance($p1, $p2);

  my ($dxi, $dyi) =  pointIntercept($p1, $p2, $d1, $d2);
  my $px = addVectorToPoint($p1, [$dxi, $dyi]);

  # create points along asymptotes
  for my $i ( 1 .. $npoints ) {
    my $f = $i / ($npoints + 1);
    my $p = interpolateCorner([$p1, $px, $p2], $f);
    push @points, $p;
  }

  # interpolate points with respect to distance along spline
  # spline does not in general have equally spaced points, so point
  # interpolation, which would have been provided by interpolatePoint,
  # wouldn't work
  if (@points > 0) {
    my @ss = ( latlngDistance($p1, $points[0]) );
    for my $i ( 0 .. $#points - 1 ) {
      push @ss, $ss[-1] + latlngDistance($points[$i], $points[$i + 1]);
    }
    push @ss, $ss[-1] + latlngDistance($points[-1], $p2);

    for my $i ( 0 .. $#points ) {
      my $p = $points[$i];
      for my $k ( keys %$p1 ) {
        if (($k ne "lat") && ($k ne "lon")) {
          my $f = $ss[$i] / $ss[-1];
	  if ($k eq "segment" ) {
	    if ( $p1->{$k} eq $p2->{$k} ) {
	      $p->{$k} = $p1->{$k};
	    } else {
	      $p->{$k} = 0;
	    }
	  } elsif ( ($p1->{$k} =~ /^$number_regexp$/o) && ($p2->{$k} =~ /^$number_regexp$/o) ) {
            $p->{$k} = (1 - $f) * $p1->{$k} + $f
 * $p2->{$k};
          } else {
            $p->{$k} = $p1->{$k};
          }
        }
      }
    }
  }

  return \@points;
}

sub removeDuplicatePoints {
  my %var = @_;
  my $points = $var{points};

  note("removing duplicate points...\n");

  my @pNew = ();
  my $i = 0;
  while ( $i <= $#$points ) {
    my $p = $points->[$i];
    last unless (defined $p);
    my $lat0 = $p->{lat};
    my $lng0 = $p->{lon};
    my $s0 = $p->{segment};
    last unless (defined $lat0);

    my %sum1;
    my $sum0 = 0;

    if (($i < $#$points) && (abs($points->[$i + 1]->{lat} - $lat0) < 1e-9) && (abs($points->[$i + 1]->{lon} - $lng0) < 1e-9)) {
      my $j = $i;
      my %var;
      while (($j <= $#$points) && (abs($points->[$j]->{lat} - $lat0) < 1e-9) && (abs($points->[$j]->{lon} - $lng0) < 1e-9) && ($points->[$j]->{segment} == $s0)) {
        warn("($lat0, $lng0): combining duplicate point $j...\n");
        $sum0 ++;
        for my $key ( keys %$p ) {
          $sum1{$key} += $points->[$j]->{$key};
        }
        $j ++;
      }
      for my $key ( keys %$p ) {
        $var{$key} = $sum1{$key} / $sum0;
      }
      $i = $j;
      push @pNew, { %var };
    } else {
      push @pNew, $points->[$i];
      $i ++;
    }
  }
  return \@pNew;
}


#
# adds splines to points
#
sub addSplines {
  my %var = @_;
  my $points = $var{points};
  my $splineRadians = $var{splineRadians};
  my $splineMaxRadians = $var{splineMaxRadians};
  my $isLoop = $var{isLoop} // 0;

  note("starting spline processing...\n");

  #
  # create a direction field
  #
  addDirectionField(points=> $points, isLoop=>$isLoop);

  # find corners which meet spline criteria
  # two turns in the same direction, both less than max
  # assume sharper or single-point turns are intentional
  my @pNew = ();
  iLoop: for my $i ( 0 .. $#$points ) {
    push @pNew, $points->[$i];
    # add points if appropriate
    if ($isLoop || (($i > 0) && ($i < $#$points))) {
      my $j = ($i + 1) % @$points;
      next if (pointsAreClose($points->[$i], $points->[$j]));

      my $k = ($i - 1) % @$points;
      while (pointsAreClose($points->[$i], $points->[$k])) {
	next iLoop if ($k == ($isLoop ? 0 : $j));
	$k = ($k - 1) % @$points;
      }

      # turn angle of next point
      my $a1 = reduceAngle($points->[$j]->{direction} - $points->[$i]->{direction});
      # turn angle of this point
      my $a2 = reduceAngle($points->[$i]->{direction} - $points->[$k]->{direction});
      if ((abs($a1) > $splineRadians) &&
          (abs($a2) > $splineRadians) &&
          (abs($a1) <= $splineMaxRadians) &&
          (abs($a2) <= $splineMaxRadians) &&
          (($a1 <=> 0) == ($a2 <=> 0))
         ) {
        my $splinePoints = splineInterpolation( $points->[$i], $points->[$j], $points->[$i]->{direction}, $points->[$j]->{direction}, $splineRadians);
        push @pNew, @$splinePoints;
      }
    }
  }

  return \@pNew;
}


# calculate the normal between a point p3, and the segment connecting points p1 and p2
# 1: formula for segment:
#   (y - y1) / (x - x1) = (y2 - y1) / (x2 - x1)
#   (y - y1) (x2 - x1) = (x - x1) (y2 - y1)
# 2: formula for perpendicular line, passing thru x3
#   (y - y3) / (x - x3) = -(x2 - x1) / (y2 - y1)
#   (y - y3) (y2 - y1) = - (x - x3) (x2 - x1)
# 3: solve for x (from 1)
#   x = x1 + (y - y1) (x2 - x1) / (y2 - y1)
#   x = x1 + (x2 - x1) [ (y - y1) / (y2 - y1) ]
# 4: plug into 2:
#   (y - y3) (y2 - y1) = - ((x1 - x3) + (y - y1) (x2 - x1) / (y2 - y1)) (x2 - x1)
#   (y - y3) (y2 - y1)^2 = -((x1 - x3)  (x2 - x1) (y2 - y1) + (y - y1) (x2 - x1)^2)
#   (y - y3) (y2 - y1)^2 + (x1 - x3)  (x2 - x1) (y2 - y1) + (y - y1) (x2 - x1)^2 = 0
#   (y - y3) (y2 - y1)^2 + (y - y1) (x2 - x1)^2  + (x1 - x3)  (x2 - x1) (y2 - y1)  = 0
#   y [ (y2 - y1)^2  + (x2 - x1)^2 ] - y1 (x2 - x1)^2 - y3 (y2 - y1)^2 + (x1 - x3)  (x2 - x1) (y2 - y1)  = 0
#   y [ (y2 - y1)^2  + (x2 - x1)^2 ] = y1 (x2 - x1)^2 + y3 (y2 - y1)^2 - (x1 - x3)  (x2 - x1) (y2 - y1)
#   y = [ y1 (x2 - x1)^2 + y3 (y2 - y1)^2 - (x1 - x3) (x2 - x1) (y2 - y1) ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
#   y = [ y1 (x2 - x1)^2 + y3 (y2 - y1)^2 + (x3 - x1) (x2 - x1) (y2 - y1) ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
# for (3), we need...
#   (y - y1) = [ y1 (x2 - x1)^2 + y3 (y2 - y1)^2 + (x3 - x1) (x2 - x1) (y2 - y1) - y1 (y2 - y1)^2  - y1 (x2 - x1)^2 ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
#   (y - y1) = [ (y3 - y1) (y2 - y1)^2 + (x3 - x1) (x2 - x1) (y2 - y1) ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
#   (y - y1) / (y2 - y1)= [ (y3 - y1) (y2 - y1) + (x3 - x1) (x2 - x1) ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
#   x = x1 + (x2 - x1) [ (y3 - y1) (y2 - y1) + (x3 - x1) (x2 - x1) ] /  [ (y2 - y1)^2  + (x2 - x1)^2 ]
# summary (putting y into same form as x):
#   x = x1 + (x2 - x1) [ (y3 - y1) (y2 - y1) + (x3 - x1) (x2 - x1) ] / [ (y2 - y1)^2  + (x2 - x1)^2 ]
#   y = y1 + (y2 - y1) [ (y3 - y1) (y2 - y1) + (x3 - x1) (x2 - x1) ] / [ (y2 - y1)^2  + (x2 - x1)^2 ]
# parametric position on line: (this should be [0, 1])
#   f = [ (y3 - y1) (y2 - y1) + (x3 - x1) (x2 - x1) ] / [ (y2 - y1)^2  + (x2 - x1)^2 ]
# distance from line
#   x - x3 = (x1 - x3) + f (x2 - x1)
#   y - y3 = (y1 - y3) + f (y2 - y2)
#   (x - x3)^2 + (y - y3)^2 = [ (x1 - x3) + f (x2 - x1) ]^2 + [ (y1 - y3) + f (y2 - y2) ]^2
#   d = sqrt( [ (x1 - x3) + f (x2 - x1) ]^2 + [ (y1 - y3) + f (y2 - y1) ]^2 )

sub xyPointOnLine {
  # x,y points
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my ($x1, $y1) = @$p1;
  my ($x2, $y2) = @$p2;
  my ($x3, $y3) = @$p3;
  return (undef, undef) if ( ($x1 == $x2) && ($y1 == $y2) );
  my $f = ( ($y3 - $y1) * ($y2 - $y1) + ($x3 - $x1) * ($x2 - $x1) ) / ( ($y2 - $y1) ** 2  + ($x2 - $x1) ** 2 );
  my $d = sqrt( ( $x1 - $x3 + $f * ($x2 - $x1) ) ** 2 + ( $y1 - $y3 + $f * ($y2 - $y1) ) ** 2 );
  return ( $f, $d );
}

# checks whether px is on the line connecting p1 and p2
sub isPointOnRoad {
  my $p1 = shift();
  my $p2 = shift();
  my $px = shift();
  my $dmax  = shift() // 1;
  # if point is "on" an endpoint (within 10 cm) then true
  return 1 if (pointsAreClose($p1, $px) || pointsAreClose($p2, $px));
  # else check if it is within the margin of the line
  my ($dx1, $dy1) = latlng2dxdy($px, $p1);
  my ($dx2, $dy2) = latlng2dxdy($px, $p2);
  my ($f, $d)     = xyPointOnLine([$dx1, $dy1], [$dx2, $dy2], [0, 0]);
  my $isOnRoad    = ((defined $f) && (defined $d) && ($f >= 0) && ($f <= 1) && ($d <= $dmax));
  return $isOnRoad;
}

# a corner version of whether the point is on the road...
# but requires more points.
# given 4 points, takes a direction from p1 to p2
# and a direction from p3 to p4
# if the direction from p2 to px, and from px to p3, falls in
# between the cirections from p1 to p2 and from p2 to p3,
# then it's compatible with being on the line
sub isPointOnRoadCorner {
  my $p1 = shift();
  my $p2 = shift();
  my $p3 = shift();
  my $p4 = shift();
  my $px = shift;

  return 0 unless ((defined $px) && (defined $p2) && (defined $p3));

  return 1
    if (pointsAreClose($px, $p2) || pointsAreClose($px, $p3));

  return 0
    unless ((defined $p1) && (defined $p4));

  return 0
    if (pointsAreClose($p2, $p3) || pointsAreClose($p1, $p2) || pointsAreClose($p3, $p4));

  my $d12 = latlngDirection($p1, $p2);
  my $d34 = latlngDirection($p3, $p4);
  my $d2x = latlngDirection($p2, $px);
  my $dx3 = latlngDirection($px, $p3);

  # these angles are between -pi/2 and +pi/2
  my $dA = deltaAngle($d12, $d2x);
  my $dB = deltaAngle($d12, $dx3);
  my $dC = deltaAngle($d12, $d34);
  # if angles are monotonic, success
  my $isPointOnRoadCorner =
    (
     ( ($dA >= 0) && ($dB >= $dA) && ($dC >= $dB) ) ||
     ( ($dA <= 0) && ($dB <= $dA) && ($dC <= $dB) )
    );

  return $isPointOnRoadCorner;
}


# do tests of if point i falls on the road in the range (j, k, l, m)
sub roadTest {
  my $points = shift;
  my $j = shift;                # point before first point
  my $k = shift;                # first point
  my $l = shift;                # second point
  my $m = shift;                # point after second point
  my $i = shift;                # test point
  my $d = shift;                # distance error margin

  # first check to see if the point i falls in the range k .. l
  return 0
    unless (
            ($i > 0) &&
            ($k > 0) &&
            ($l > 0) &&
            ($i <= $#$points) &&
            ($k <= $#$points) &&
            ($l <= $#$points)
           );

  return 1
    if (
        isPointOnRoad($points->[$k], $points->[$l], $points->[$i], $d)
       );

  return 0
    unless (
            ($j > 0) &&
            ($m > 0) &&
            ($j <= $#$points) &&
            ($m <= $#$points)
           );

  return ( isPointOnRoadCorner($points->[$j], $points->[$k], $points->[$l], $points->[$m], $points->[$i]) );
}

sub applyLaneShift {
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop} // 0;

  return $points unless (@$points);

  my @pNew = ();

  # create list of (x, y) coordinates
  my @dxs = ();
  my @dys = ();
  my @dss = ();
  my @ss  = (0);
  my @dirs = ();

  for my $i ( 0 .. $#$points ) {
    push @ss, $ss[-1] + $dss[-1] if ($i > 0);
    if ($isLoop || ($i < $#$points)) {
      my ($dx, $dy) = latlng2dxdy($points->[$i], $points->[($i + 1) % @$points]);
      push @dxs, $dx;
      push @dys, $dy;
      push @dss, sqrt($dx ** 2 + $dy ** 2);
      push @dirs, atan2($dy, $dx);
    }
  }

  # final point for point-to-point
  if (! $isLoop) {
    push @dxs, $dxs[-1];
    push @dys, $dys[-1];
    push @dss, $dss[-1];
    push @dirs, $dirs[-1];
  }

  # lane shift: to right, which means adding pi/2 to the direction
 shiftLoop: for my $i ( 0 .. $#$points ) {
    my ($dir1, $dir2);
    if (($i > 0) || $isLoop) {
      $dir1 = $dirs[$i - 1];
      $dir2 = $dir1 + reduceAngle($dirs[$i] - $dir1);
    } else {
      $dir1 = $dirs[$i];
      $dir2 = $dirs[$i];
    }

    # for sharp turns repeat a point: there's no way to decide if it's an "inside" or "outside" sharp turn
    if ( ($isLoop || (($i > 0) && ($i < $#$points))) && (abs($dir2 - $dir1) > 0.99 * $pi) ) {
      my @pTurns = ();
      for my $dir ( $dir1, $dir2 ) {
        push @pTurns,
          shiftPoint(point=> $points->[$i], direction=> $dir, distance=> $points->[$i]->{shift});
      }
      # check if there's a knot.. if not use the doubled points
      my @fs = segmentIntercept( [$points->[$i - 1], $pTurns[0]], [$pTurns[1], $points->[($i + 1) % @$points]] );
      if ( @fs == 0 ) {
        push @pNew, @pTurns;
        next shiftLoop;
      }
    }

    push @pNew, shiftVertex(point=> $points->[$i], directions=> [$dir1, $dir2], distance=> $points->[$i]->{shift});
  }

  return \@pNew;
}


#
# determines whether point p3 can be removed from segment p1 - p3 - p2
# without affecting path or altitude profile
#
sub isPointPrunable {
  my %var = @_;
  my ($p1, $p2, $p3) = @{$var{points}};
  my $dmax = $var{distance} // 2;
  my $X = $var{X}           // 0.001;
  my $dgmax = $var{dg}      // 0.001;
  die("isPointPrunable requires 3 points\n") unless (defined $p3);

  my ($x1, $y1) = latlng2dxdy( $p3, $p1);
  my ($x2, $y2) = latlng2dxdy( $p3, $p2);
  my ($x3, $y3) = (0, 0);
  my $z1 = $p1->{ele};
  my $z2 = $p2->{ele};
  my $z3 = $p3->{ele};
  my $s1 = $p1->{segment};
  my $s2 = $p2->{segment};
  my $s3 = $p3->{segment};

  # only prune points in the same segment
  return 0 unless (($s1 == $s2) && ($s2 == $s3));

  if (isPointOnRoad ( $p1, $p2, $p3, 1 ) ) {
    my $d13 = sqrt(($y3 - $y1) ** 2 + ($x3 - $x1) ** 2);
    my $d23 = sqrt(($y3 - $y2) ** 2 + ($x3 - $x2) ** 2);

    # duplicate points are not prunable
    return 0
      if ( ($d13 == 0) || ($d23 == 0) );

    # check gradient, and alignment
    my $dg =  ($z2 - $z3) / $d23 - ($z3 - $z1) / $d13;
    my $cross = crossProduct( [$x1, $y1], [$x3, $y3], [$x3, $y3], [$x2, $y2] );
    return ( (abs($dg) <= $dgmax) && (abs($cross) <= $X) );
  }
  return 0;
}

#
# my heuristic bike speed model
# see https://djconnel.blogspot.com/2013/01/calibrating-heuristic-bike-speed-model.html
# extreme gradients: 1/3 gradient cuts speed 50%.
#
sub bikeSpeedModel {
  my %vars = @_;
  my $vMax   = $vars{vMax} // 17;
  my $VAMMax = $vars{VAMMax} // 0.52;
  my $v0     = $vars{v0} // 9.5;
  my $g      = $vars{g} // 0;
  # convert g to sine
  $g /= sqrt(1 + $g ** 2);
  my $a      = $vMax / $VAMMax;
  my $b      = $vMax / $v0 - $ln2;
  my $fV     = (1 + (3 * $g) ** 4) * ($b + log(1 + exp($a * $g)));
  return  $vMax / $fV;
}

#
# if there is a distance field, calculate the distance between points, which is more complicated
# on a loop course, which is why we need the total course distance
# this requires the distance field be already present.
#
sub distanceDifference {
  my $p1 = shift;
  my $p2 = shift;
  my $courseDistance = shift;
  my $isLoop = shift;
  die("distanceDifference called w/o distance field\n") unless ((defined $p1->{distance}) && (defined $p2->{distance}));
  my $d = $p2->{distance} - $p1->{distance};
  $d -= $courseDistance * floor($d / $courseDistance) if ($isLoop && ($courseDistance > 0)); # for loop courses
  return $d;
}
#
# separation of 2 points in course distance.... similar to distance difference but either direction
#
sub pointSeparation {
  my $p1 = shift;
  my $p2 = shift;
  my $courseDistance = shift;
  my $isLoop = shift;
  my $d = distanceDifference($p1, $p2, $courseDistance, $isLoop);
  if ($isLoop) {
    $d -= $courseDistance * floor(0.5 + $d / $courseDistance) if ($isLoop && ($courseDistance > 0)); # for loop courses
  }
  return abs($d);
}

#
# Fiets climb rating, modified
# Fiets is gradient times altitude
# this uses gradient to gradientPower times altitude (> 1 => more focus on gradient)
# gradient is normalized to 10%, so if the gradient averages 10%, the rating
# equals the altitude gain
#
sub climbRating {
  my %var = @_;
  my ($p1, $p2) = @{$var{points}};
  my $gradientPower = $var{gradientPower} // 2;
  my $courseDistance = $var{courseDistance};
  my $isLoop = $var{isLoop} // 0;
  my $dz = $p2->{ele} - $p1->{ele};
  my $ds = distanceDifference($p1, $p2, $courseDistance, $isLoop);
  return (($ds == 0) ? 0 : $dz * abs((10 * $dz / $ds)) ** $gradientPower);
}


#
# place gradient signs
# simplify profile, then find max Fiets segment, then recurse
#
sub addAutoSegments {
  my %var = @_;
  my $courseDistance = $var{courseDistance};
  my $gradientPower = ($var{gradientPower} // 2);
  my $isLoop = $var{isLoop};
  my $margin = $var{margin};
  my $names = $var{names};
  my $points = $var{points};
  my $segmentDefined = $var{segmentDefined} // {};
  my $segmentName = $var{segmentNames} // {};
  my $simplifyPoints = $var{simplifyPoints} // 1;
  my $stretch = $var{stretch};
  my $threshold = $var{threshold} // 100;
  note("creating auto-segments...\n");

  addDistanceField(points=> $points);
  $courseDistance //= calcCourseDistance(isLoop=> $isLoop, points=> $points);
  my $dMin = 60 + $margin;
  my $dMax = $courseDistance + ($isLoop ? 60 : -140) - $margin;

  my @c =
    findClimbs(
	       points => $points,
	       courseDistance=> $courseDistance,
	       simplifyPoints=> $simplifyPoints,
	       shiftCircuit=> 0,
	       gradientPower=> $gradientPower,
	       threshold=> $threshold,
	       isLoop=> $isLoop,
	       sign=> 1,
	      );

  my @climbs = ();
  for my $c ( sort {$a->[0] <=> $b->[0]} @c ) {
    if (
	($points->[$c->[0]]->{distance} >= $dMin ) &&
	($points->[$c->[1]]->{distance} <= $dMax)
       ) {
      if ( (@climbs == 0) || ($points->[$c->[0]]->{distance} > $points->[$climbs[-1]->[1]]->{distance} + $margin) ) {
	note(sprintf("autoSegments: identified climb from %.3f to %.3f km\n", $points->[$c->[0]]->{distance} / 1000, $points->[$c->[1]]->{distance} / 1000));
	push @climbs, $c;
       }
      else {
	warn("autoSegments: removing detected lower-rated climb due to inadequate margin to higher-rated adjacent climb.\n");
	 # climb is too close to preceding climb: take the one with the higher rating
	 my $r1 = climbRating(
			      points=> [$points->[$climbs[-1]->[0]], $points->[$climbs[-1]->[1]]],
			      gradientPower=> $gradientPower,
			      courseDistance=> $courseDistance,
			      isLoop => $isLoop,
			     );
	 my $r2 = climbRating(
			      points=> [$points->[$c->[0]], $points->[$c->[1]]],
			      gradientPower=> $gradientPower,
			      courseDistance=> $courseDistance,
			      isLoop => $isLoop,
			     );
	 if ($r2 < $r1) {
	   pop @climbs;
	   push @climbs, $c;
	 }
       }
    }
  }

  #
  # insert climbs into points -- need to be a bit careful to not
  # create point triplets is fhte climb happens to begin/end on point pairs,
  # for example existing segment boundaries
  #
  my @newPoints = ();
  my $nS = 1;
  my $i0 = 0;
  my $i1 = 0;

  for my $nc ( 0 .. $#climbs ) {
    my $climb = $climbs[$nc];

    # maximum distance to shift points to find peak or valley
    my $d = $stretch * ($points->[$climb->[1]]->{distance} - $points->[$climb->[0]]->{distance});

    # see if we can find a point within the search distance which is an altitude minimum
    my $j0 = $climb->[0];
    my $j = $j0 - 1;
    while (
	   ($j > 0) &&
	   ($points->[$j]->{distance} > $points->[$j0]->{distance} - $d) &&
	   (($points->[$j]->{distance} >= $dMin)) &&
	   (($nc == 0) || ($points->[$j]->{distance} >= $points->[$climbs[$nc - 1]->[1]]->{distance} + $margin))
	  ) {
      if (($points->[$j + 1]->{ele} >  $points->[$j]->{ele}) &&
	  ($points->[$j - 1]->{ele} >= $points->[$j]->{ele})
	 ) {
	note(sprintf("autoSegments: extending climb start from %.3f to %.3f km\n", $points->[$climb->[0]]->{distance} / 1000, $points->[$j]->{distance} / 1000));
	$climb->[0] = $j;
	last;
      }
      $j --;
    }

    my $j1 = $climb->[1];
    $j = $j1 + 1;
    while (
	   ($j < $#$points) &&
	   ($points->[$j]->{distance} < $points->[$j1]->{distance} + $d) &&
	   ($points->[$j]->{distance} <= $dMax) &&
	   (($nc == $#climbs) || ($points->[$j]->{distance} <= $points->[$climbs[$nc + 1]->[0]]->{distance} - $margin))
	  ) {
      if (($points->[$j + 1]->{ele} <= $points->[$j]->{ele}) &&
	  ($points->[$j - 1]->{ele} <  $points->[$j]->{ele})
	 ) {
	note(sprintf("autoSegments: extending climb finish from %.3f to %.3f km\n", $points->[$climb->[1]]->{distance} / 1000, $points->[$j]->{distance} / 1000));
	$climb->[1] = $j;
	last;
      }
      $j ++;
    }

    $nS ++ while ($segmentDefined->{$nS});
    $segmentDefined->{$nS} ++;
    $segmentName->{$nS} = (defined $names->[$nc]) ? $names->[$nc] : ( (@climbs > 1) ? ("GPM " . ($nc + 1)) : "GPM" );

    # if the climb limits are at point pairs, move each to the appropriate point
    $climb->[0] ++ while ( ($climb->[0] < $climb->[1]) && ($points->[$climb->[0] + 1]->{distance} < $points->[$climb->[0]]->{distance} + 0.05) );
    $climb->[1] -- while ( ($climb->[1] > $climb->[0]) && ($points->[$climb->[1]]->{distance} < $points->[$climb->[1] - 1]->{distance} + 0.05) );

    # points up to the climb
    $i1 = $climb->[0] - 1;
    push @newPoints, @$points[$i0 .. $i1];

    # shift to the climb
    $i0 = $climb->[0];
    $i1 = $climb->[1];

    # we may need to create a copy of the first point of the climb
    if (($i0 > 0) && ($points->[$i0]->{distance} > $points->[$i0 - 1]->{distance} + 0.05)) {
      my %p = %{$points->[$i0]};
      push @newPoints, \%p;
    }

    # copy all of the points up to the final point in the climb
    my $s = $points->[$i1]->{segment};
    for my $i ( $i0 .. $i1 ) {
      if ( ( $i == $i0 ) || ($points->[$i]->{distance} > $points->[$i - 1]->{distance} + 0.05) ) {
	push @newPoints, $points->[$i];
	$points->[$i]->{segment} = $nS;
      }
    }

    # if the next point is not a pair with the last copied point, then duplicate the last point of the climb
    if ( ($i1 < $#$points) && ($points->[$i1 + 1]->{distance} > $points->[$i1]->{distance} + 0.05) ) {
      my %p = %{$points->[$i1]};
      $p{segment} = $s;
      push @newPoints, \%p;
    }

    # starting point for the next insertion
    $i0 = $i1 + 1;
  }

  # points following the last climb
  push @newPoints, @$points[$i0 .. $#$points];

  return \@newPoints;
}

#
# findClimbs
# a proc to return route portions which are climbs according to the algorithm
#
sub findClimbs {
  my %var = @_;
  my $points = $var{points};
  my $indices = $var{indices};
  my $simplifyPoints = $var{simplifyPoints} // 1;
  my $shiftCircuit = $var{shiftCircuit} // 1;
  my $courseDistance = $var{courseDistance};
  my $gradientPower = ($var{gradientPower} // 2);
  my $threshold = ($var{threshold} // 100);
  my $isLoop = $var{isLoop};
  my $sign = $var{sign} // 1;  # sign: 1 for climbs, -1 for descents, 0 for both

  # minimum rating... units are meters ( @ 10% gradient)
  # this is normalized to 10% gradient,
  my $rating0 = $threshold;

  unless (defined $indices) {
    if ($simplifyPoints) {
      $indices = simplifyProfile($points, $gradientPower, $courseDistance, $isLoop);
    } else {
      $indices = [0 .. $#$points];
    }
  }

  # for circuits, we want to shift the points to the altitude minimum
  # no gradient signs will cross the altitude minimum on a loop
  if ($shiftCircuit) {
    # shift the points to the altitude minimum
    my $zMin = $points->[0]->{ele};
    my $izMin = 0;
    for my $i ( 1 .. $#$indices ) {
      if ($points->[$indices->[$i]]->{ele} < $zMin) {
        $zMin = $points->[$indices->[$i]]->{ele};
        $izMin = $i;
      }
    }
    if ($izMin > 0) {
      my @indices = @$indices[$izMin .. $#$indices];
      push @indices, @$indices[0 .. $izMin];  # repeat the first point
      $indices = \@indices;
    }
  }
  
  # find the segment of maximum Fiets
  my $rating = $rating0;
  my @range = ();
  for my $j ( 1 .. $#$indices ) {
    for my $i ( 0 .. $j - 1 ) {
      my $r = climbRating(
			  points=> [$points->[$indices->[$i]], $points->[$indices->[$j]]],
			  gradientPower=> $gradientPower,
			  courseDistance=> $courseDistance,
			  isLoop=> $isLoop
			 );
      if ($sign == 0) {
	$r = abs($r);
      } else {
	$r *= $sign;
      }
      if ($r > $rating) {
        @range = ($i, $j);
        $rating = $r;
      }
    }
  }

  my @climbs = ();
  if (@range) {
    push @climbs,
      findClimbs(
		 points => $points,
		 simplifyPoints=> 0,
		 courseDistance=> $courseDistance,
		 shiftCircuit=> 0,
		 gradientPower=> $gradientPower,
		 threshold=> $threshold,
		 isLoop=> $isLoop,
		 sign=> $sign,
		 indices=>  [ @$indices[0 .. $range[0]] ],
		)
      if ($range[0] > 0);

    my @climb = map { $indices->[$_] } @range;
    push @climbs, \@climb;

    push @climbs,
      findClimbs(
		 points => $points,
		 courseDistance=> $courseDistance,
		 simplifyPoints=> 0,
		 shiftCircuit=> 0,
		 gradientPower=> $gradientPower,
		 threshold=> $threshold,
		 isLoop=> $isLoop,
		 sign=> $sign,
		 indices=>  [ @$indices[$range[1] .. $#$indices] ],
		)
      if ($range[1] < $#$indices);
  }

  return @climbs;
}

#
# place gradient signs
# simplify profile, then find max Fiets segment, then recurse
#
sub placeGradientSigns {
  my %var = @_;
  my $points = $var{points};
  my $simplifyPoints = $var{simplifyPoints} // 1;
  my $shiftCircuit = $var{shiftCircuit} // 1;
  my $courseDistance = $var{courseDistance};
  my $gradientPower = ($var{gradientPower} // 2);
  my $threshold = ($var{threshold} // 100);
  my $isLoop = $var{isLoop};

  $courseDistance //= calcCourseDistance(isLoop=> $isLoop, points=> $points);

  note("placing gradient signs...\n");

  my @waypoints;

  my @climbs =
    findClimbs(
	       points => $points,
	       courseDistance=> $courseDistance,
	       simplifyPoints=> $simplifyPoints,
	       shiftCircuit=> $shiftCircuit,
	       gradientPower=> $gradientPower,
	       threshold=> $threshold,
	       isLoop=> $isLoop,
	       sign=> 0,
	      );

  note("placeGradientSigns: number of climbs = ", scalar @climbs, "\n");

  my $nClimb = 0;
  for my $climb ( @climbs ) {
    $nClimb ++;
    my $ds = distanceDifference($points->[$climb->[0]], $points->[$climb->[1]], $courseDistance, $isLoop);
    my $dz = $points->[$climb->[1]]->{ele} - $points->[$climb->[0]]->{ele};
    my $g = $dz / $ds;
    my $text = sprintf("%.2f", 100 * $g) . "% for " . (($ds > 1000) ? sprintf("%.2f km", $ds / 1000) : sprintf("%d meters", $ds)) . " (" . sprintf("%.1f", $dz) . " m altitude)";
    note("gradient sign @ ", sprintf("%.2f", $points->[$climb->[0]]->{distance} / 1000), "km to ", sprintf("%.2f", $points->[$climb->[1]]->{distance} / 1000), " km: $text\n");

    push @waypoints,
      {
       lat   => $points->[$climb->[0]]->{lat},
       lon   => $points->[$climb->[0]]->{lon},
       ele   => $points->[$climb->[0]]->{ele},
       name  => "$text",
       cmt   => "$text",
       desc  => "$text",
       src   => "processGPX",
       sym   => "sign",
       type  => "sign",
       fix   => 'dgps',
      };
  }
  return \@waypoints;
}

#
# circle procs:
# fit a circle thru 3 points for replacing corners with circular sections
# this is designed for tracks like the Polo fields in San Francisco
#

# 3-point fit: takes (x, y) points and returns the center and the radius
# of a circle thru the points
sub circle3PointFit {
  my ($p1, $p2, $p3) = @_;

  # reference to first point
  my $x21 = $p2->[0] - $p1->[0];
  my $x31 = $p3->[0] - $p1->[0];
  my $y21 = $p2->[1] - $p1->[1];
  my $y31 = $p3->[1] - $p1->[1];


  # distances from first point
  my $rs21 = $x21 ** 2 + $y21 ** 2;
  my $rs31 = $x31 ** 2 + $y31 ** 2;

  my $denom = 2 * ($y21 * $x31 - $y31 * $x21);

  if ($denom == 0) {
    # points are colinear
    die("ERROR: tried to fit circle through colinear points\n");
  }

  my $f = ( $rs31 * $x21 - $rs21 * $x31 ) / $denom;
  my $g = ( $rs21 * $y31 - $rs31 * $y21 ) / $denom;

  my $r = sqrt($f ** 2 + $g ** 2);
  my $x0 = $p1->[0] - $g;
  my $y0 = $p1->[1] - $f;

  my @p0;
  $p0[0] = $x0;
  $p0[1] = $y0;
  return(\@p0, $r);
}

#
# given a set of poins, fit a circle to those points
#
sub fitCircle{
  my %var = @_;

  # points are (x, y, s)
  my $points = $var{points};

  my $p0 = $points->[0];
  my $pf = $points->[-1];
  my $s0 = $p0->[2];
  my $sf = $pf->[2];
  my $sMid = ($s0 + $sf) / 2;
  my $pMid;
  my $p1;
  for my $i ( 1 .. $#$points - 1 ) {
    $p1 = $points->[$i];
    last if ($points->[$i]->[2] > $sMid);
  }
  unless (defined $p1) {
    warn("insufficient points to fit circle!\n");
    return;
  }

  # fit analytic circle through points
  return circle3PointFit($p0, $p1, $pf);
}

sub processCircle {
  my %var = @_;

  my $points = $var{points};
  my $circle = $var{circle};
  my $circleStart = $var{circleStart};
  my $circleEnd = $var{circleEnd};
  my $isLoop = $var{isLoop} // 0;

  my @circles = ((defined $circle) ? @$circle : ());

  my @circleStarts = ();
  my @circleEnds = ();

  for (my $i = 0; $i < @circles;) {
    push @circleStarts, $circles[$i];
    $i ++;
    push @circleEnds, ( ($i < @circles) ? $circles[$i] : undef );
    $i ++;
  }

  my @a = (defined $circleStart) ? @$circleStart : ();
  my @b = (defined $circleEnd) ?  @$circleEnd : ();
  while (@a || @b) {
    push @circleStarts, shift @a;
    push @circleEnds, shift @b;
  }

  for my $iCircle ( 0 .. $#circleStarts ) {
    addDistanceField(points=> $points) unless (exists $points->[0]->{distance});

    note("fitting circle ", $iCircle + 1, " of ", scalar(@circleStarts), "\n");
    my $cStart = $circleStarts[$iCircle];
    my $cEnd = $circleEnds[$iCircle];
    next if (
             (! ( (defined $cStart) || (defined $cEnd) ) ) ||
             ((! $isLoop) && ($cStart >= $cEnd))
             );

    # get points to be replaced by circle
    my $iStart;
    if (defined $cStart) {
      my $i = 0;
      while ($points->[$i]->{distance} < $cStart) {
        $i ++;
        return if ($i > $#$points);
      }
      $iStart = $i;
    } else {
      $iStart = 0;
    }
    my $iEnd;
    if (defined $cEnd) {
      my $i = 0;
      while ($points->[$i + 1]->{distance} < $cEnd) {
        $i ++;
        return if ($i > $#$points);
      }
      $iEnd = $i;
    } else {
      $iEnd = $#$points;
    }

    # if we wrap around, then use a negative number for te start index
    $iStart -= @$points if ($iStart > $iEnd);


    # reference coordinates to first point
    my @xys = ( [0, 0, 0] );

    # offset distance
    my $d0 = $points->[$iStart]->{distance};

    for my $i ( $iStart + 1 .. $iEnd ) {

      # if we wrap around, adjust the distance offset
      $d0 -= $points->[-1]->{distance} if ($i == 0);

      my ($x, $y) = latlng2dxdy($points->[$iStart], $points->[$i]);
      push @xys, [$x, $y, $points->[$i]->{distance} - $d0];
    }

    # now we have a list of points and distances... create the circle
    my ($xyfit, $rCircle) = fitCircle(points=> \@xys);

    # center is relative to first point.
    my $pCenter = addVectorToPoint($points->[$iStart], $xyfit);

    # for each point, adjust the radius to the center point to the fitted radius
    for my $i ( $iStart .. $iEnd ) {
      my $d = latlngDistance($points->[$i], $pCenter);
      my $f = $rCircle / $d;
      my ($dx, $dy) = latlng2dxdy($pCenter, $points->[$i]);
      my $pNew =  addVectorToPoint($pCenter, [$dx * $f, $dy * $f]);
      $points->[$i]->{lat} = $pNew->{lat};
      $points->[$i]->{lon} = $pNew->{lon};
      note("updating point $i ...\n");
    }
    # these fields are now invalid
    deleteField(points=> $points, field=> "distance");
    deleteField(points=> $points, field=> "direction") if (exists $points->[0]->{direction});
  }
}

sub processStraight {
  my %var = @_;

  my $points = $var{points};
  my $straight = $var{straight};
  my $straightStart = $var{straightStart};
  my $straightEnd = $var{straightEnd};
  my $isLoop = $var{isLoop} // 0;

  my @straights = ((defined $straight) ? @$straight : ());

  my @straightStarts = ();
  my @straightEnds = ();

  for (my $i = 0; $i < @straights;) {
    push @straightStarts, $straights[$i];
    $i ++;
    push @straightEnds, ( ($i < @straights) ? $straights[$i] : undef );
    $i ++;
  }

  my @a = (defined $straightStart) ? @$straightStart : ();
  my @b = (defined $straightEnd) ?  @$straightEnd : ();
  while (@a || @b) {
    push @straightStarts, shift @a;
    push @straightEnds, shift @b;
  }

  for my $iStraight ( 0 .. $#straightStarts ) {
    addDistanceField(points=> $points) unless (exists $points->[0]->{distance});

    note("fitting straight ", $iStraight + 1, " of ", scalar(@straightStarts), "\n");
    my $sStart = $straightStarts[$iStraight];
    my $sEnd = $straightEnds[$iStraight];
    next if (
             (! ( (defined $sStart) || (defined $sEnd) ) ) ||
             ((! $isLoop) && ($sStart >= $sEnd))
             );

    # get points to be replaced by straight
    my $iStart;
    if (defined $sStart) {
      my $i = 0;
      while ($points->[$i]->{distance} < $sStart) {
        $i ++;
        return if ($i > $#$points);
      }
      $iStart = $i;
    } else {
      $iStart = 0;
    }
    my $iEnd;
    if (defined $sEnd) {
      my $i = 0;
      while ($points->[$i + 1]->{distance} < $sEnd) {
        $i ++;
        return if ($i > $#$points);
      }
      $iEnd = $i;
    } else {
      $iEnd = $#$points;
    }

    # if we wrap around, then use a negative number for te start index
    $iStart -= @$points if ($iStart > $iEnd);


    # reference coordinates to first point
    my @xys = ( [0, 0, 0] );

    # offset distance
    my $d0 = $points->[$iStart]->{distance};

    my ($rx, $ry) = latlng2dxdy($points->[$iStart], $points->[$iEnd]);

    # if neither rx nor ry is nonzero, do nothing
    next if (($rx == 0) && ($ry == 0));
    my $r2 = $rx ** 2 + $ry ** 2;

    # for each point, find the projection of the point on the segment
    for my $i ( $iStart + 1 .. $iEnd - 1 ) {
      my ($dx, $dy) = latlng2dxdy($points->[$iStart], $points->[$i]);
      # find the projection onto the line
      # projection: r dot rLine / r
      my $f = ($dx * $rx + $dy * $ry) / $r2;
      my $pNew =  addVectorToPoint($points->[$iStart], [$rx * $f, $ry * $f]);
      $points->[$i]->{lat} = $pNew->{lat};
      $points->[$i]->{lon} = $pNew->{lon};
      note("updating point $i ...\n");
    }
    # these fields are now invalid
    deleteField(points=> $points, field=> "distance");
    deleteField(points=> $points, field=> "direction") if (exists $points->[0]->{direction});
  }
}

#
#
# shiftCircuit: shift a circuit to start at a particular point
# note it works with either points themselves or with point indices
#
sub shiftCircuit {
  my $points = shift;
  my $startIndex = shift;
  my $dsConnect = latlngDistance($points->[-1], $points->[0]);
  my $copyPoint = ( $dsConnect  < 0.1 );
  my $lastPoint = $copyPoint ? $#$points -1 : $#$points;
  my @newPoints = @$points[$startIndex .. $lastPoint];
  push @newPoints, @$points[0 .. $startIndex - 1];
  push @newPoints, \%{$newPoints[0]} if $copyPoint;

  return \@newPoints;
}

#
# simplify profile for placing gradient signs
# makes sure max, min points are included, as well as first, last points
# this takes a list of points and point indices,
#

sub simplifyProfile {
  my $points = shift;
  my $gradientPower = shift;
  my $courseDistance = shift;
  my $isLoop = shift;
  my $indices = shift // [0 .. $#$points];

  my @indicesNew = ( $indices->[0] );
  my @keypoints = (0);
  for my $i ( 1 .. $#$indices - 1 ) {
    if ( ( $points->[$indices->[$i - 1]]->{ele} <=> $points->[$indices->[$i]]->{ele} ) != ( $points->[$indices->[$i]]->{ele} <=> $points->[$indices->[$i + 1]]->{ele} ) ) {
      push @keypoints, $i;

      # simplifying the monotonic profile: is guaranteed to return the last point, but may add intermediate points
      push @indicesNew, @{simplifyMonotonicProfile( $points, $courseDistance, $gradientPower, $isLoop, [ @$indices[$keypoints[-2] .. $keypoints[-1]]] )};
    }
  }
  push @indicesNew, @{simplifyMonotonicProfile( $points, $courseDistance, $gradientPower, $isLoop, [ @$indices[$keypoints[-1] .. $#$indices]] )};

  # DEBUG: this writes to /tmp
  # open my $fprofile,  ">/tmp/simplifiedProfile.csv";
  # print $fprofile "n,index,lat,lng,s,z\n";
  # for my $i ( 0 .. $#indicesNew ) {
  #   print $fprofile "$i,$indicesNew[$i],$points->[$indicesNew[$i]]->{lat},$points->[$indicesNew[$i]]->{lon},$points->[$indicesNew[$i]]->{distance},$points->[$indicesNew[$i]]->{ele}\n";
  # }
  # close $fprofile;

  return \@indicesNew;
}


#
# add distance field to points
#
sub addDistanceField {
  my %var =@_;
  my $points = $var{points} // [];

  return unless (@$points);
  $points->[0]->{distance} = 0;
  for my $i ( 1 .. $#$points ) {
    $points->[$i]->{distance} = $points->[$i - 1]->{distance}  + latlngDistance($points->[$i - 1], $points->[$i]);
  }
}

sub addGradientField {
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop} // 0;
  next unless (@$points);
  addDistanceField(points=> $points) unless ((defined $points->[0]->{distance}) && (defined $points->[-1]->{distance}));
  my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);
  my $i = 0;
  my $iMax = $#$points;
  while ($i <= $iMax) {
    my $p1 = $points->[$i];
    my $j = ($i + 1) % @$points;
    my $di = $p1->{distance};
    $j = (($j + 1) % @$points)  while ( ($j != $i) && abs(distanceDifference($p1, $points->[$j], $courseDistance, $isLoop)) < 0.1 );
    last if ( ($j <= $i)  && (! $isLoop) );
    my $p2 = $points->[$j];
    $p1->{gradient} = ($p2->{ele} - $p1->{ele}) / distanceDifference($p1, $p2, $courseDistance, $isLoop);
    $i ++;
  }
  if ($i > 0) {
    while ($i <= $iMax) {
      $points->[$i]->{gradient} = $points->[$i - 1]->{gradient};
      $i ++;
    }
  }
}

#
# add direction field to points
#
sub addDirectionField {
  my %var =@_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop} // 0;
  return unless (@$points);
  my $u = ($isLoop ? $#$points : 0);
  my $v = 0;
  my $w = 1;
  my $dPrev;
  while ($v <= $#$points) {
    $u = $v;
    $w = $v;
    while (pointsAreClose($points->[$u], $points->[$v])) {
      if ($isLoop ? ((($u - 1) % @$points) != $w) : ($u > 0)) {
        $u = ($u - 1) % @$points;
      } else {
        $u = $v;
        last;
      }
    }
    while (pointsAreClose($points->[$w], $points->[$v])) {
      if ($isLoop ? ((($w + 1) % @$points) != $u) : ($w < $#$points)) {
        $w = ($w + 1) % @$points;
      } else {
        $w = $v;
        last;
      }
    }
    my $d = $dPrev // 0;
    if ($u == $v) {
      if ($v != $w) {
        $d = latlngDirection($points->[$v], $points->[$w]);
      }
    } else {
      if ($v == $w) {
        $d = latlngDirection($points->[$u], $points->[$v]);
      } else {
        $d = pointDirection($points->[$u], $points->[$v], $points->[$w]);
      }
    }
    $d = $dPrev + reduceAngle($d - $dPrev) if (defined $dPrev);
    $dPrev = $d;
    $points->[$v]->{direction} = $d;
    $v ++;
  }
}

#
# add curvature field to points
# curvature = rate of change of direction / distance
#
sub addCurvatureField {
  my %var =@_;
  my $points = $var{points} // [];
  return unless (@$points);
  my $isLoop = $var{isLoop} // 0;
  my $vMin = 0;
  my $vMax = $#$points;
  unless ($isLoop) {
    $points->[$vMin ++]->{curvature} = 0;
    $points->[$vMax --]->{curvature} = 0;
  }
  my $v = $vMin;
  my $dPrev;
  while ($v <= $vMax) {
    my $u = ($v - 1) % @$points;
    my $w = ($v + 1) % @$points;
    while (pointsAreClose($points->[$u], $points->[$v])) {
      if ($isLoop ? ((($u - 1) % @$points) != $w) : ($u > 0)) {
        $u = ($u - 1) % @$points;
      } else {
        $u = $v;
        last;
      }
    }
    while (pointsAreClose($points->[$w], $points->[$v])) {
      if ($isLoop ? ((($w + 1) % @$points) != $u) : ($w < $#$points)) {
        $w = ($w + 1) % @$points;
      } else {
        $w = $v;
        last;
      }
    }
    if (($u == $v) || ($u == $w)) {
      $points->[$v]->{curvature} = 0;
      next;
    }
    $dPrev //= latlngDirection($points->[$u], $points->[$v]);
    my $d = latlngDirection($points->[$v], $points->[$w]);
    $points->[$v]->{curvature} = 2 * deltaAngle($dPrev, $d) / (latlngDistance($points->[$u], $points->[$v]) + latlngDistance($points->[$v], $points->[$w]));
    $dPrev = $d;
    $v ++;
  }
}

#
# calculate the net course distance
# need to "wrap around" for lapped courses
#
sub calcCourseDistance {
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop};
  return 0 unless @$points;
  addDistanceField(points=> $points)
    unless (defined $points->[-1]->{distance});
  my $distance = $points->[-1]->{distance};
  $distance += latlngDistance($points->[-1], $points->[0])
    if ($isLoop && @$points > 1);
  return $distance;
}

#
# delete a field from the points
#
sub deleteField {
  my %var = @_;
  my $field = $var{field};
  my $points = $var{points} // [];
  return unless (defined $field);
  for my $p ( @$points ) {
    delete $p->{$field} if (exists $p->{$field});
  }
}

sub cropPoints {
  my %vars = @_;
  my $points = $vars{points} // die;
  my $cropMin = $vars{min} // 0;
  my $cropMax = $vars{max} // 0;

  note("cropping ", (defined $cropMin) ? "from $cropMin " : "", (defined $cropMax) ? "to $cropMax " : "", "meters...\n");

  addDistanceField(points=> $points);

  my $s = 0;
  my @pNew = ();
  for my $i (0 .. $#$points) {

    # interpolate a point for cropMin, cropMax
    # if this is cropMin, this may be followed by including the point
    # if this is cropMax, then the point will be excluded
    for my $s0 ( $cropMin, $cropMax ) {
      if ( ($i > 0) && ($s0 > 0) && ($points->[$i]->{distance} > $s0) && ($points->[$i - 1]->{distance} < $s0) ) {
        my $ds = $points->[$i]->{distance} - $points->[$i - 1]->{distance};
        my $f = ($s0 - $points->[$i - 1]->{distance}) / $ds;
        my $d1 = $f * $ds;
        my $d2 = (1 - $f) * $ds;
        if (($d1 > 0.01) && ($d2 > 0.01)) {
          push @pNew, interpolatePoint($points->[$i - 1], $points->[$i], $f);
        }
      }
    }

    if (((! defined $cropMin) || ($s >= $cropMin)) &&
        ((! defined $cropMax) || ($cropMax <= 0) || ($s <= $cropMax))) {
      push @pNew, $points->[$i];
    }

    $s += latlngDistance($points->[$i], $points->[$i + 1])
      if ($i < $#$points);
  }
  return \@pNew;
}

#
# UTurnCheck
# check whether p1->p2 and p3->p4 are in the opposite cirection
#

sub UTurnCheck {
  my $p1 = shift;
  my $p2 = shift;
  my $p3 = shift;
  my $p4 = shift;
  my $dotMax = shift // -0.98;
  my $d = latlngDotProduct($p1, $p2, $p3, $p4);
  return ((defined $d) && ($d < $dotMax));
}

#
# make a loop of turn radius R from specified point in direction d with appropriate shift
# shift is the amount the point has been moved left or right
# if a second point is provided, then use that to calculate the shift, and optionally direction
#
# loop consists of semi-circles of appropriate radius
# 1. opening semi-circle
# 2. main semi-circle
# 3. closing semi-circle
#

sub makeLoop {
  my %var = @_;
  my $points = $var{points};
  my $direction = $var{direction};
  my $sign = $var{defaultSign} // 1;
  my $radius = $var{radius} // 4;
  my $segmentName = $var{segmentNames} // {};

  # if radius is negative, swap the direction
  if ($radius < 0) {
    $radius = -$radius;
    $sign = -$sign;
  }

  die("makeLoop requires a reference to a list of two points.\n")
    unless ((defined $points) && ((ref $points) eq "ARRAY") && (@$points > 1));
  die("makeLoop requires a direction parameter\n")
    unless (defined $direction);
  my $cdir = cos($direction);
  my $sdir = sin($direction);

  my ($point1, $point2) = @$points;

  # loop points
  my @pLoop = ();

  # loop eventually goes from point1 to point2
  # but this may require a shear

  #
  # calculate distance of the two paths,where a left turn is positive,
  # a right turn is negative.  This is twice the "laneShift", for example
  #
  my ($dx, $dy) = latlng2dxdy($point1, $point2);
  my $ds = sqrt($dx ** 2 + $dy ** 2);
  my $d = 0;
  if ($ds > 0.01) {
    # the original route is along direction dir (c, s)
    # so I need the end point along the orthogonal direction (-s, c)
    # it's along the direction perpendicular, but proportional to dot product
    $d = (-$sdir * $dx + $cdir * $dy);
    # check this... (all pass)
    # if c = 1, s = 0, dy = R, dx = 0 : d = R
    # if c = 1, s = 0, dx = R, dy = 0 : d = 0
    # if s = 1, c = 0, dy = R, dx = 0 : d = 0
    # if s = 1, c = 0, dx = R, dy = 0 : d = -R
  }

  #
  # make loop from point to reverse direction with specified shift
  #
  my $lat0 = ( $point1->{lat} + $point2->{lat} ) / 2;
  my $lng0 = ( $point1->{lon} + $point2->{lon} ) / 2;
  my $delta = abs($d / 2);
  $sign = ($d <=> 0) if ($delta > 0.1); # override sign if the points are separate (L or R turn)

  # generate points.... rotated coordinates
  my (@xs, @ys);
  my $cosTheta = ($radius + $delta) / (2 * $radius);

  # if cos theta > 1, then we'll generate a circle, but stretch it later
  my $theta;
  my $stretch;
  if ($cosTheta > 1) {
    $theta = 0;
    $stretch = $delta / $radius;
  } else {
    $theta = atan2(sqrt(1 - $cosTheta ** 2), $cosTheta);
    $stretch = 1;
  }

  my $dThetaMax = $twopi / (16 * (1 +sqrt( abs($radius / 4) )));

  # arc going into the circle
  # first point (delta, 0)
  # last point  (-delta, 0)
  my $nPoints = 1 + floor($theta / $dThetaMax);
  for my $i ( 1 .. $nPoints ) {
    my $t = $theta * $i / $nPoints;
    my $x = $radius + $delta - $radius * cos($t);
    my $y = $radius * sin($t);
    push @xs, $x;
    push @ys, $y;
  }

  # semi-circle
  my $theta2 = $theta + $pi / 2;
  $nPoints = 1 + floor($stretch ** (2/3) * $theta2 / $dThetaMax);
  for my $i ( 1 .. $nPoints ) {
    my $t = ($nPoints - $i) * $theta2 / $nPoints;
    my $x = $radius * sin($t);
    my $y = 2 * $radius * sin($theta) + $radius * cos($t);
    push @xs, $x;
    push @ys, $y;
  }

  # stretch points if separation exxceeds target turn radius
  for my $i ( 1 .. $#xs ) {
    $xs[$i] *= $stretch;
  }

  # swap x points if we're "driving on the left"
  if ( $sign < 0 ) {
    for my $i ( 0 .. $#xs ) {
      $xs[$i] = -$xs[$i];
    }
  }

  # finish route
  for (my $i = $#xs - 1; $i >= 0; $i -- ) {
    push @xs, -$xs[$i];
    push @ys, $ys[$i];
  }

  # shear to align
  # point1 => point2 : dx, dy
  # point1 => origin:: -s, +c
  my $u = ($delta == 0) ? 0 : ($dx / (2 * $delta)) ** 2 + ($dy / (2 * $delta)) ** 2 - 1;
  my $shear = ($delta == 0) ? 0 : ($u > 0) ? sqrt($u) : 0;
  $shear *= -$sign * (($cdir * $dx + $sdir * $dy) <=> 0);

  # transform to direction, adding shear transformation first
  # original road is aligned in direction dir
  # this is aligned in direction 90 degrees
  # need to rotate by dir - 90 deg
  # also calculate distance
  for my $i ( 0 .. $#xs ) {
    $ys[$i] += $shear * $xs[$i];
    my $x = $ sdir * $xs[$i] + $cdir * $ys[$i];
    my $y = -$cdir * $xs[$i] + $sdir * $ys[$i];
    $xs[$i] = $x;
    $ys[$i] = $y;
  }

  # convert to lat, lng
  my $c = cos($deg2rad * $lat0);
  for my $i ( 0 .. $#xs ) {
    my %h = %$point1;
    $h{lon} = $lng0 + $xs[$i] / ($lat2y * $c);
    $h{lat} = $lat0 + $ys[$i] / $lat2y;
    push @pLoop, \%h;
  }

  # may need to set segment
  if ( $point1->{segment} != $point2->{segment} ) {
    if ( defined $segmentName->{$point1->{segment}} ) {
      my $s = (defined $segmentName->{$point2->{segment}}) ? 0 : $point2->{segment};
      my %p = %$point1;
      unshift @pLoop, \%p;

      for my $p ( @pLoop ) {
	$p->{segment} = $s;
      }
    }

    if ($pLoop[-1]->{segment} != $point2->{segment}) {
      my %p = %$point2;
      $p{segment} = $pLoop[-1]->{segment};
      push @pLoop, \%p;
    }
  }

  # create a distance field
  my @ss = ( latlngDistance($point1, $pLoop[0]) );
  for my $i ( 0 .. $#pLoop - 1 ) {
    push @ss, $ss[-1] + latlngDistance($pLoop[$i], $pLoop[$i + 1]);
  }
  my $sLoop = $ss[-1] + latlngDistance($pLoop[-1], $point2);

  # interpolate elevation
  for my $i ( 0 .. $#pLoop ) {
    $pLoop[$i]->{ele} = ($point1->{ele} * ($sLoop - $ss[$i]) + $point2->{ele} * $ss[$i]) / $sLoop;
  }

  return \@pLoop;
}

#
# calculate an autosmoothing field
#
sub calcSigma {
  my %var = @_;
  my $points = $var{points} // [];
  my $isLoop = $var{isLoop};

  return unless (@$points);

  # specify the window over which gradient variance is calculated
  my $sigmaAvg = 200;
  my $twoSigmaAvg2 = 2 * $sigmaAvg ** 2;
  my $avgRange = 3 * $sigmaAvg;

  # calculate a gradient field (also adds distance)
  note("calculating gradient field...\n");
  addGradientField(points=> $points);
  my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);

  my @gVars;                    # gradient variances
  my @densities;                # point densities
  my $i1 = 1; # starting point for gradient variance: note we don't calculate for i=0 unless it's a loop
  my $i2 = 0; # ending point for gradient variance (can exceed number of points)

  if ($isLoop) {
    $i1 -- while ( ($i1 > -scalar(@$points)) && (distanceDifference($points->[$i1], $points->[0], $courseDistance, $isLoop) < $avgRange) );
  }

  for my $i ( 0 .. $#$points ) {
    # move i1 to just outside averaging range
    $i1 ++ while ( ($i1 < $i) && (distanceDifference($points->[$i1 + 1], $points->[$i], $courseDistance, $isLoop) > $avgRange) );
    # move i1 to just outside averaging range
    $i2 ++ while ( ($isLoop ? ($i2 < $i + @$points) : ($i2 < $#$points - 1)) && (distanceDifference($points->[$i], $points->[$i2 % @$points], $courseDistance, $isLoop) < $avgRange) );
    my $sum0 = 0;
    my $sum1 = 0;
    for my $j ( $i1 .. $i2 ) {
      # gradient for each point is the forward gradient
      # so compare gradient of the previous point to gradient of this point
      my $w = exp(-(distanceDifference($points->[$i], $points->[$j % @$points],$courseDistance, $isLoop)) ** 2 / $twoSigmaAvg2);
      $sum0 += $w;
      # note for point to point, the last gradient is invalid, and there's no difference for the first point
      my $g1 = $points->[$j % @$points]->{gradient};
      my $g2 = $points->[($j - 1) % @$points]->{gradient};
      $sum1 += $w * ($g1 - $g2) ** 2 / sqrt( 1e-4 + $g1 ** 2 + $g2 ** 2 ); # this weights steep grade fluctuations more, but not too much more
    }
    if ($sum0 > 0) {
      my $gVar = $sum1 / $sum0; # variance of gradient differences
      my $d = $sum0 / ($sigmaAvg * $sqrt2pi); # density of points
      my $sigma = sqrt($gVar) * 25 / $d; # 10% grade varying +/- 1% : sigma = 0.8 points, 2.5% grade varying +/- 1% = 1.6 points
      $points->[$i]->{sigma} = $sigma;
    } else {
      $points->[$i]->{sigma} = 0;
    }
  }
}

#
# simplify monotonic profile
# simplify a route based only on altitude and distance
# the only preferred  point is the final point:
#
sub simplifyMonotonicProfile {
  my $points = shift;
  my $courseDistance = shift;
  my $gradientPower = shift // 2;
  my $isLoop = shift // 0;
  my $indices = shift // [0 .. $#$points];

  addDistanceField(points=> $points) unless (defined $points->[0]->{distance});
  $courseDistance //= calcCourseDistance(points=> $points, isLoop=> $isLoop);

  # create a distance field of the index list
  my @distance = (0);
  for my $i ( 1 .. $#$indices ) {
    push @distance, $distance[-1] + distanceDifference( $points->[$indices->[$i - 1]], $points->[$indices->[$i]], $courseDistance, $isLoop );
  }

  my $dz = $points->[$indices->[-1]]->{ele} - $points->[$indices->[0]]->{ele};
  my $sign = ($dz <=> 0);
  my $ds = $distance[-1] - $distance[0];

  return [$indices->[-1]] if ( (@$indices <= 2) || (abs($dz) < 1) || ($ds < 50) );


  # find maximum grade
  my $gAvg = $dz / $ds;
  my $gMax = 1.1 * $gAvg;
  my $igMax;
  for my $i ( 0 .. $#$indices - 1 ) {
    my $ds = $distance[$i + 1] - $distance[$i];

    if ($ds > 0) {
      my $dz = $points->[$indices->[$i + 1]]->{ele} - $points->[$indices->[$i]]->{ele};
      my $gAvg = $dz / $ds;

      # look for maximum gradient within the interval, but if the interval is mostly constant,
      # just live with endpoints
      my $g = ($points->[$indices->[$i + 1]]->{ele} - $points->[$indices->[$i]]->{ele}) / $ds;
      if ($g * $sign > $gMax * $sign) {
        $gMax = $g;
        $igMax = $i;
      }
    }
  }
  my @newIndices;

  if (defined $igMax) {
    my $i1 = $igMax;
    my $i2 = $i1 + 1;

    # extend segment around the point
    # the segment of maximum rating within this profile will be included in the simplified profile
  loop: while ( ($i1 > 0) || ($i2 < $#$indices) ) {
      my $rating = $sign * climbRating(points=> [$points->[$indices->[$i1]], $points->[$indices->[$i2]]], gradientPower=> $gradientPower, courseDistance=> $courseDistance, isLoop=> $isLoop);

      my $r1 = ($i1 > 0) ? $sign * climbRating(points=> [$points->[$indices->[$i1 - 1]], $points->[$indices->[$i2]]], gradientPower=> $gradientPower, courseDistance=> $courseDistance, isLoop=> $isLoop) : 0;
      my $r2 = ($i2 < $#$indices) ? $sign * climbRating(points=> [$points->[$indices->[$i1]], $points->[$indices->[$i2 + 1]]], gradientPower=> $gradientPower, courseDistance=> $courseDistance, isLoop=> $isLoop) : 0;
      if (($r1 > $rating) && ($r1 > $r2)) {
        $i1 --;
      } elsif (($r2 > $rating) && ($r2 > $r1)) {
        $i2 ++;
      } else {
        last loop;
      }
    }

    # the segment between i1 and i2 has maximal rating, so we don't need to simplify that further.
    # there may be interesting segments before and after
    # this will add point i1, plus perhaps more
    push @newIndices, @{simplifyMonotonicProfile( $points, $courseDistance, $gradientPower, $isLoop, [ @$indices[0 .. $i1] ]  )}
      if ($i1 > 0);
    push @newIndices, $indices->[$i2];
    # this will add the final point,plus perhaps more
    push @newIndices, @{simplifyMonotonicProfile( $points, $courseDistance, $gradientPower, $isLoop, [ @$indices[$i2 .. $#$indices] ] )}
      if ($i2 < $#$points);
  } else {
    push @newIndices, $indices->[-1];
  }
  return \@newIndices;
}

#
# calculate a quality metric for the profile...
#

sub calcQualityScore {
  my %var = @_;
  my $points = $var{points};
  my $isLoop = $var{isLoop};
  my $sum0 = 0;
  my $sum1 = 0;
  my $sum2 = 0;
  my @dss;
  my @dzs;
  note("calculating altitude quality score..\n");
  for my $i ( 0 .. $#$points ) {
    last if ((! $isLoop) && ($i == $#$points));
    my $ds = latlngDistance($points->[$i], $points->[($i + 1) % @$points]);
    my $dz = $points->[($i + 1) % @$points]->{ele} - $points->[$i]->{ele};
    next if ((abs($ds) < 0.1) && abs($dz < 0.01)); # skip duplicate points
    push @dss, latlngDistance($points->[$i], $points->[($i + 1) % @$points]);
    push @dzs, $dz;
  }
  for my $i ( 0 .. $#dss ) {
    next if ((! $isLoop) && ($i == 0));
    $sum0 ++;
    # these are sine grades, not tangents, to avoid zero denominators
    my $g1 = $dzs[$i - 1] / sqrt($dzs[$i - 1] ** 2 + $dss[$i - 1] ** 2);
    my $g2 = $dzs[$i] / sqrt($dzs[$i] ** 2 + $dss[$i] ** 2);
    $sum1 += ($g2 - $g1) ** 2;
    $sum2 += ( $g1 ** 2 + $g2 ** 2 ) / 2;
  }
  my $score = ($sum0 == 0) ? 0 : sqrt( $sum1 / (1e-4 * $sum0 + $sum2 ) );
  return $score;
}

#
# this proc finds extension elements within the GPX file
# Geo::GPX will not report extensions
#
# GPX extensions example:
# <extensions>
# <rgt:parserOptions>
# <rgt:disableElevationFixes/>
# <rgt:disableAdvancedSmoothing/>
# <rgt:maxSlope>30</rgt:maxSlope>
# </rgt:parserOptions>
# </extensions>
#


sub getExtensions {
  my $xml = shift;
  my $p = XML::Descent->new( { Input => $xml } );

  # Global handler - trigger anywhere an <options> tag is found
  my %extensions;
  $p->on( gpx => sub {
	    $p->on( "extensions/rgt:parserOptions" => sub {
		      $p->on(
			     '*' => sub {
			       my ( $elem, $attr, $ctx ) = @_;
			       my $t = $p->text;
			       if ($t eq "") {
				 $extensions{$elem} = 1;
			       } else {
				 $extensions{$elem} = $t;
			       }
			     })->walk;
		    });
	    my $nTrack = 0;
	    $p->on( trk => sub {
		      $nTrack ++;
		      my $nSegment = 0;
		      $p->on( trkseg => sub {
				$nSegment ++;
				$p->on(extensions => sub {
					 $p->on("rgt:namedSegment" => sub {
						  my $t = $p->text;
						  $extensions{segmentName}->{$nTrack}->{$nSegment} = $t;
						})->walk;
				       })->walk;
			      })->walk;
		    })->walk;
	  })->walk;
  return \%extensions;
}

sub addExtensions {
  my $xml = shift;
  my $extensions = shift;

  return $xml
    unless ( (defined $extensions) && (keys %$extensions) );

  my @lines = split("\n", $$xml);
  my @output = ();
  my $nTrack = 0;
  my $nSegment = 0;
  for my $l ( @lines ) {
    # add in GPX extensions
    if ($l =~ /<gpx.*>/) {
      # add extensions to xmins list .
      if ( $l !~ /GpxExtensions/ ) {
	$l =~ s/<gpx/<gpx xmlns:rgt="http:\/\/www.rgtcycling.com\/XML\/GpxExtensions\/v1"/;
      }
      push @output, $l;
      push @output, "<extensions>";
      push @output, "<rgt:parserOptions>";
      push @output, "<rgt:disableElevationFixes/>"
	if ($extensions->{"rgt:disableElevationFixes"});
      push @output, "<rgt:disableAdvancedSmoothing/>"
	if ($extensions->{"rgt:disableAdvancedSmoothing"});
      push @output, "<rgt:maxSlope>" . $extensions->{"rgt:maxSlope"} . "</rgt:maxSlope>"
      	if (defined $extensions->{"rgt:maxSlope"});
      push @output, "</rgt:parserOptions>";
      push @output, "</extensions>";
    } else {
      push @output, $l;
    }
    if ( ($l =~ /<trk>/) || ($l =~ /<trk\s/) ) {
      $nTrack ++;
    }
    if ($l =~ /<trkseg.*>/) {
      $nSegment ++;
      my $name= $extensions->{segmentName}->{$nTrack}->{$nSegment} // "";
      if ($name ne "") {
	push @output, "<extensions><rgt:namedSegment>$name</rgt:namedSegment></extensions>";
      }
    }
  }
  my $xml2 = join("\n", @output);
  return \$xml2;
}

my $addCurvature = 0;           # whether to not add a curvature field
my $addDirection = 0;           # whether to not add a direction field
my $addDistance = 0;            # whether to not add a distance field
my $addGradient = 0;            # whether to not add a gradient field
my $addGradientSigns = 0;       # whether to create list of gradient signs
my $addSigma = 0;               # whether to create a sigma field when autosmoothing
my $anchorSF = 0;               # whether to anchor the S/F
my $append = 0;                 # distance to append on finish (140 meters allows room for finish): only for point-to-point
my $autoSegmentMargin = 100;    # minimum distance between auto-segments or between segments and start or finish banners
my $autoSegmentDefaultPower = 0.5;  # default for gradient power in auto segments
my $autoSegmentStretch = 0.05;  # fractional amount to stretch auto-segments to hit peaks or valleys
my $autoSegmentNames = "";      # comma separated list of names for the auto-segments
my $autoSpacing;                # whether to do auto-spacing
my $author;                     # author, for GPX
my $copyPoint = 0;              # whether to make sure first point and last point in data coincide
my $copyright;                  # copyright field, for GPX
my $cropMax;                    # maximum distance of retained data (distance calculated in original coordinates
my $cropMin;                    # minimum distance of retained data (distance calculated in original coordinates)
my $crossingAngle;              # crossings need to cross by at least this angle
my $crossingHeight = 2;         # crossing should have same altitude, or at least this height
my $crossingTransition;         # transition length for crossings
my $csv = 0;                    # whether to use CSV instead of GPX
my $description;                # description, for GPX metadata
my $disableElevationFixes = 1;  # whether to disable elevation fixes
my $disableAdvancedSmoothing = 1; # whether to disable advanced smoothing
my $enableElevationFixes = 0;     # whether to disable elevation fixes
my $enableAdvancedSmoothing = 0;  # whether to disable advanced smoothing
my $extend = 0;                 # apply to both append and prepend
my $extendBack = 0;             # amount to extend the route with a loop.
my $finishCircuits  = 0;        # number of finish circuits
my $finishCircuitDistance = -1;  # km of finish circuit
my $fixCrossings = 0;           # whether to flatten crossings
my $gradientPower = 2;          # power to raise gradient in evaluating segments for gradient signs
my $gradientThreshold = 100;    # minimum climb @ 10% grade to get a gradient sign
my $isLoop = 0;                 # whether to apply periodic boundary conditions (smooth around the Loop)
my $lAutoSmooth = 0;            # auto-smoothing based on position
my $lSmooth = 0;                # general smoothing, applies to positions and all other fields
my $laneShift = 0;              # how much to shift lanes right (positive) or left (negative)
my $maxSlope = 30;              # maximum gradient for RGT, in percent (if <1, will be converted to %)
my $minRadius = 0;              # a minimum radius for corners: correct with lane shift
my $minRadiusStart;             # where to begin applying minimum radius (meters)
my $minRadiusEnd;               # where to end applying minimum radius (meters)
my $namedSegments = "";         # named segments
my $needHelp = 0;               # print the pod
my $newKeywords = "";           # new keywords for the GPX file
my $noSave = 0;                 # skip saving the file
my $outFile = "";               # where to write the resulting GPX, unless -nosave is used
my $prepend = 0;                # distance to pre-pend on start (60 meters allows room for start): only for point-to-point
my $prune = 0;                  # whether to prune points
my $pruneD = 1;                 # distance a point can deviate in meters to avoid pruning.  also much match X-product.
my $pruneX = 0.001;             # maximum cross product for pruning
my $prunedg = 0.0005;           # maximum difference in grade for point pruning
my $quiet = 0;                  # suppressed notes to standard error
my $rCrossings = 6;             # how much lenth to flatten crossings, each side
my $reverse = 0;                # whether to reverse the course
my $rLap= 0;                    # if the route is turned into an out-and-back, the radius of the return loop
my $rTurnaround= 0;             # if the route is turned into an out-and-back, the radius of the outer loop
my $rUTurn;                     # if the route is turned into an out-and-back, the radius of the two loops
my $shiftEnd;                   # where to end land shifting (define: don't end it)
my $shiftSF = -60;              # amount to shift the S/F if a loop course: RGT puts the start line 60 meters after start of course, so -60 works here
my $shiftStart;                 # where to start lane shifting (default: don't start it)
my $smoothAngle;                # angle at which direction changes trigger point interpolation
my $smoothStart;                # where to start smoothing (default: beginning)
my $smoothEnd;                  # where to finish smoothing (default: end)
my $snap = 0;                   # whether to check for near-coincident road segments, and make them exactly coincide: upward direction: 1 = up, 2 = down, 0 = none
my $snapAltitude = 1;           # how close altitude needs to be for snapping
my $snapDistance = 2;           # number of meters threshold for point snapping
my $snapTransition = 0;         # whether to transition the altitude around snaps to match the source
my $spacing = 0;                # target point spacing: linear interpolate between existing points
my $splineDegs = 0;             # maximum degrees use if we use spline interpolation
my $splineMaxDegs = 60;         # maximum turn angle for spline
my $startCircuits  = 0;         # number of start circuits
my $startCircuitDistance = -1;    # km of start circuit
my $startTime;                  # start time for activity
my $stripSegments;              # eliminate all existing segment definitions on input files
my $title;                      # title, for GPX file
my $vFlag = 0;                  # print version
my $zAutoSmooth = 0;            # auto-smoothing based on altitude
my $zOffset = 0;                # offset for altitude before scaling
my $zScale = 1;                 # scale factor for altitude
my $zShift = 0;                 # offset for altitude after scaling
my $zShiftStart;                # where to start applying z shift
my $zShiftEnd;                  # where to end applying z shift
my $zSmooth = 0;                # smoothing applied additionally to altitude

my @autoSegments;               # parameters for auto-segment generation
my @circle;                     # points for circle substitution
my @circleEnd;                  # ending point (meters) for a circular corner (one per run)
my @circleStart;                # starting point for a circular corner (one per run)
my @flatten;                    # points come in sets of 4: altitude, start point, finish point, lambda
my @join;                       # GPX file(s) to join to this one
my @straight;                   # points for straight substitution
my @straightEnd;                # ending point (meters) for a circular corner (one per run)
my @straightStart;              # starting point for a circular corner (one per run)

# shortcut options:
my $auto = 0;                   # automatically set options based on the course (doesn't turn options off)

GetOptions (
            "addCurvature"  => \$addCurvature,
            "addDirection"  => \$addDirection,
            "addDistance"   => \$addDistance,
            "addGradient"   => \$addGradient,
            "addGradientSigns" => \$addGradientSigns,
            "addSigma"      => \$addSigma,
            "anchorSF"      => \$anchorSF,
            "append=f"      => \$append,
            "author=s"      => \$author,
            "auto"          => \$auto,
	    "autoSegments=f{1,2}" =>  \@autoSegments,
	    "autoSegmentMargin=f" =>  \$autoSegmentMargin,
	    "autoSegmentPower=f"   =>  \$autoSegmentDefaultPower,
	    "autoSegmentStretch=f" =>  \$autoSegmentStretch,
	    "autoSegmentNames=s"  =>  \$autoSegmentNames,
            "autoSmoothZ=f" => \$zAutoSmooth,
            "autoSpacing"   => \$autoSpacing,
            "circleStart=f{1,1000}" => \@circleStart,
            "circleEnd=f{1,1000}" => \@circleEnd,
            "circleStop=f{1,1000}" => \@circleEnd,
            "circle=f{1,1000}" => \@circle,
            "closed"        => \$copyPoint,
            "copyPoint"     => \$copyPoint,
            "copyright=s"   => \$copyright,
            "crop=f"        => \$cropMax,
            "cropEnd=f"     => \$cropMax,
            "cropMax=f"     => \$cropMax,
            "cropMin=f"     => \$cropMin,
            "cropStart=f"     => \$cropMin,
            "crossingAngle=f" => \$crossingAngle,
            "crossingHeight=f" => \$crossingHeight,
            "crossingTransition=f" => \$crossingTransition,
            "csv"           => \$csv,
            "description=s" => \$description,
	    "disableAdvancedSmoothing=i" => \$disableAdvancedSmoothing,
	    "disableElevationFixes=i"    => \$disableElevationFixes,
	    "enableAdvancedSmoothing"    => \$enableAdvancedSmoothing,
	    "enableElevationFixes"       => \$enableElevationFixes,
            "extend=f"      => \$extend,
            "extendBack=f"  => \$extendBack,
            "finishCircuits=i"  => \$finishCircuits,
            "finishCircuitDistance=f" => \$finishCircuitDistance,
            "fixCrossings"      => \$fixCrossings,
            "flatten=f{1,1000}" => \@flatten,
            "gradientPower=f"   => \$gradientPower,
            "gradientThreshold=f"  => \$gradientThreshold,
            "h"             => \$needHelp,
            "help"          => \$needHelp,
            "join=s{1,100}" => \@join,
            "keywords=s"    => \$newKeywords,
            "interpolate=f" => \$spacing,
            "laneShift=f"   => \$laneShift,
            "lap"           => \$isLoop,
            "loop"          => \$isLoop,
	    "maxSlope=f" => \$maxSlope,
            "minRadius=f"   => \$minRadius,
            "minRadiusStart=f" => \$minRadiusStart,
            "minRadiusEnd=f"   => \$minRadiusEnd,
            "name=s"        => \$title,
            "noSave"        => \$noSave,
            "out=s"         => \$outFile,
            "prepend=f"     => \$prepend,
            "prune"         => \$prune,
            "pruneD=f"      => \$pruneD,
            "pruneX=f"      => \$pruneX,
            "prunedg=f"     => \$prunedg,
            "quiet"         => \$quiet,
            "rCrossings=f"  => \$rCrossings,
            "reverse"       => \$reverse,
            "rLap=f"        => \$rLap,
            "rTurnaround=f" => \$rTurnaround,
            "rUTurn=f"      => \$rUTurn,
	    "segment=s"     =>  \$namedSegments,
	    "segments=s"    =>  \$namedSegments,
            "shiftEnd=f"    => \$shiftEnd,
            "shiftSF=f"     => \$shiftSF,
            "shiftStart=f"  => \$shiftStart,
            "sigma=f"       => \$lSmooth,
            "sigmaz=f"      => \$zSmooth,
            "smooth=f"      => \$lSmooth,
            "smoothAngle=f" => \$smoothAngle,
            "smoothEnd=f"   => \$smoothEnd,
            "smoothStart=f" => \$smoothStart,
            "smoothz=f"     => \$zSmooth,
            "snap=i"        => \$snap,
            "snapDistance=f" => \$snapDistance,
            "snapTransition=f" => \$snapTransition,
            "snapAltitude=f" => \$snapAltitude,
            "snapZ=f"       => \$snapAltitude,
            "spacing=f"     => \$spacing,
            "splineDegs=f"  => \$splineDegs,
            "splineMaxDegs=f" => \$splineMaxDegs,
            "startCircuits=i"  => \$startCircuits,
            "startCircuitDistance=f" => \$startCircuitDistance,
            "startTime=s"   => \$startTime,
            "straight=f{1,1000}" => \@straight,
            "straightStart=f{1,1000}" => \@straightStart,
            "straightEnd=f{1,1000}" => \@straightEnd,
            "straightStop=f{1,1000}" => \@straightEnd,
	    "stripSegments" => \$stripSegments,
            "title=s"       => \$title,
            "version"       => \$vFlag,
            "v"             => \$vFlag,
            "zOffset=f"     => \$zOffset,
            "zScale=f"      => \$zScale,
            "zShift=f"      => \$zShift,
            "zShiftEnd=f"   => \$zShiftEnd,
            "zShiftStart=f" => \$zShiftStart,
            "zSmooth=f"     => \$zSmooth,
            "zsigma=f"      => \$zSmooth,
           )
  or die("$0: ERROR processing command line options\n");


if ($needHelp) {
  pod2usage(-exitval=>0, -verbose=>2);
}

if ($vFlag ) {
  warn("$0: version $version\n");
  exit 0;
}

my @namedSegments    = split(";", $namedSegments);
my @autoSegmentNames = split("[,;]", $autoSegmentNames);

# convert max slope to percent
$maxSlope *= 100 if ($maxSlope < 1);

for my $s ( @autoSegmentNames ) {
  $s =~ s/^\s*(.*?)\s*$/$1/;
}

# proc to print user messages
# here so it can access $quiet as a global variable
sub note {
  warn(@_) unless ($quiet);
}

# if extendBack is specified, we need a turnaround loop... calculate crop
# later
$rTurnaround //= 0;
$rTurnaround = 5
  if (($extendBack > 0) && ($rTurnaround <= 0));

die("Crop window minimum exceeds crop window maximum\n")
  if ((defined $cropMin) && (defined $cropMax) && ($cropMax > 0) && ($cropMin > $cropMax));

warn("WARNING: if snapping distance ($snapDistance) is more than smoothing distance ($lSmooth), then abrupt transitions between snapped and unsnapped points may occur\n")
  if (($snap > 0) && ($snapDistance > $lSmooth));

if ($isLoop && ($rTurnaround > 0)) {
  warn("WARNING: ignoring -lap or -loop option when rTurnaround > 0\n");
  $isLoop = 0;
}

# csv option can be inferred from filename, if specified
if (defined $outFile) {
  $csv = 1 if ($outFile =~ /csv$/i);
  $csv = 0 if ($outFile =~ /gpx$/i);
}

# apply extend
$prepend += $extend;
$append  += $extend;

# autospacing triggered if max angle specified
my $smoothRadians;
if ((defined $smoothAngle) && ($smoothAngle <= 0)) {
  $smoothAngle = 20;
  $autoSpacing //= 1;
}
if ($autoSpacing) {
  $smoothAngle //= 20;
  $smoothRadians = $smoothAngle * $deg2rad;
}

my $splineRadians = $splineDegs * $deg2rad;
my $splineMaxRadians = $splineMaxDegs * $deg2rad;

my @files = @ARGV;
@files = ("-") unless (@files);

die("output file name can be specified only if one input file is specified: either use default output file name, or run files one at a time.\n")
  if ((@files > 1) && ($outFile ne ""));

for my $file ( @files ) {
  open my $fin, "<$file"
    or die("ERROR opening file $file");
  my $xml;
  {
    my $tmp = $/;
    $/ = undef;
    $xml = <$fin>;
    $/ = $tmp;
  }
  close $fin;

  # Parse GPX from open file
  my $gpx = Geo::Gpx->new( xml => $xml );

  # get segment names indexed by track and segments
  my $extensions = getExtensions(\$xml);
  $extensions->{"rgt:maxSlope"} = $maxSlope;   # set the maximum slope
  if ($disableElevationFixes != 0) {
    $extensions->{"rgt:disableElevationFixes"} = 1;
  }
  if ($disableAdvancedSmoothing != 0) {
    $extensions->{"rgt:disableAdvancedSmoothing"} = 1;
  }
  if ($enableElevationFixes) {
    $extensions->{"rgt:disableElevationFixes"} = 0;
  }
  if ($enableAdvancedSmoothing) {
    $extensions->{"rgt:disableAdvancedSmoothing"} = 0;
  }
  my $waypoints = $gpx->waypoints();
  my $tracks    = $gpx->tracks();

  # process tracks
  my $nTrack = 0;
  for my $track ( @$tracks ) {
    $nTrack ++;

    # list of segments in the present track
    my $segments = $track->{segments};

    # segments:
    # $segments: pointer to segments in the GPX data
    # @segmentPoints: list of segments
    # points->{segment}: ID of the segment associated with each point
    # initially the segment ID = segment index
    # this may change if segments are modified

    # add segment field to points
    my $points = [];

    my $nSegment = 0;
    my %segmentDefined;
    my %segmentName;   # names of each segment

    for my $segment ( @$segments ) {
      $nSegment ++;
      $segmentDefined{$nSegment} ++;

      my $segmentName = $extensions->{segmentName}->{$nTrack}->{$nSegment};
      $segmentName{$nSegment} = $segmentName;
      note("processing segment $nSegment ...\n");
      note("segment name = $segmentName\n") if ( (defined $segmentName) && ($segmentName ne "") );

      for my $p ( @{$segment->{points}} ) {
        $p->{segment} = ($stripSegments ? 0 : $nSegment);
	push @$points, $p;
      }
      note("total points after segment $nSegment = ", scalar(@$points), "\n");
    }
    note("points in original GPX track = ", scalar(@$points), "\n");
    note("altitude quality score of original course = ",
	 sprintf("%.4f", calcQualityScore(points=> $points, isLoop=> $isLoop)), "\n");

    # eliminate duplicate x,y points
    $points = removeDuplicatePoints(points=> $points);

    # if join was specified, join points from a second file
    if ( $nTrack == 1 ) {
      for my $join ( @join ) {
	note("joining file $join to the end of tfile $file...\n");
	open my $fjoin, "<$join"
	  or die("ERROR opening file $join");
	my $xml2;
	{
	  my $tmp = $/;
	  $/ = undef;
	  $xml2 = <$fjoin>;
	  $/ = $tmp;
	}
	close $fin;

	# Parse GPX from open file
	my $gpx2 = Geo::Gpx->new( xml => $xml2 );

	# get segment names indexed by track and segments
	my $extensions2 = getExtensions(\$xml2);

	# Parse GPX from open file
	my $waypoints2 = $gpx2->waypoints();
	my $tracks2    = $gpx2->tracks();

	# just use the first track on a joined file
	my $track2 = $tracks2->[0];

	# segments for the joined file
	my $segments2  = $track2->{segments};

	my $points2 = [];

	my $nSegment0 = $nSegment;
	for my $segment ( @$segments2 ) {
	  $nSegment ++;

	  for my $p ( @{$segment->{points}} ) {
	    $p->{segment} = ($stripSegments ? 0 : $nSegment);
	    push @$points2, $p;
	  }
	}

	# add in segment extensions to the main extensions
	if ((! $stripSegments) && (defined $extensions2) && (defined $extensions2->{segmentName}->{1})) {
	  for my $s ( keys %{$extensions2->{segmentName}->{1}} ) {
	    my $nS = $nSegment0 + $s;
	    $segmentName{$nS} = $extensions2->{segmentName}->{1}->{$s};
	    $segmentDefined{$nS} ++;
	  }
	}

	push @$points, @$points2;
      }
      note("points in joined GPX track = ", scalar(@$points), "\n");
    }


    #
    # auto: auto option will turn on options based on the course
    #

    if ( $auto ) {
      note("auto-setting options...\n");
      if (
          (! $isLoop) &&
          (latlngDistance($points->[0], $points->[-1]) < 150) &&
          (@$points > 3) &&
          (latlngDotProduct($points->[-2], $points->[-1], $points->[0], $points->[1]) > -0.1)
         ) {
        $isLoop = 1;
        $copyPoint = 1;
        note("setting -loop\n");
      }

      my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);

      # calculate position interpolation
      if ( $spacing <= 0 ) {
        $spacing = 3 * (1 + $courseDistance / 250) ** (1/4);
        note("setting spacing to ", sprintf("%.3f", $spacing), " meters (distance = ", sprintf("%.3f", $courseDistance / 1000), " km)\n");
      }

      # smoothing
      if ( $lSmooth <= 0 ) {
        $lSmooth = 7;
        note("setting smoothing to $lSmooth meters\n");
      }

      # other options
      if (! $autoSpacing) {
        note("setting -autoSpacing...\n");
        $autoSpacing = 1;
      }
      if (! defined $smoothAngle) {
        $smoothAngle = 20;
        note("setting -smoothAngle $smoothAngle ...\n");
      }
      $smoothRadians = $smoothAngle * $deg2rad;

      if ($minRadius == 0) {
        $minRadius = 6;
        note("setting minimum corner radius to $minRadius ...\n");
      }
      if (! $prune) {
        note("setting -prune ...\n");
        $prune = 1;
      }
      if ($zSmooth == 0) {
        $zSmooth = 15;
        note("setting altitude smoothing to $zSmooth meters\n");
      }
      if (! $anchorSF) {
        $anchorSF = 1;
        note("setting -anchorSF ...\n");
      }
      if (! $fixCrossings) {
        note("setting -fixCrossings ...\n");
        $fixCrossings = 1;
      }
      if (! defined  $rUTurn) {
        $rUTurn = 5;
        note("setting -RUTurn 5 (meters) ...\n");
      }
      if ($snap == 0) {
        $snap = 1;
        note("setting -snap 1 ...\n");
      }
      if ($snapTransition <= 0) {
        $snapTransition = 10;
        note("setting -snapTransition $snapTransition (meters) ...\n");
      }
      $disableAdvancedSmoothing = 1;
      note("setting -disableAdvancedSmoothing ...\n");
      $disableElevationFixes = 1;
      note("setting -disableElevationFixes ...\n");
    }


    #
    # check if loop specified for apparent point-to-point
    #

    if ($isLoop) {
      my $d =latlngDistance($points->[0], $points->[-1]);
      warn("WARNING: -loop or -lap specified, with large ($d meter) distance between first and last point: are you sure you wanted -loop or -lap?\n")
        if ($d > 150);
    }

    #
    # zig-zags: pairs of 180 degree turns within a certain distance are probably misplaced control points
    # this is just a warning for now... easy to fix if it's along a line, but what if it goes around a corner?
    #
    {
      note("checking for zig-zags...\n");
      my $dzigzag = 100;
      my @UTurns = ();
      for my $i ( 1 .. $#$points - 1 ) {
        push @UTurns, $i
          if (UTurnCheck($points->[$i - 1], $points->[$i], $points->[$i], $points->[$i + 1], -0.9));
      }

      addDistanceField(points=> $points);
      if (@UTurns) {
        my $zigzagCount = 0;
        while ( @UTurns > 1 ) {
          my $U1 = shift @UTurns;
          my $U2 = $UTurns[0];
          my $p1 = $points->[$U1];
          my $p2 = $points->[$U2];

          if ($p2->{distance} - $p1->{distance} < $dzigzag) {
            warn("WARNING: zig-zag found on points (0, 2, 3 ...) : ",
                 $U1, " and ", $U2, " : ",
                 sprintf("%.4f km: (%g, %g)", 0.001 * $p1->{distance}, $p1->{lon}, $p1->{lat}),
                 " to ",
                 sprintf("%.4f km: (%g, %g)", 0.001 * $p2->{distance}, $p2->{lon}, $p2->{lat}),
                 " : separation = ", sprintf("%.4f", $p2->{distance} - $p1->{distance}), " meters\n");

            # repairing zig-zags...
            # zig-zags are two U-turns within a specified distance
            # p1 -> p2 -> ... ->  p3 -> p4
            # U-turn @ p2, and U-turn @ p3
            # 1. eliminate all points between p2 and p3
            # 2. as long as P3 has a U-turn, delete it... there will be a new P3
            # 3. as long as P2 has a U-turn, delete it...
            # 4. go back step 2 if we deleted any U-turns

            # eliminate points between
            warn("repairing zig-zag...\n");
            my $u = $U1;        # keep points up to u
            my $v = $U2 + 1;    # keep points starting with v
            $v ++
              while (
                     ($v < $#$points) &&
                     UTurnCheck($points->[$u], $points->[$v], $points->[$v], $points->[$v + 1])
                    );

            warn("eliminating ", $v - $u - 1, " points\n");
            $zigzagCount ++;

            my @pNew = @$points[0 .. $u];
            push @pNew, @$points[$v .. $#$points];

            # if we ran out of points, something is wrong
            die("repairing zig-zags eliminated entire route\n")
              if (@pNew < 2);

            $points = \@pNew;

            # adjust U-turn coordinates
            # We've eliminated the next Uturn, so pop it
            shift @UTurns;

            # adjust coordinates of remaining U-turns
            for my $U ( @UTurns ) {
              $U += $u - $v + 1;
            }

            # get rid of obsolete U-turns
            shift @UTurns
              while (@UTurns && ( $UTurns[0] < 0));
          }
        }
        # may need to redo distance if zig-zag repair
        addDistanceField(points=> $points)
          if ($zigzagCount > 0);
      }
    }

    # look for loops
    {
      note("checking for loops...\n");
      my $loopDistance = 100;
      # add direction field: distance field was just calculated by zig-zag check
      addDirectionField(points=> $points, isLoop=> $isLoop);
      my $u = 0;
      my $v = 0;
      my $loopAngle = 0.7 * $twopi;
      while ($v < $#$points) {
        my $p = $points->[$u];
        $v ++ while (($v < $#$points) && ($points->[$v + 1]->{distance} < $p->{distance} + $loopDistance));
        if (abs($p->{direction} - $points->[$v]->{direction}) > $loopAngle) {
          $u ++ while (($u + 1 < $v) && (abs($points->[$u + 1]->{direction} - $points->[$v]->{direction}) > $loopAngle));
          warn("WARNING: loop between distance: ", sprintf("%.3f km and %.3f km", $points->[$u]->{distance} / 1000, $points->[$v]->{distance} / 1000), "\n");
          $u = $v;
          next;
        }
        $u ++;
      }
      deleteField(field=> "direction", points=> $points);
    }

    # adjust altitudes if requested
    if (($zOffset != 0) || ($zScale != 1)) {
      note("transforming altitude...\n");
      for my $p ( @$points ) {
        $p->{ele} = ($p->{ele} + $zOffset) * $zScale;
      }
    }
    if ( (defined $zShift) && ($zShift != 0) ) {
      # transition set to change gradient by up to 5%
      note("applying z shift = $zShift\n");
      note("zShift start = $zShiftStart\n") if (defined $zShiftStart);
      note("zShift end = $zShiftEnd\n") if (defined $zShiftEnd);
      my $zShiftDistance = 20 * (1 + abs($zShift));
      for my $p ( @$points ) {
        my $s = $p->{distance};
        my $dz = $zShift;
        if ( (defined $zShiftStart) && (defined $zShiftEnd) && ($zShiftEnd < $zShiftStart) ) {
          $dz *= (transition(($zShiftStart - $s) / $zShiftDistance) + transition(($s - $zShiftEnd) / $zShiftDistance));
        } else {
          $dz *= transition(($zShiftStart - $s) / $zShiftDistance) if (defined $zShiftStart);
          $dz *= transition(($s - $zShiftEnd) / $zShiftDistance)   if (defined $zShiftEnd);
        }
        $p->{ele} += $dz;
      }
    }

    # reverse the points of the original course
    # points reference segments so segments order is also reversed
    if ($reverse) {
      note("reversing course direction..\n");
      @$points = reverse @$points;
    }

    # start and finish circuits
    # note this could create segment fragments
    my $circuitsAdded = 0;
    if ( ($startCircuits > 0) && ($startCircuitDistance >= 0) ) {
      note("adding $startCircuits start circuits...\n");
      # get start circuit points
      my @circuitPoints = ();
      addDistanceField(points=> $points) unless ( defined $points->[0]->{distance} );
      my $i = 0;
      while ($i <= $#$points) {
        if ($points->[$i]->{distance} <= $startCircuitDistance) {
          note("adding point to circuit list...\n");
          push @circuitPoints, \%{$points->[$i]};
          $i ++;
        } else {
          last;
        }
      }
      if (@circuitPoints) {
        my @newPoints;
        for my $i (1 .. $startCircuits) {
          push @newPoints, @circuitPoints;
          note("adding circuit point...\n");
          $circuitsAdded ++;
        }
        push @newPoints, @$points;
        $points = \@newPoints;
      }
    }
    if ( ($finishCircuits > 0) && ($finishCircuitDistance >= 0) ) {
      note("adding $finishCircuits finishing circuits...\n");
      addDistanceField(points=> $points) unless ( defined $points->[0]->{distance} );
      my @circuitPoints = ();
      my $i = 0;
      for my $p ( @$points ) {
        if ($p->{distance} < $finishCircuitDistance) {
          next;
        }
        push @circuitPoints, \%$p;
      }
      if (@circuitPoints) {
        for my $i (1 .. $finishCircuits) {
          push @$points, @circuitPoints;
          $circuitsAdded ++;
        }
      }
    }
    addDistanceField(points=> $points) if ($circuitsAdded > 0);

    # check for snapping
    if ( ($snap > 0) && ($snapDistance >= 0) ) {
      note("snapping repeated points...\n");

      # snap = 1: subsequent laps snap to position of earlier laps
      # snap = 2: earlier laps snap to position of layer laps
      # snap 2 can be handled by reversing points, then doing snap, then reversing back
      #
      # snapping can happen either on sections done in the same direction, or in opposite directions
      #

      # if we're snapping later for earlier, flip points
      if ( $snap == 2 ) {
        @$points = reverse(@$points);
      }

      # on large courses, since initial search is O(N-squared), step thru multiple points, then refine
      # snap step 1 has a potential bug (infinite loop) so lower bound is 2
      my $snapStep = 2 + int(scalar(@$points) / 200);

      #
      # maximum range at which we check for snapping...
      # so if colinear points are spaced more than twice this, we may miss snapping onto that interval
      #
      my $snapRange = ($spacing > 0) ? $snapStep * $spacing : 100;
      $snapRange  = 100 if ($snapRange > 100);

      # threshold for checking if points are close for snapping
      my $dsClose = $snapDistance / 2;

      # i is on the "earlier" segment, j on the "later" segment
      # note this excludes starting point and end point
    iLoop: for ( my $i = 0; $i < $#$points - 1; $i += $snapStep ) {
        my $p1 = $points->[$i];
        my @jCount;

        my $j = $i + $snapStep;
        next iLoop if ( $j > $#$points);

        # get out of snap range: get point j beyond the snap range of point i
        # this is geometric distance, not course distance, which could potentially be an issue
        my $d = 0;
        while ( ($d = latlngDistance( $p1, $points->[$j] ) ) <= $snapRange ) {
          $j += $snapStep;      # use big jumps to save time
          next iLoop if ($j >= $#$points);
        }

        # keep going until distance between j and i stops increasing
        while ( (my $d2 = latlngDistance( $p1, $points->[$j] ) ) >= $d ) {
          $d = $d2;
          $j += $snapStep;
          next iLoop if ($j >= $#$points);
        }

        # keep moving until j comes back into snap range of i
      jLoop1: while ( $j <= $#$points) {
          # make sure we don't try the same value twice (moving forward and backward could cause this)
          next iLoop
            if ($jCount[$j] ++);

          # looking for j sufficiently close to i and connected with less than a 30% slope
          # slope requirement avoids snapping across tight switchbacks or a hypothetical "spiral"
          while ((($d = latlngDistance( $p1, $points->[$j])) > $snapRange ) || (abs($p1->{ele} - $points->[$j]->{ele}) > $snapAltitude + 0.3 * $d)) {
            $j += $snapStep;
            next iLoop if ($j >= $#$points);
          }

          # find local minimum of distance... reduced step distance to 1
        jLoop2: while ( $j <= $#$points ) {
            $d = latlngDistance( $p1, $points->[$j] );
            # distance to point forward
            my $df = latlngDistance( $p1, $points->[$j + 1] )
              if ( $j < $#$points );
            # distance to point backward
            my $db = latlngDistance( $p1, $points->[$j - 1] )
              if ( $j > 0 );
            if ( (defined $df) && ($df < $d) ) {
              $j ++;
              next jLoop2;
            }
            if ( (defined $db) && ($db < $d) ) {
              $j --;
              next jLoop2;
            }
            last jLoop2;
          }


          # we've now brought point j close to point i.  This could be fooled with a sufficiently complicated
          # route, but so far it seems to work fairly well

          # check altitude.  If altitude is out of range, maybe we're across a tight swichback, or there's a bridge or tunnel
          # this was already done previously, but now we're closer
          if (abs($p1->{ele} - $points->[$j]->{ele}) > 1 + 0.3 * $d) {
            $j += $snapStep;
            next jLoop1;
          }

          #
          # we've got a possible point match between two points.
          # check dot products
          # the lines need to be in similar directions
          #
          # set direction for checking dot product
          my $di = 0;
          if (( $j < $#$points ) && ( $i < $#$points )) {
            $di = 1;
          } elsif (( $j > 0 ) && ( $i > 0 )) {
            $di = -1;
          } else {
            next iLoop;
          }
          my $p2 = $points->[$i + $di];
          my $p3 = $points->[$j];
          my $p4 = $points->[$j + $di];

          # dot product
          # dot product = 1: same direction
          # dot product = -1: opposite direction
          # dot product close to zero: intersection, perhaps -- ignore
          # set for 45 degree angle right now
          my $dot = latlngDotProduct($p1, $p2, $p3, $p4);
          my $sign;
          if ( $dot > 0.7 ) {
            $sign = 1;
          } elsif ($dot < -0.7 ) {
            $sign = -1;
          } else {
            # vectors are relatively perpendicular, move on
            $j += $snapStep;
            next jLoop1;
          }

          # point i is matched to point j, and the two are moving in the same direction
          # for each point j, if it falls on a line of points i, then replace the nearest point i

          # first we need to find values of j which are encapsulated by i
          # j will be replaced by i
          my ($ja, $jb);
        jLoop2: while(1) {
            # search range near j: j was point nearest i so it should be close
            # nearest found the nearest point, but we're looking for the segment,
            # and the nearest point may not mark the intersecting segment, so check proximity
            for my $ja ( $j, $j - $sign, $j + $sign, $j - 2 * $sign ) {
              $jb = $ja + $sign;

              # checking if point i falls on the line between ja and jb
              if (
                  roadTest(
                           $points,
                           $ja - 1,
                           $ja,
                           $jb,
                           $jb + 1,
                           $i,
                           $snapDistance
                          )
                 ) {
                $j = $jb;
                last jLoop2;
              }
            }
            # didn't find a match... move to next point
            next iLoop;
          }

          my $j1 = $j - $sign;
          my $j2 = $j;

          # starting point:
          # j1 ... i1 ... i2 ... j2
          # i's are encapsulated by j's
          # initial point is we have only a single point i1 = i2 = i
          # j2 = $j1 + 1
          # algorithm:
          # shift down i1 as long as it remains in range j1 .. j2....  and i1 >= 0
          # extend downward:
          #   1. test point: iTest = i1 - 1, jTest = j1... we know iTest is outside range j1 .. j2
          #   2. decrease jTest while iTest .. jTest .. i1 and jTest > i1
          #   3. decrease jTest if new jTest .. iTest .. j1
          #   4. if this was successful, then j1 = jTest, i1 = iTest
          #   5. shift down i1 as long as j1 .. i1 ... j1 + 1
          #   repeat until failure
          #
          # extend upward: similar, but up
          #   1. shift up i2 as long as it remains in range j1 .. j2....  and i2 <= j1

          my $i1 = $i;
          my $i2 = $i;

          # keep shifting boundaries until we don't expand them anymore
          my ($flag1, $flag2);

          do {
            # shift i1 down as long as along line from j1 to j2
            $i1 --
              while (
                     ($i1 > 0) &&
                     roadTest(
                              $points,
                              $j1 - $sign,
                              $j1,   # point 1
                              $j2,   # point 2
                              $j2 + $sign,
                              $i1 - 1, # test point
                              $snapDistance
                             )
                    );

            # as long as they are coincident, increase i1 and j1 together (short cut)
            while ( ($i1 > 0) && ($j1 > $i2) && ($j1 < $#$points) && pointsAreClose($points->[$i1 - 1], $points->[$j1 - $sign], $dsClose, $snapAltitude) ) {
              $i1 --;
              $j1 -= $sign;
            }

            # shift up i2 down as along line from j1 to j2
            $i2 ++
              while (
                     ($i2 < $j1) &&
                     roadTest(
                              $points,
                              $j1 - $sign,
                              $j1,   # point 1
                              $j2,   # point 2
                              $j2 + $sign,
                              $i2 + 1, # test point
                              $snapDistance
                             )
                    );

            # as long as they are coincident, increase i1 and j1 together (short cut)
            while ( ($i2 < $j1) && ($j2 > $i2) && ($j2 < $#$points) && pointsAreClose($points->[$i2 + 1], $points->[$j2 + $sign], $dsClose, $snapAltitude) ) {
              $i2 ++;
              $j2 += $sign;
            }

            $flag1 = 0;
            my $iTest = $i1 - 1;
            if ($iTest > 0) {

              # push jTest up against iTest
              my $jTest = $j1;
              $jTest -= $sign
                while (
                       ($jTest > $i2) &&
                       ($jTest < $#$points) &&
                       roadTest(
                                $points,
                                $iTest - 1,
                                $iTest,       # point 1
                                $iTest + 1,   # point 2
                                $iTest + 2,
                                $jTest - $sign, # test point
                                $snapDistance
                               )
                      );

              # hop jTest past iTest: test that iTest lays in line of j points
              $jTest -= $sign
                if (
                    ($jTest > $i2) &&
                    ($jTest < $#$points) &&
                    ($flag1 =
                     roadTest(
                              $points,
                              $jTest - 2 * $sign,
                              $jTest - $sign, # point 1
                              $jTest,         # point 2
                              $jTest + $sign,
                              $iTest, # test point
                              $snapDistance
                             )
                    )
                   );


              if ($flag1) {
                $j1 = $jTest;
                $i1 = $iTest;
              }
            }

            $flag2 = 0;
            $iTest = $i2 + 1;
            if ($iTest >= $j1) {
              my $jTest = $j2;

              # push jTest up against iTest (it's between j2 and jTest)
              $jTest += $sign
                while (
                       ($jTest > $iTest) &&
                       ($jTest < $#$points) &&
                       roadTest(
                                $points,
                                $iTest - 2,
                                $iTest - 1, # point 1
                                $iTest,     # point 2
                                $iTest + 1,
                                $jTest + $sign, # test point
                                $snapDistance
                               )
                      );
              # hop past iTest
              $jTest += $sign
                if (
                    ($jTest > $iTest) &&
                    ($jTest < $#$points) &&
                    ($flag2 =
                     roadTest(
                              $points,
                              $jTest - $sign,
                              $jTest,           # point 1
                              $jTest + $sign,   # point 2
                              $jTest + 2 * $sign,
                              $iTest, # test point
                              $snapDistance
                             )
                    )
                   );

              if ($flag2) {
                $j2 = $jTest;
                $i2 = $iTest;
              }
            }
          } while ($flag1 || $flag2);

          # splice in the snapped points
          # irange encapsulates j range
          # may need to retain outer points of j range if they're not duplicated by points in irange

          # avoid duplicate points at ends of range
          # this is the same independent of sign: i1 connects with j1, i2 connects with j2
          $i1 ++ while (($i1 < $i2) && pointsAreClose($points->[$i1], $points->[$j1]));
          $i2 -- while (($i2 > $i1) && pointsAreClose($points->[$i2], $points->[$j2]));

          if ($i1 >= $i2) {
            $j += $snapStep;
            next jLoop1;
          }

          die "zero sign encountered\n" if ($sign == 0);

          # now check for zig-zags at start... algorithm shouldn't allow them.
          while (1) {
            my $p1 = $points->[$j1];
            my $p2 = $points->[$i1];
            my $p3 = $points->[$i1 + 1];
            last if ((defined $p1) && (defined $p2) && (defined $p3) && (latlngDotProduct($p1, $p2, $p2, $p3) > -0.9));
            $i1 ++;
            if ($i1 >= $i2) {
              $j += $snapStep;
              next jLoop1;
            }
          }

          # now check for zig-zags at end... algorithm shouldn't allow them.
          while (1) {
            my $p1 = $points->[$j2];
            my $p2 = $points->[$i2];
            my $p3 = $points->[$i2 - 1];
            last if ((! defined $p1) || (! defined $p2) || (! defined $p3) || (latlngDotProduct($p1, $p2, $p2, $p3) > -0.9));
            $i2 --;
            if ($i1 >= $i2) {
              $j += $snapStep;
              next jLoop1;
            }
          }

          if (($i2 > $i1) && (abs($j2 - $j1) > 0)) {
            note("i = $i, j = $j: snapping ", ($sign > 0) ? "forward" : "reverse", " segment: $i1 .. $i2 <=> $j1 .. $j2\n");

            my @pNew;
            if ( $sign > 0 ) {
              # keep everything up to start of j range
              @pNew = @$points[0 .. $j1];
              # splice in i range (exclude end-points)
	      # try to match up segments if possible
	      # segment matching by relative distance, but we need to nudge if we encounter a duplicate
	      my $j = $j1;
	      for my $i ( $i1 .. $i2 ) {
		$j ++ if (($j < $j2) && (abs($points->[$i]->{distance} - $points->[$i - 1]->{distance}) < 0.05));
		$j++
		  while (
			 ($j < $j2) &&
			 (
			  abs(abs($points->[$j + 1]->{distance} - $points->[$j1]->{distance}) - abs($points->[$i]->{distance} - $points->[$i1]->{distance})) <
			  abs(abs($points->[$j]->{distance} - $points->[$j1]->{distance}) - abs($points->[$i]->{distance} - $points->[$i1]->{distance}))
			 )
			);
		my %p = %{$points->[$i]};
		$p{segment} = $points->[$j]->{segment};
		push @pNew, \%p;
	      }
              push @pNew, @$points[$j2 .. $#$points]; # keep everything which follows j range
            } else {
              @pNew = @$points[0 .. $j2];
	      my $j = $j2;
	      for my $i ( reverse($i1 .. $i2) ) {
		$j ++ if (($j < $j1) && (abs($points->[$i]->{distance} - $points->[$i - 1]->{distance}) < 0.05));
		$j++
		  while (
			 ($j < $j1) &&
			 (
			  abs(abs($points->[$j + 1]->{distance} - $points->[$j1]->{distance}) - abs($points->[$i]->{distance} - $points->[$i1]->{distance})) <
			  abs(abs($points->[$j]->{distance} - $points->[$j1]->{distance}) - abs($points->[$i]->{distance} - $points->[$i1]->{distance}))
			 )
			);
		my %p = %{$points->[$i]};
		$p{segment} = $points->[$j]->{segment};
		push @pNew, \%p;
	      }
              push @pNew, @$points[$j1 .. $#$points];
            }
            $points = \@pNew;
          }

          # snap transition...
          # adjust altitude...
          # the first pass goes from i1 to i2
          # the replaced portion goes from j3 to j4
          # for points beyond this range, transition the altitude
          # this presently does not work with loops
          if ( $snapTransition > 0 ) {
            my $j3 = (($sign > 0) ? $j1 : $j2) + 1;
            my $j4 = $j3 + $i2 - $i1 + 1;

            # d = 1: forward direction, -1: backard direction
            for my $d ( -1, 1 ) {
              my $s = 0;
              $i = ($d > 0) ? $i2 : $i1;
              my @sis = (0);
              my @is = ($i);
              while (($s < $snapTransition) && ($i > 0) && ($i < $#$points)) {
                $s += latlngDistance($points->[$i], $points->[$i + $d]);
                $i += $d;
                push @sis, $s;
                push @is, $i;
              }
              my $jd = $d * $sign;
              $j = ($jd > 0) ? $j4 : $j3;
              my @sjs = (0);
              my @js = ($j);

              $s = 0;
              while (($s < $snapTransition) && ($j > 0) && ($j < $#$points)) {
                $s += latlngDistance($points->[$j], $points->[$j + $jd]);
                $j += $jd;
                push @sjs, $s;
                push @js, $j;
              }
              # step thru and adjust altitudes
              my $u = 0;
              my $v = 0;
              my @zis   = ( $points->[$is[0]]->{ele} );
              my @zjs   = ( $points->[$js[0]]->{ele} );
              while (($u < $#sis) && ($v < $#sjs)) {
                my $i = $is[$u];
                my $j = $js[$v];
                if ($sis[$u + 1] < $sjs[$v + 1]) {
                  $u ++;
                  # interpolate the point onto the other interval
                  my $f = ($sis[$u] - $sjs[$v]) / ($sjs[$v + 1] - $sjs[$v]);
                  my $z0   = (1 - $f) * $points->[$js[$v]]->{ele} + $f * $points->[$js[$v + 1]]->{ele};
                  # note: in limit of being close to the snapped section, altitude is average of two branches, then it diverges
                  my $g = ( 1 + cos($pi * $sis[$u] / $snapTransition) ) / 4; # from 0.5 to 0
                  die "negative g!" if ($g < 0);
                  my $z1 = $points->[$is[$u]]->{ele};
                  $zis[$u] = $g * $z0 + (1 - $g) * $z1;
                } else {
                  $v ++;
                  my $f = ($sjs[$v] - $sis[$u]) / ($sis[$u + 1] - $sis[$u]);
                  my $z0   = (1 - $f) * $points->[$is[$u]]->{ele} + $f * $points->[$is[$u + 1]]->{ele};
                  my $g = ( 1 + cos($pi * $sjs[$v] / $snapTransition) ) / 4; # from 0.5 to 0
                  die "negative g!" if ($g < 0);
                  # note: in limit of being close to the snapped section, altitude is average of two branches, then it diverges
                  my $z1 = $points->[$js[$v]]->{ele};
                  $zjs[$v] = $g * $z0 + (1 - $g) * $z1;
                }
              }

              # assign the new elevations to the appropriate points
              for my $u ( 0 .. $#zis ) {
                $points->[$is[$u]]->{ele} = $zis[$u];
              }
              for my $v ( 0 .. $#zjs ) {
                $points->[$js[$v]]->{ele} = $zjs[$v];
              }
            }
          }
          # end of snap transition

          # jump to next ivalue outside of range if we did replacement
          # this isn't perfect, but note points in j range are changed, so
          # j indices are no longer valid: this is why need to jump to outer loop
          $i = $i2 if ($i2 > $i);
          next iLoop;
        }
      }

      if ( $snap == 2 ) {
        @$points = reverse(@$points);
      }
    }

    # spline of corners
    if ( $splineRadians > 0 ) {
      note("corner splines, pre-smoothing...\n");
      $points = addSplines(points=> $points, splineRadians=> $splineRadians, splineMaxRadians=> $splineMaxRadians, isLoop=> $isLoop);
    }

    # add distance field
    addDistanceField(points=> $points);
    my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);

    # automatic interpolation at corners
    if ( $autoSpacing && (($lSmooth > 0) || ($minRadius > 0)) ) {
      warn("ready for corner spacing processing: ", scalar @$points, " points\n");
      # iterate a few times
      for my $autoSpacingIteration ( 0 ) {
        # do this in each direction
        for my $direction (0, 1 ) {

          my @pNew = ();

	  # refine distance -- need to exceed the smoothing length
	  my $lambda = sqrt($minRadius ** 2 + $lSmooth ** 2);
	  my $dRefine = 3 * $lambda;

        iLoop: for my $i ( 0 .. $#$points ) {
            push @pNew, $points->[$i]; # temporarily put the latest point on the new points list

            # there's nothing behind the first point -- copy it to the last point to get refinement
            next iLoop
              if ( $i == 0 );

            if ( $isLoop || ($i < $#$points) ) {
              # find points which define an angle
              my $i1 = ($i - 1) % scalar(@$points);
              my $i2 = ($i + 1) % scalar(@$points);
              my $d1;
              my $d2;
              while (($d1 = latlngDistance($points->[$i1], $points->[$i])) < 0.01) {
                $i1 --;
                next iLoop
                  if ( ((! $isLoop) && ($i1 < 0)) || ($i1 == $i));
                $i1 %= scalar(@$points);
              }
              while (($d2 = latlngDistance($points->[$i2], $points->[$i])) < 0.01) {
                $i2 --;
                next iLoop
                  if (((! $isLoop) && ($i2 > $#$points)) || ($i2 == $i));
                $i1 %= scalar(@$points);
              }
              # determine the angle between the points
              my $a = latlngAngle($points->[$i1], $points->[$i], $points->[$i2]);

              # add points if needed
              die("ERROR: smoothRadians not defined (smoothAngle = $smoothAngle\n")
                unless(defined $smoothRadians);
              if ( abs($a) > abs($smoothRadians) ) {
                # refine spacing -- need to refine to sufficient resolution to resolve the angle
                # this was multipled by 0.5, but that generated too many points, so updating
                my $spacing = $lambda * (0.01 + abs($smoothRadians / $a));

                # tricky bit -- we need to insert points back to the desired range, but that may extend earlier than points
                # which we've already placed, so we'll need to keep track of points as we rewind.

                # find interval on which to add first point
                my $s = 0;
                my $i3 = $#pNew;
                my @ds;
                $ds[$i3] = 0;
              sLoop: while ($s < $dRefine) {
                  last sLoop if ($i3 <= 0);
                  $i3 --;
                  $ds[$i3] = latlngDistance($pNew[$i3], $pNew[$i3 + 1]);
                  $s += $ds[$i3];
                }

                # find the start point, between point i3 and i3 + 1
                my $f;
                if ($s > $dRefine) {
                  $f = ($s - $dRefine) / $ds[$i3]; # how far over the segment goes
                } else {
                  $f = 0;
                }

                # strip off the points beyond i3, to save for later
                my @pStack = ();
                push @pStack, pop @pNew
                  while ($#pNew > $i3);

                # add first point for corner smoothing, unless another point is close
		my $ff = 0.5 * $spacing / $ds[$#pNew]; # normalized spacing of new points
                if ( ($f > $ff) && ($f < 1 - $ff) ) {
                  push @pNew, interpolatePoint($pNew[-1], $pStack[-1], $f);
                  # adjust spacing to next point to account for interpolated point
                  $ds[$#pNew] = $ds[$#pNew - 1] * (1 - $f);
                  $ds[$#pNew - 1] *= $f;
                }

                # go thru points in stack, and adjust spacings
                while (@pStack) {
                  my $p1 = $pNew[-1];
                  my $p2 = $pStack[-1];
                  my $dsTot = latlngDistance($p1, $p2);
		  my $N = int($dsTot / $spacing  + 0.5);
                  if ($N > 0 ) {
                    $ds[$#pNew] = $dsTot / $N;
                    for my $n ( 1 .. $N - 1 ) {
                      push @pNew, interpolatePoint($p1, $p2, $n / $N);
                      $ds[$#pNew] = $dsTot / $N;
                    }
                  } else {
                    $ds[$#pNew] = $dsTot;
                  }
                  push @pNew, pop @pStack;
                  $ds[$#pNew] = 0;
                }
              }
            }
          }
          $points = [ reverse @pNew ];
	  warn("corner spacing step increased points to ", scalar @$points, "\n");
        }
      }
    }

    # interpolation if requested
    if ( @$points && ($spacing > 0) ) {
      note("interpolation..\n");
      my @pNew = ();
      my $iMax = $#$points - ($isLoop ? 0 : 1);
      for my $i ( 0 .. $iMax ) {
        my $p1 = $points->[$i];
        my $p2 = $points->[($i + 1) % @$points];
        push @pNew, $p1;
        my $ps = latlngDistance( $p1, $p2 );
        my $npoints = int( $ps / $spacing + 0.5);
        # interpolate points...
        for my $n ( 1 .. $npoints - 1 ) {
          push @pNew,  interpolatePoint( $p1, $p2, $n / $npoints);
        }
      }
      push @pNew, $points->[-1] unless ($isLoop);
      note("interpolation increased course from ", scalar @$points, " to ", scalar @pNew, " points\n");
      $points = \@pNew;
    }

    # straight processing
    # if circular fits are required, those should be done before smoothing, so smoothing can
    # reduce the anomalies.
    if (@straight || (@straightStart) || (@straightEnd)) {
      note("processing straight fit(s)...\n");
      processStraight(points=> $points, straight=> \@straight, straightStart=> \@straightStart, straightEnd=> \@straightEnd, isLoop=> $isLoop);
    }

    # straight processing
    # if circular fits are required, those should be done before smoothing, so smoothing can
    # reduce the anomalies.
    if (@circle || (@circleStart) || (@circleEnd)) {
      note("processing circular fit(s)\n");
      processCircle(points=> $points, circle=> \@circle, circleStart=> \@circleStart, circleEnd=> \@circleEnd, isLoop=> $isLoop);
    }

    # various smoothing passes:
    # 1  : position
    # 2  : altitude
    # 3  : reserved for position auto-smoothing (not implemented yet)
    # 4  : altitude auto-smoothing
    #
    # smoothing parameter with auto-smoothing is normalized,
    # so tuned for smoothing = 1 being reasonable choice

    # update distance field if we've got autosmoothing
    addDistanceField(points=> $points) if ($zAutoSmooth || $lAutoSmooth);

    # keep track of the first and last points, if anchoring is happening
    my @endPoints  = ($points->[0], $points->[-1]);

    for my $smoothLoop ( 0, 1, 3 ) {
      my %fsigma;
      my $smooth;
      my $autoSmooth;
      $smooth = $lSmooth     if ($smoothLoop == 0);
      $smooth = $zSmooth     if ($smoothLoop == 1);
      $smooth = $lAutoSmooth if ($smoothLoop == 2);
      $smooth = $zAutoSmooth if ($smoothLoop == 3);

      # scale factors
      if ( $smoothLoop % 2 == 0 ) {
        %fsigma = (
                   "ele" => 1,
                   "lat" => 1,
                   "lon" => 1,
                  );
      } elsif ( $smoothLoop % 2 == 1 ) {
        %fsigma = (
                   "ele" => 1,
                   "lat" => 0,
                   "lon" => 0,
                  );
      }
      my $autoSmoothing = ($smoothLoop > 1);

      my @keys = keys %fsigma;
      my $sumSigma2 = 0;

      #
      # smoothing is different than auto-smoothing
      # autosmoothing has a variable sigma, determined by the appropriate field
      # smoothing has a fixed sigma
      # try to share code....
      #

      if ( $smooth > 0 ) {
        note("smoothing...", ($smoothLoop==0) ? "position" : ($smoothLoop==1) ? "altitude" : ($smoothLoop==3) ? "altitude(auto)" : "other", ": parameter = $smooth\n");

        # calculate smoothing sigma for autosmoothing based on gradient
        calcSigma(points=> $points)
          if ($smoothLoop == 3);

        my @pNew;

        # step thru the points
        for my $i ( 0 .. $#$points ) {
          my $sigma0 = ($autoSmoothing ? $smooth * $points->[$i]->{sigma} : $smooth);

          # create smoothed data: initialize with unsmoothed data
          my %var = %{$points->[$i]};

          if ($sigma0 > 0) {
            # if smoothStart and/or smoothEnd are defined, then create a window for smoothing
            {
              my $smoothDistance = 4 * $sigma0;
              my $s = $points->[$i]->{distance};
              if ( (defined $smoothStart) && (defined $smoothEnd) && ($smoothEnd < $smoothStart) ) {
                $sigma0 *= (transition(($smoothStart - $s) / $smoothDistance) + transition(($s - $smoothEnd) / $smoothDistance));
              } else {
                $sigma0 *= transition(($smoothStart - $s) / $smoothDistance) if (defined $smoothStart);
                $sigma0 *= transition(($s - $smoothEnd) / $smoothDistance)   if (defined $smoothEnd);
              }
            }

            if (abs($sigma0) < 0.01) {
              push @pNew, $points->[$i];
              next;
            }

            my $dsMax = 4 * $sigma0;

            my $j = $i;
            my $s = 0;
            while ((($j > 0) || $isLoop) &&
                   ($j > $i - @$points) &&
                   ($s  < $dsMax)
                  ) {
              $s += latlngDistance( $points->[$j], $points->[$j - 1] );
              $j --;
            }

            $s = 0;
            my $k = $i;
            while ((($k < $#$points) || $isLoop) &&
                   ($k < $i + @$points) &&
                   ($s < $dsMax )
                  ) {
              $s += latlngDistance( $points->[$k % @$points], $points->[($k + 1) % @$points] );
              $k ++;
            }

            # create list of separations
            $s = 0;
            my @ss = (0);
            for my $ii ( $j .. $k - 1 ) {
              my $ds = latlngDistance($points->[($ii + 1) % @$points], $points->[$ii % @$points]);
              $s += $ds;
              push @ss, $s;
            }

            for my $key ( @keys ) {

              next
                if ( $fsigma{$key} <= 0 );

              my $sigma = $fsigma{$key} * $sigma0;

              my $sum0 = 0;
              my $sum1 = 0;

              my @us = ();

              # find normalized distance to center point
              for my $ii ( 0 .. $#ss ) {
                push @us, ($ss[$ii] - $ss[$i - $j]) / $sigma;
              }

              next
                if ( (@us < 2) );

              # simple weighted average -- does not consider density of points
              # more sophisticated approach could use 2D convolution
              for my $ii ( 0 .. $#us ) {
                my $u = $us[$ii];
                my $p = $points->[($j + $ii) % @$points];
                my $z = $p->{$key};

                # weight by distance
                my $du = ($ii > 0) ? $u - $us[$ii - 1] : 0;
                $du += $us[$ii + 1] - $u if ($ii < $#us);

                my $w = exp(-($u ** 2) / 2) * $du;
                $sum1 += $w * $z;
                $sum0 += $w;
              }

              # this may be deletable if there's a legitimate reason for a zero sum
              die("zero sum found!!!\npoint = $i\nss = @ss\nus = @us\n")
                if ( $sum0 == 0 );

              $var{$key} = $sum1 / $sum0 if ($sum0 != 0);
            }
          }
          push @pNew, \%var;
        }
        $points = \@pNew;
      }
    }

    # anchoring: return start point and, if not a loop, finish point to original values
    # if anchoring requested
    if ( $anchorSF && (! $isLoop) ) {
      for my $d ( 1, -1 ) {
        my %sigma = (
                     ele => sqrt($lSmooth ** 2 + $zSmooth ** 2),
                     lat => $lSmooth,
                     lon => $lSmooth,
                    );

        # the point to anchor
        my $i0 = ($d == 1) ? 0 : -1;

        # if autosmoothing is used, then add that in
        $sigma{ele} = sqrt($sigma{ele} ** 2 + ($points->[$i0]->{sigma} * $zAutoSmooth) ** 2)
          if ($zAutoSmooth > 0);

        # this is from BEFORE smoothing since we've not updated the distance field: this is important
        my $courseDistance = $points->[-1]->{distance} - $points->[0]->{distance};

        for my $key ( keys %sigma ) {
          if ($sigma{$key} > 0) {
            my $dy0 = $points->[$i0]->{$key} - $endPoints[$i0]->{$key};

            # step thru points
            my $i = $i0 % @$points;

            my $dsMax = 6 * $sigma{$key};
            while ( ($i <= $#$points) && ($i >= 0) ) {

              # distance: using values calculated from the original course, not
              # distorted by smoothing, since smoothing can collapse points,
              # and point of anchoring is to reduce collapse
              my $s = abs(distanceDifference($points->[$i], $points->[$i0], $courseDistance, $isLoop));
              last if ($s > $dsMax );

              my $u = $s / $sigma{$key};
              my $w = exp(-$u ** 2 / 2) * (1 - $s / $courseDistance);
              $points->[$i]->{$key} -= $w * $dy0;

              $i += $d;
            }
          }
        }
      }
      deleteField(points=> $points, field=> "sigma") unless ($addSigma);
    }

    # spline again post-smoothing, if requested
    if ( ($splineRadians > 0) && (($lSmooth > 1) || ($zSmooth > 0)) ) {
      note("corner splines, post-smoothing...\n");
      my $points = addSplines(points=> $points, splineRadians=> $splineRadians, splineMaxRadians=> $splineMaxRadians, isLoop=> $isLoop);
    }

    #
    # flatten selected sections
    # points come in sets of 4: start point, altitude, finish point, altitude, lambda
    #
    if (@flatten) {
      note("flattening...\n");
      addDistanceField(points=> $points);
      for (my $nf = 0; $nf < @flatten; $nf += 5) {
        my $flattenStart = $flatten[$nf];
        my $zFlatten1    = $flatten[$nf + 1] if ($nf < $#flatten);
        my $flattenStop  = $flatten[$nf + 2] if ($nf + 1 < $#flatten);
        my $zFlatten2    = $flatten[$nf + 3] if ($nf + 2 < $#flatten);
        my $lambda       = $flatten[$nf + 4] if ($nf + 3 < $#flatten);
        $lambda //= 10 + sqrt($zSmooth ** 2 + $lSmooth ** 2);
        $flattenStop //= ($points->[-1]->{distance} + 1000 * $lambda + 1000);
        $zFlatten2   //= $zFlatten1;
        note("flattening course from $flattenStart ($zFlatten1 meters) to $flattenStop ($zFlatten2 meters)\n");
        for my $i ( 0 .. $#$points ) {
          my $s = $points->[$i]->{distance};
          my $z = $points->[$i]->{ele};
          if ($s >= $flattenStart) {
            my $zFlatten = ( $zFlatten1 * ($flattenStop - $s) + $zFlatten2 * ($s - $flattenStart) ) / ($flattenStop - $flattenStart);
            if ($flattenStop >= $s) {
              $points->[$i]->{ele} = $zFlatten;
              note("point $i: flattened to $points->[$i]->{ele}\n");
            } elsif ($s < $flattenStop + $lambda) {
              my $f = (1 + cos($pi * ($s - $flattenStop) / $lambda)) / 2;
              $points->[$i]->{ele} = $f * $zFlatten + (1 - $f) * $z;
            }
          } elsif ($s > $flattenStart - $lambda) {
            my $zFlatten = ( $zFlatten1 * ($flattenStop - $s) + $zFlatten2 * ($s - $flattenStart) ) / ($flattenStop - $flattenStart);
            my $f = (1 + cos($pi * ($flattenStart - $s) / $lambda)) / 2;
            $points->[$i]->{ele} = $f * $zFlatten + (1 - $f) * $z;
          }
        }
      }
    }

    #
    # flatten intersections
    # if roads cross and one or both of them are sloped, this creates ugly intersections
    # in RGT, where one of the directions tends to float in the air.  This flattens
    # roads proximate to intersections
    #
    if ( $fixCrossings ) {
      note("fixing crossings...\n");

      # calculate a crossingX: minimum crossing X-product
      my $crossingX = ((defined $crossingAngle) && ($crossingAngle >= 0)) ? abs(sin($crossingAngle * $deg2rad)) : sin($pi / 16);

      #
      # create a distance field
      #
      addDistanceField(points=> $points);

      #
      # create simplified version of profile
      # monitor the direction and when the direction changes enough, add a point
      #
      my @simplified = (0, 1);
      die("course lacks at least two points... quitting\n") unless (@$points > 1);
      my $simplifiedAngle = $pi / 24;
      for my $i ( 2 .. $#$points ) {
        my $angle = latlngAngle($points->[$i], $points->[$simplified[-1]], $points->[$simplified[-2]]);
        # add points which cause an angle change
        if (
            (defined $angle) &&
            (abs($angle) > $simplifiedAngle) &&
            (($isLoop || ($i < $#$points)))
           ) {
          my $a1 = latlngAngle($points->[($i + 1) % @$points], $points->[$i], $points->[$simplified[-1]]);
          my $a2 = latlngAngle($points->[($i + 1) % @$points], $points->[$i], $points->[$i - 1]);
          if (
              ((defined $a1) && (abs($a1) > $simplifiedAngle)) ||
              ((defined $a2) && (abs($a2) > $simplifiedAngle))
             ) {
            push @simplified, $i;
          }
        }
      }
      if ( $isLoop ) {
        push @simplified, 0
          unless (pointsAreClose($points->[0], $points->[$simplified[-1]]));
      } else {
        push @simplified, $#$points unless ( ($simplified[-1] == $#$points) || pointsAreClose($points->[-1], $points->[$simplified[-1]]) );
      }

      # search for crossings on simplified route
      my @crossings;

      for my $j ( 1 .. $#simplified - 1 ) {
        for my $i ( 0 .. $j - 1 ) {
          if ((my @fs = segmentIntercept( [$points->[$simplified[$i]], $points->[$simplified[$i + 1]]], [$points->[$simplified[$j]], $points->[$simplified[$j + 1]]] )) == 2) {
            # note("intercept found between simplified segments $i and $j: @fs\n");

            # there is a crossing between simplified segments i and j
            # but the actual intersection might be from adjacent segments... so check those if the intersection was close to the edge
            my $u1 =  (($fs[0] < 0.5) && ($i > 0)) ? $simplified[$i - 1] : $simplified[$i];
            my $u2 =  ((($fs[0] > 0.5) && ($i < $#simplified - 1)) ? $simplified[$i + 2] : $simplified[$i + 1]) - 1;
            my $v1 =  (($fs[1] < 0.5) && ($j > 0)) ? $simplified[$j - 1] : $simplified[$j];
            my $v2 =  ((($fs[1] > 0.5) && ($j < $#simplified - 1)) ? $simplified[$j + 2] : $simplified[$j + 1]) - 1;

            # find the specific segments and positions where the crossings occur
            my $crossingsFound = 0;
            for my $u ( $u1 .. $u2 ) {
              for my $v ( $v1 .. $v2 ) {
                if ( (my @gs =
                      segmentIntercept(
                                       [$points->[$u], $points->[($u + 1) % @$points]],
                                       [$points->[$v], $points->[($v + 1) % @$points]]
                                      )
                     ) == 2
                   ) {
                  my $up1 = ($u + 1) % @$points;
                  my $vp1 = ($v + 1) % @$points;
                  my @cNew;
                  push @cNew, interpolatePoint($points->[$u], $points->[$up1], $gs[0]);
                  my $z1 = $cNew[-1]->{ele};
                  push @cNew, interpolatePoint($points->[$v], $points->[$vp1], $gs[1]);
                  my $z2 = $cNew[-1]->{ele};
                  my $zAvg = ($z1 + $z2) / 2;

                  # adjust the altitude of the crossing points
                  if (abs(latlngCrossProduct($points->[$u], $points->[$up1], $points->[$v], $points->[$vp1])) > $crossingX) {
                    if (abs($z1 - $z2) < $crossingHeight / 2) {
                      note("crossing @ $cNew[-2]->{distance} m and $cNew[-1]->{distance} m: setting level crossing altitude to $zAvg\n");
                      $cNew[-2]->{ele} = $zAvg;
                      $cNew[-1]->{ele} = $zAvg;
                    } elsif (abs($z1 - $z2) < $crossingHeight) {
                      $cNew[-2]->{ele} = $zAvg + ($z1 <=> $zAvg) * $crossingHeight / 2;
                      $cNew[-1]->{ele} = $zAvg + ($z2 <=> $zAvg) * $crossingHeight / 2;
                      note("crossing @ $cNew[-2]->{distance} m and $cNew[-1]->{distance} m: setting overpass altitudes to $cNew[-2]->{ele} and $cNew[-1]->{ele}\n");
                    }
                    push @crossings, @cNew;
                    $crossingsFound ++;
                  }
                }
              }
            }
          }
        }
      }
      note("total crossings = ", scalar(@crossings), "\n");

      {
        my $fName = setFileNameSuffix($file, "_crossings.csv");
        open my $fcrossings, ">$fName";
        print $fcrossings  "lon,lat,ele,distance\n";
        for my $p ( @crossings ) {
          print $fcrossings "$p->{lon},$p->{lat},$p->{ele},$p->{distance}\n";
        }
        close $fcrossings;
      }

      # crossing parameters
      my $r1 = $rCrossings;
      my $r2 = $crossingTransition // 3 * $rCrossings;
      my $dr = $r2 - $r1;
      my $r3 = ($r1 + $r2) / 2;
      my $r4 = (3 * $r1 + $r2) / 4;

      # sort crossings
      # create interpolated point list
      my @si;
      for my $c ( @crossings ) {
        my $s = $c->{distance};
        push @si, ($s - $r2, $s - $r3, $s - $r4, $s - $r1, $s, $s + $r1, $s + $r4, $s + $r3, $s + $r2);
      }

      @si = sort { $a <=> $b } @si;

      if (@si) {
        my @siNew = ( $si[0] );
        for my $j ( 1 .. $#si ) {
          push @siNew, $si[$j] if (abs($si[$j] - $siNew[-1]) > 0.5);
        }

        @si = @siNew;
      }

      # report simplified route
      {
        my $fName = setFileNameSuffix($file, "_simplifiedCourse.csv");
        open my $fsimplified, ">$fName";
        print $fsimplified  "lon,lat\n";
        for my $i ( 0 .. $#simplified ) {
          print $fsimplified "$points->[$simplified[$i]]->{lon},$points->[$simplified[$i]]->{lat}\n";
        }
        close $fsimplified;
      }

      # interpolate points
      # si: position of point to be interpolated
      # i : index to the existing points
      # s1: distance to point i
      # s2: distance to point 1 + 1
      # j : index into interpolated point array
      if ( @si) {
        note("adding additional points at crossings...\n");
        my @newPoints = $points->[0];
        my $j = 0;
        for my $i ( 0 .. $#$points - 1) {
          my $s1 = $points->[$i]->{distance};
          my $s2 = $points->[$i + 1]->{distance};
          $j ++ while ( ($j <= $#si) && ($si[$j] <= $s1) );
          while (($j < @si) && ($s2 > $si[$j])) {
            if ( (abs($si[$j] - $s1) > 0.5) && (abs($si[$j] - $s2) > 0.5) ) {
              my $f = ($si[$j] - $s1) / ($s2 - $s1);
              push @newPoints, interpolatePoint($points->[$i], $points->[$i + 1], $f);
            }
            $j ++;
          }
          push @newPoints, $points->[$i + 1]
        }
        $points = \@newPoints;
      }

      #
      # smooth altitude at crossings
      #
      # width of road is 4 meters
      # flatten road for at least this distance

      my $k = $pi / $dr;

      for my $p ( @$points ) {
        my $sp = $p->{distance};
        for my $c ( @crossings ) {
          my $sc = $c->{distance};
          my $ds = abs($sp - $sc);
          if ($ds < $r2) {
            if ($ds < $r1) {
              $p->{ele} = $c->{ele};
            } else {
              my $f = (1 + cos($k * ($ds - $r1))) / 2;
              $p->{ele} = $f * $c->{ele} + (1 - $f) * $p->{ele};
            }
          }
        }
      }
    }

    #
    # create named segments

    note("number of named segments = ", scalar(@namedSegments), "\n");
    addDistanceField(points=> $points)
      if ( @namedSegments );

    for my $s ( @namedSegments ) {
      chomp($s);

      my ($start, $end, $name) = split(",", $s);
      for my $a ($start, $end, $name) {
	$a =~ s/^\s*(.*?)\s*$/$1/;
      }
      note("processing named segment $name from $start to $end ...\n");
      if ((! defined $start) || ($start eq "") || ($start eq "start")) {
	$start = 0;
      }
      if ((! defined $end) || ($end eq "") || ($end eq "end")) {
	$end = $points->[-1]->{distance};
      }
      note("defining segment \"$name\" from $start to $end ...\n");
      my ($pStart, $pEnd);
      ($points, $pStart) = pointAtPosition($start, $points, $isLoop);
      ($points, $pEnd)   = pointAtPosition($end, $points, $isLoop);
      # find a segment number
      my $nS = 1;
      $nS ++ while ($segmentDefined{$nS});
      my @pNew = ();
      for my $i ( 0 .. $pStart ) {
	push @pNew, $points->[$i];
      }
      for my $i ( $pStart .. $pEnd ) {
	my %p = %{$points->[$i]};
	$p{segment} = $nS;
	push @pNew, \%p;
      }
      for my $i ( $pEnd .. $#$points ) {
	push @pNew, $points->[$i];
      }
      $points = \@pNew;
      $segmentName{$nS} = $name;
      $segmentDefined{$nS} ++;
    }

    #
    # cropping: shorten distance of original GPX
    # note distance is calculated here... can change from lane shifts
    #

    # if crops may have been specified with negative append or prepend...
    if ((! $isLoop) && (((! (defined $cropMax)) || ($cropMax <= 0)) && ($append < 0))) {
      $cropMax = calcCourseDistance(points=> $points, isLoop=> $isLoop) + $append;
    }
    if ((! defined $cropMin) || ($cropMin <= 0) && ($prepend < 0)) {
      $cropMin = -$prepend;
    }

    if ( ((defined $cropMin) && ($cropMin > 0)) || ((defined $cropMax) && ($cropMax > 0)) ) {
      $points = cropPoints(points=> $points, min=> $cropMin, max=> $cropMax);
      note("points remaining after cropping = ", scalar(@$points), "\n");
    }

    #
    # pruning: remove colinear points
    # out-and-back route generation requires identical paths, so follows this
    #

    if ( $prune ) {
      # prune in each direction
      for my $n ( 0, 1 ) {
        my $pruneCount = 0;
        my @pNew = ( $points->[0] );
        for my $i ( 1 .. $#$points - 1 ) {
          my $p1 = $pNew[-1];
          my $p2 = $points->[$i + 1];
          my $p3 = $points->[$i];
          if ( isPointPrunable( points=> [$p1, $p2, $p3], distance=> $pruneD, X=> $pruneX, dg=> $prunedg)  ) {
            $pruneCount ++;
          } else {
            push @pNew, $p3;
          }
        }
        push @pNew, $points->[-1];
        @pNew = reverse @pNew;
        $points = \@pNew;
        note("prune loop $n: pruned $pruneCount points.\n");
      }
    }


    #
    # calculate a lane shift field, if we're doing lane shifts
    # shiftStart < shiftEnd: shifting between shiftStart and shiftEnd
    # shiftStart > shiftEnd: shifting up to shiftEnd, then after shiftStart
    #
    if ( $laneShift != 0) {
      note("lane shift...\n");
      my $shiftDistance = 20 * abs($laneShift) ** (2/3);
      my $s = 0;
      for my $i ( 0 .. $#$points ) {
        $s += latlngDistance($points->[$i - 1], $points->[$i])
          if ( $i > 0 );
        my $shift = $laneShift;
        if ( (defined $shiftStart) && (defined $shiftEnd) && ($shiftEnd < $shiftStart) ) {
          $shift *= (transition(($shiftStart - $s) / $shiftDistance) + transition(($s - $shiftEnd) / $shiftDistance));
        } else {
          $shift *= transition(($shiftStart - $s) / $shiftDistance) if (defined $shiftStart);
          $shift *= transition(($s - $shiftEnd) / $shiftDistance)   if (defined $shiftEnd);
        }
        $points->[$i]->{shift} = $shift;
      }
    }

    #
    # if an out-and-back is to be generated, then generate the return points
    # (these will be added to the main points list later)
    # however, make copies of each invidual hash, don't just copy hash pointers,
    # or data will get clobbered
    #
    my $rPoints = [];
    if ( (defined $rTurnaround) && ($rTurnaround > 0) ) {
      note("out-and-back...\n");
      for my $p (reverse @$points) {
        my %h = %$p;
        push @$rPoints, \%h;
      }
    }

    #
    # lane shift:
    # shift lanes to the right (positive) or left (negative)
    #
    if ( $laneShift != 0 ) {
      $points  = applyLaneShift(points=> $points, isLoop=> $isLoop);
      deleteField(points=> $points, field=> "shift");
      $rPoints = applyLaneShift(points=> $rPoints, isLoop=> $isLoop);
      deleteField(points=> $rPoints, field=> "shift");
    }

    # for extendback, we calculate the crop crop position here: the loop counts as part
    # of the extension distance
    my $cropBack = 0;
    if ($extendBack > 0) {
      $cropBack = calcCourseDistance(points=> $points) + $extendBack;
      note("calculating cropping position for extendBack = $cropBack\n");
    }

    #
    # generate turn-around loops, if requested
    # last two points of outward leg, first two points of return leg, determine direction
    #
  pathLoop: for my $nPath ( 0, 1 ) {
      my $R = ($nPath == 0) ? $rTurnaround : $rLap;
      next pathLoop unless ((defined $R) && ($R > 0));

      my $ps1 = ($nPath == 0) ? $points : $rPoints;
      my $ps2 = ($nPath == 0) ? $rPoints : $points;
      next pathLoop unless ((@$ps1 > 1) && (@$ps2 > 1));

      # find average direction of the two legs
      my ($dx1, $dy1) = latlng2dxdy($ps1->[-2], $ps1->[-1]);
      my $dir1 = atan2($dy1, $dx1);
      my ($dx2, $dy2) = latlng2dxdy($ps2->[1], $ps2->[0]);
      my $dir2 = atan2($dy2, $dx2);
      my $dir = averageAngles($dir1, $dir2);

      # create the loop
      note("creating turn-around loop...\n");
      my $loop = makeLoop(points=> [$ps1->[-1], $ps2->[0]], direction=> $dir, radius=> $R, defaultSign=> (($laneShift < 0) ? -1 : 1), segmentNames=> \%segmentName);
      push @$ps1, @$loop;
    }

    # eliminate temporary fields (for now)
    for my $k ( "distance", "shift" ) {
      for my $ps ( $points, $rPoints ) {
        deleteField(points=> $ps, field=> $k);
      }
    }

    #
    # store points in the hash
    #
    if (@$rPoints) {
      note("points on outbound = ", scalar(@$points), "\n");
      note("points on inbound = ", scalar(@$rPoints), "\n");
      push @$points, @$rPoints;
    }

    # for -extendBack, crop it here:
    $points = cropPoints(points=> $points, max=> $cropBack)
      if ($cropBack > 0);

    #
    # turn-around loops within the course, if requested
    #
    if ( (defined $rUTurn) && (abs($rUTurn) > 1) ) {
      note("checking for U-turn loops...\n");

      # get rid of duplicate point at end
      my $pointPopped = pointsAreClose($points->[0], $points->[-1]);
      pop @$points if ($pointPopped);

      # two sweeps: one for 3-point turns, the next for 4-point turns.
      for my $turnType (3, 4) {
        my @pNew = ();
        my $i = 0;
        push @pNew, $points->[$i++]
          if (! $isLoop);
        while ($i <= $#$points) {
          push @pNew, $points->[$i];

	  if (pointsAreClose($points->[$i], $points->[($i + 1) % @$points])) {
	    $i ++;
	    next;
	  }

	  # select points: check for duplicate points
          my $h = ($i - 1) % @$points;
	  $h = ($h - 1) % @$points if (($h != $i) && pointsAreClose($points->[$h], $points->[$i]));
          my $j = ($i + 1) % @$points;
          my $k = ($j + 1) % @$points;
	  if (($j != $i) && pointsAreClose($points->[$j], $points->[$i])) {
	    $j = ($j + 1) % @$points;
	    $k = ($k + 1) % @$points;
	  }
	  $k = ($k + 1) % @$points if (($k != $i) && pointsAreClose($points->[$j], $points->[$k]));

          if (
              ($turnType == 3) &&
              ($isLoop || ($i < $#$points)) &&
              UTurnCheck($points->[$h], $points->[$i], $points->[$i], $points->[$j])
             ) {
            my $d1 = latlngDirection($points->[$h], $points->[$i]);
            my $d2 = latlngDirection($points->[$j], $points->[$i]);
            note("3-point U-turn detected @\n",
                 "   1: point ", $h + 1, " of ", scalar(@$points), " ($points->[$h]->{lon}, $points->[$h]->{lat})\n",
                 "   2: point ", $i + 1, " of ", scalar(@$points), " ($points->[$i]->{lon}, $points->[$i]->{lat})\n",
                 "   3: point ", $j + 1, " of ", scalar(@$points), " ($points->[$j]->{lon}, $points->[$j]->{lat})\n",
                 "   directions = ", $d1 / $deg2rad, ", ", $d2 / $deg2rad, "\n");
            my $dir = averageAngles($d1, $d2);
            my $loop = makeLoop(points=> [$points->[$i], $points->[$i]], direction=> $dir, radius=> $rUTurn, defaultSign=> (($laneShift < 0) ? -1 : 1), segmentNames=> \%segmentName);
            push @pNew, @$loop;
            push @pNew, \%{$points->[$i]}; # put a copy of the turn-around point here
          } elsif (
                   ($turnType == 4) &&
                   ($isLoop || (($i > 0) && ($i < $#$points - 1))) &&
                   UTurnCheck($points->[$h], $points->[$i], $points->[$j], $points->[$k]) &&
                   (latlngDistance($points->[$i], $points->[$j]) < 20)
                   # (latlngDotProduct($points->[$h], $points->[$i], $points->[$i], $points->[$j]) < 0.9) &&
                   # (latlngDotProduct($points->[$i], $points->[$j], $points->[$j], $points->[$k]) < 0.9) &&
                  ) {
            my $d1 = latlngDirection($points->[$h], $points->[$i]);
            my $d2 = latlngDirection($points->[$k], $points->[$j]);
            note("4-point U-turn detected @\n",
                 "   1: point ", $h + 1, " of ", scalar(@$points), " ($points->[$h]->{lon}, $points->[$h]->{lat})\n",
                 "   2: point ", $i + 1, " of ", scalar(@$points), " ($points->[$i]->{lon}, $points->[$i]->{lat})\n",
                 "   3: point ", $j + 1, " of ", scalar(@$points), " ($points->[$j]->{lon}, $points->[$j]->{lat})\n",
                 "   4: point ", $k + 1, " of ", scalar(@$points), " ($points->[$k]->{lon}, $points->[$k]->{lat})\n",
		 "   directions = ", $d1 / $deg2rad, ", ", $d2 / $deg2rad, "\n");
            my $dir = averageAngles($d1, $d2);
            my $loop = makeLoop(points=> [$points->[$i], $points->[$j]], direction=> $dir, radius=> $rUTurn, defaultSign=> (($laneShift < 0) ? -1 : 1), segmentNames=> \%segmentName);
            push @pNew, @$loop;
          }
          $i ++;
        }
        push @pNew, $points->[$i++] while ($i < $#$points);
        $points = \@pNew;
      }

      push @$points, \%{$points->[0]} if ($pointPopped);
    }


    #
    # set maximum curvature
    # note this needs to happen AFTER turn-around loops
    #
    if ( $minRadius > 0 ) {
      note("setting minimum radius to $minRadius...\n");
      addCurvatureField(points=> $points, isLoop=> $isLoop);
      addDistanceField(points=> $points, isLoop=> $isLoop);
      my $courseDistance = calcCourseDistance(points=> $points, isLoop=> $isLoop);

      # calculate a lane shift field
      my $maxCurvature = 1 / $minRadius;
      my $count = 0;
      my @posShifts = map { 0 } @$points;
      my @negShifts = map { 0 } @$points;
      my $lambda = 16 * sqrt($minRadius);

      for my $u ( 0 .. $#$points ) {
        my $p = $points->[$u];
        if (
            (
             ( (! defined $minRadiusStart) || ($p->{distance} >= $minRadiusStart) ) +
             ( (! defined $minRadiusEnd) || ($p->{distance} <= $minRadiusEnd) ) +
             ((defined $minRadiusEnd) && (defined $minRadiusStart) && ($minRadiusEnd < $minRadiusStart))
             == 2
            ) &&
            ( abs($p->{curvature}) > $maxCurvature )
           ) {
          my $s = $minRadius - abs(1 / $p->{curvature});
          my $a = ( $p->{curvature} > 0 ) ? \@posShifts : \@negShifts;
          $a->[$u] = $s if ($a->[$u] < $s);
          $count ++;
        }
      }

      if ($count > 0) {
        note("found $count points tighter than minimum radius $minRadius meters...\n");
        for $a ( \@posShifts, \@negShifts ) {
          my $u1 = 0;
          my $u2 = 0;

          if ( $isLoop ) {
            $u1 --
              while (
                     ($u1 > -$#$points) &&
                     (distanceDifference($points->[$u1 - 1], $points->[0], $courseDistance, $isLoop) < $lambda)
                    );
          }

          my @newShifts = @$a;
          for my $u0 ( 0 .. $#$points ) {
            next if ($a->[$u0] == 0);

            # u1 ... u0 ... u2
            $u1 ++
              while (
                     ($u1 < $u0) &&
                     (distanceDifference($points->[$u1], $points->[$u0], $courseDistance, $isLoop) > $lambda)
                    );
            $u2 = $u0 if ($u2 < $u0);
            $u2 = ($u2 + 1) % @$points
              while (
                     ($isLoop ? ((($u2 + 1) % @$points) != $u1) : $u2 < $#$points) &&
                     (distanceDifference($points->[$u0], $points->[($u2 + 1) % @$points], $courseDistance, $isLoop) < $lambda)
                    );
            for my $u ( $u1 .. $u2 ) {
              # the u0 point has already been set...
              next
                if ($u == $u0);
              my $f = ( (1 + cos($pi * pointSeparation($points->[$u], $points->[$u0], $courseDistance, $isLoop) / $lambda)) / 2 ) ** 2;
              my $shift = $a->[$u0] * $f;

              # if there's an existing shift, then combine with that:
              # $newShifts[$u] = ($shift ** 4 + $newShifts[$u] ** 4) ** (1/4);
              $newShifts[$u] = $shift if ($shift > $newShifts[$u]);
            }
          }
          @$a = @newShifts;
        }

        # fill in shifts... sum of positive and negative shifts.
        for my $u ( 0 .. $#$points ) {
          $points->[$u]->{shift} += $posShifts[$u] - $negShifts[$u];
        }
        $points = applyLaneShift(points=> $points, isLoop=> $isLoop);
        deleteField(points=> $points, field=> "shift");
      }
    }

    #
    # shift starting line
    # this is useful on crit courses because RGT puts the start line 60 meters after the start of the data,
    # so a value of -60 is useful
    #
    if ( $isLoop && ($shiftSF != 0) && (@$points > 1) ) {
      my $direction = ($shiftSF <=> 0);

      # trim off the last point if it equals the first point
      pop @$points
        if ( pointsAreClose($points->[-1], $points->[0]) );

      my $s = 0;
      while (1) {
        my $sPrev = $s;
        $s += latlngDistance($points->[0], $points->[$direction]);
        if ( $direction > 0 ) {
          push @$points, shift @$points;
        }
        if ( $s > abs($shiftSF) ) {
          my $f = (abs($shiftSF) - $sPrev) / ($s - $sPrev);
          # add in this point to the start... may need to remove the existing start point if it's too close
          # direction = 1 : interpolation between point -1 => point 0
          # direction = -1 : interpolation between point 1 => point 0

          my $pNew = interpolatePoint($points->[-1], $points->[0], ($direction > 0) ? $f : (1 - $f));
          shift @$points
            if (pointsAreClose($points->[0], $pNew));
          pop @$points
            if (pointsAreClose($points->[-1], $pNew));
          unshift @$points, $pNew;
          last;
        }
        if ( $direction < 0 ) {
          unshift @$points, pop @$points;
        }
      }
    }

    #
    # add points to beginning or end
    # this provides space for the S or F in a point-to-point
    # RGT can automatically close courses with undesired results if
    # points are too close
    #
    if ( (! $isLoop) && ($prepend > 0) && (($rTurnaround <= 0) || ($rLap <= 0)) ) {
      my $p1 = $points->[0];
      my $i = 1;
      my $d;
      $i ++
        while ((($d = latlngDistance($p1, $points->[$i])) < 10) && ($i < $#{$points}));
      my $p2 = $points->[$i];

      # figure out if we want to curve the road to split this from the return road
      if ( ($prepend == $append) && ($rTurnaround > 0) ) {
        my $p3 = interpolatePoint($p1, $p2, -0.5 * $prepend / $d);
        $p3->{ele} = $p1->{ele};
	$p3->{segment} = (defined $segmentName{$p1->{segment}}) ? 0 : $p1->{segment};

        # turn appropriate direction
        my $sign = ($laneShift < 0) ? -1 : 1;
        note("adding turn to prepend: ", (($sign > 0) ? "right" : "left"), "\n");

        my ($dx, $dy) = latlng2dxdy($p1, $p3);
        my $c = cos($deg2rad * $p3->{lat});

        # right turn: x -> y, y -> -x
        # left turn: x -> -y, y-> x

        my $dx2 = -$sign * $dy;
        my $dy2 = $sign * $dx;

        # switch back to lon, lat
        my $p4;
        %$p4 = %$p3;
        $p4->{lon} = $p3->{lon} + $dx2 / ($c * $lat2y);
        $p4->{lat} = $p3->{lat} + $dy2 / $lat2y;
	$p4->{segment} = $p3->{segment};

        unshift @{$points}, $p4, $p3;
      } else {
        my $p3 = interpolatePoint($p1, $p2, -$prepend / $d);
        $p3->{ele} = $p1->{ele};
        unshift @{$points}, $p3;
      }
    }
    if ( (! $isLoop) && ($append > 0) && (($rTurnaround <= 0) || ($rLap <= 0)) ) {
      my $p1 = $points->[-1];
      my $i = $#$points - 1;;
      my $d;
      $i --
        while ((($d = latlngDistance($p1, $points->[$i])) < 10) && ($i > 0));
      my $p2 = $points->[$i];

      # figure out if we want to curve the road to split this from the return road
      if ( ($prepend == $append) && ($rTurnaround > 0) ) {
        my $p3 = interpolatePoint($p1, $p2, -0.5 * $prepend / $d);
        $p3->{ele} = $p1->{ele};
	$p3->{segment} = (defined $segmentName{$p1->{segment}}) ? 0 : $p1->{segment};

        # turn appropriate direction
        my $sign = ($laneShift < 0) ? -1 : 1;
        note("adding turn to append: ", (($sign > 0) ? "right" : "left"), "\n");

        my ($dx, $dy) = latlng2dxdy($p1, $p3);
        my $c = cos($deg2rad * $p3->{lat});

        # left turn: x -> y, y -> -x
        # right turn: x -> -y, y-> x

        my $dx2 = $sign * $dy;
        my $dy2 = -$sign * $dx;

        # switch back to lon, lat
        my $p4;
        %$p4 = %$p3;
        $p4->{lon} = $p3->{lon} + $dx2 / ($c * $lat2y);
        $p4->{lat} = $p3->{lat} + $dy2 / $lat2y;
	$p4->{segment} = $p3->{segment};
	if ( $p3->{segment} != $points->[-1]->{segment} ) {
	  my %p = %{$points->[-1]};
	  $p{segment} = $p3->{segment};
	  push @$points, \%p;
	}
        push @$points, $p3, $p4;
      } else {
        my $p3 = interpolatePoint($p1, $p2, -$append / $d);
        $p3->{ele} = $p1->{ele};
	$p3->{segment} = (defined $segmentName{$p1->{segment}}) ? 0 : $p1->{segment};
	if ( $p3->{segment} != $points->[-1]->{segment} ) {
	  my %p = %{$points->[-1]};
	  $p{segment} = $p3->{segment};
	  push @$points, \%p;
	}
        push @$points, $p3;
      }
    }

    #
    # automatic segment definition using climb detection
    #
    my ($autoSegmentThreshold, $autoSegmentPower) = @autoSegments;
    if ((defined $autoSegmentThreshold) && ($autoSegmentThreshold > 0)) {
      # default segment power: a 100 meter climb @ 10% = a 140 meter climb @ 5%
      # so if I have 1 km @ 10%, then 1.8 km @ 2.2%, it's ambiguous whether to include
      # the second part in the segment
      $autoSegmentPower //= $autoSegmentDefaultPower // 0.5;

      # automatic segment generation
      $points =
	addAutoSegments(
			gradientPower=> $autoSegmentPower,
			isLoop=> $isLoop,
			margin=> $autoSegmentMargin,
			names=> \@autoSegmentNames,
			points=> $points,
			segmentDefined=> \%segmentDefined,
			segmentNames => \%segmentName,
			stretch=> $autoSegmentStretch,
			threshold=> $autoSegmentThreshold,
		       );
    }


    # copy the first point to the last point if specified
    if ( $copyPoint && (($points->[0]->{lat} != $points->[-1]->{lat}) || ($points->[0]->{lon} != $points->[-1]->{lon}) || ($points->[0]->{ele} != $points->[-1]->{ele})) ) {
      my %p = %{$points->[0]};
      push @$points, \%p;
      $p{segment} = $points->[-1]->{segment};
      $points->[-1]->{distance} = $points->[-2]->{distance} + latlngDistance($points->[-2], $points->[-1]) if (defined $points->[-2]->{distance});
    }

    #
    # create a distance field
    #
    addDistanceField(points=> $points);

    if ((defined $startTime) && ($startTime ne "")) {
      note("adding time...\n");
      my $tStart = str2time($startTime);
      if ($tStart > 0) {
        note("start time found: $tStart\n");
        my @ts = (0);
        my @gs = (0);
        for my $i ( 0 .. $#$points - 1 ) {
	  my $dd = $points->[$i + 1]->{distance} - $points->[$i]->{distance};
          push @gs, ($dd == 0) ? $gs[-1] : (($points->[$i + 1]->{ele} - $points->[$i]->{ele}) / $dd);
          push @ts, $ts[-1] + ($points->[$i + 1]->{distance} - $points->[$i]->{distance}) / bikeSpeedModel(g=> $gs[-1]);
        }
        for my $i ( 0 .. $#$points ) {
          $points->[$i]->{time} = $tStart + $ts[$i];
          $points->[$i]->{duration} = $ts[$i];
        }
      }
    }

    note("final number of points = ", scalar(@$points), "\n");
    note("altitude quality score of final course = ", sprintf("%.4f", calcQualityScore(points=> $points, isLoop=> $isLoop)), "\n");
    note("distance from last point to first point = ", sprintf("%.3f", latlngDistance($points->[-1], $points->[0])), " meters\n");


    #
    # curvature
    #
    if ($addCurvature) {
      note("checking curvature\n");
      addCurvatureField(points=> $points, isLoop=> $isLoop);
    } else {
      deleteField(points=> $points, field=> "curvature");
    }

    #
    # generate gradient signs
    #
    if ( $addGradientSigns ) {
      # calculate course distance
      $waypoints //= [];
      push @$waypoints,
	@{placeGradientSigns(
			     points => $points,
			     shiftCircuit=> $isLoop,
			     courseDistance=> $courseDistance,
			     gradientPower=> $gradientPower,
			     threshold=> $gradientThreshold,
			     isLoop=> $isLoop
			    )
	};
    }


    #
    # finish up
    #
    if ($addGradient) {
      note("adding gradient field\n");
      addGradientField(points=> $points, isLoop=> $isLoop);
    } else {
      deleteField(points=> $points, field=> "gradient")
    }

    deleteField(points=> $points, field=> "distance")
      unless ( $addDistance );

    if ($addDirection) {
      addDirectionField(points=> $points, isLoop=> $isLoop);
      for my $p ( @$points ) {
        $p->{direction} /= $deg2rad;
      }
    } else {
      deleteField(points=> $points, field=> "direction");
    }

    $gpx->waypoints($waypoints) if (defined $waypoints);

    # create segments for track
    # when a segment ID changes, that means to start a new segment

    # list of segments: segments must have at least one point
    my @segments = ();

    # reset the segment names field for this track
    $extensions->{segmentName}->{$nTrack} = {};

    my @segmentPoints;
    my $sPrev = 'nan';
    for my $p ( @$points ) {
      my $s = $p->{segment};

      # new segment
      if (! ($s == $sPrev)) {
	if ( @segmentPoints ) {

	  # copy the first point of the next segment on this segment
	  # if there is a gap
	  my $pPrev = $segmentPoints[-1];
	  unless (pointsAreClose($p, $pPrev)) {
	    my %p = %{$p};
	    $p{segment} = $sPrev;
	    push @segmentPoints, \%p;
	  }

	  # add the segment to the list of segments
	  my %segment;
	  $segment{points} = [ @segmentPoints ];
	  push @segments, \%segment;

	  # add segment name if defined
	  my $nSegment = scalar @segments;
	  my $segmentID = $segment{points}->[0]->{segment};
	  $extensions->{segmentName}->{$nTrack}->{$nSegment} = $segmentName{$segmentID}
	    if (defined $segmentName{$segmentID});

	  # zero out the current segment
	  @segmentPoints = ();
	}
	$sPrev = $s;
      }
      # add the current point to the current segment
      push @segmentPoints, $p;
    }

    # store the final segment
    # this just references the segment array rather than copying the data
    if ( @segmentPoints ) {
      my %segment;
      $segment{points} = \@segmentPoints;
      push @segments, \%segment;
    }

    # number of segments
    note("number of segments = ", scalar(@segments), "\n");
    my $n = 0;
    for my $s ( @segments ) {
      deleteField(points=> $s->{points}, field=> "segment");  # delete the temporary segment field
      $n ++;
      note("segment $n : ", scalar(@{$s->{points}}), " points\n");
    }

    # replace original segments with smoothed segments
    $track->{segments} = \@segments;
  }

  unless ( $noSave ) {
    my $nTrack = 0;
    for my $track ( @$tracks ) {
      $nTrack ++;
      if ($csv) {
        my $fNew = ($outFile eq "") ? setFileNameSuffix($file, "_processed.csv") : $outFile;
        my $fcsv;
        open $fcsv, ">$fNew" or die( "ERROR opening file $fcsv\n" );
        my @keys;
        my $nSegment = 0;
        for my $segment ( @{$track->{segments}} ) {
          $nSegment ++;
          my $points = $segment->{points};
          unless (@keys) {
            @keys = keys %{$points->[0]};
            print $fcsv join( ",", "track", "segment", @keys ), "\n";;
          }
          for my $p ( @$points ) {
            print $fcsv join( ",", $nTrack, $nSegment, @$p{@keys} ), "\n";
          }
        }
        close $fcsv;
      } else {
        my $k = "processGPX";
        my @newKeywords = split('\s*,\s*', $newKeywords);
        push @newKeywords, $k;
        my $keywords = $gpx->keywords();
        $keywords = [] unless (defined $keywords);
        for my $k ( @newKeywords ) {
          push @$keywords, $k
            unless ( grep { $_ eq $k} @$keywords );
        }
        $gpx->keywords( $keywords );

        $gpx->author($author) if (defined $author);
        $gpx->name($title) if (defined $title);
        $gpx->copyright($copyright) if (defined $copyright);
        $gpx->desc($description) if (defined $description);
        $gpx->time(time());

        my $fNew = ($outFile eq "") ? setFileNameSuffix($file, "_processed.gpx") : $outFile;
        note("saving processed data in file $fNew...\n");
        open my $fout, ">$fNew";

	my $xml = $gpx->xml("1.1");

	my $xmlNew = addExtensions(\$xml, $extensions);

	print $fout $$xmlNew;
	print $fout "\n";
        close $fout;
      }
    }
  }
  note("done with file $file.\n");
}

__END__
=pod

=head1 NAME

processGPX

=head1 SYNOPSIS

smoothGPX [options] <input files>

=head1 VERSION

0.39

=head1 DESCRIPTION

smoothGPX is a series of algorithms to improve and create GPX files,
in particular for cycling emulation platforms like RGT Cycling.

At the time of this writing, RGT Cycling has a "Magic Roads"
functionality whereby a GPX file can be submitted for conversion into
a virtual envirment.  The GPX file can be initially generate by
on-line mapping tools, among which one excellent option is Strava
Route Editor, which exports GPX.  However, these tools tend to produce
GPX files with too low resolution in position, and small errors in
altitude, so that corners are not sufficiently round, and the gradient
between points can have anomalously large magnitude.  Additionally,
RGT requires the route to be specified continuously from start to
finish, rather than allowing arbitrary navigation over a network of
roads, and so sometimes the same section of road needs to be repeated,
either in the same or in the opposite direction.  Also, RGT at present
allows cyclists to use the full width of the roadway, even if there is
an out-and-back section where there may be oncoming riders.  So it is
useful to allow the generation of out-and-back courses where the
return route is shifted to the right or too the left, to avoid the
possibility of virtual collisions.

These are just some examples of the sort of processing which can be
done to improve the quality and functionality of Magic Roads in RGT,
and presumibly other cycling emulators as well.  There exist online
tools such as GPX Magic, which is excellent, but requires extensive
user interaction, and a command-line tool able to process an entire
file at once has benefit.

The file takes GPX files on the command line, and generates a file
with a suffix "_processed" for each, unless the "-out" option is used,
in which case that is used as the output (this works for only one
input file).  So for example, if I type:

C<processGPX myFavoriteRoute.gpx>

the result will be a file:

F<myFavoriteRoute_processed.gpx>

This file will be essentially equivalent to the input file, in the
absence of any comment line options, although if there are any
"zig-zags" identified, those will be removed.  The file will also be
checked for "loops", where the direction spins around within 100 meters,
which might be from a poorly placed control point with mapping software.

If an alternate filename were desired for the output, that could be
specified with the "-out" option:

C<processGPX myFavoriteRoute.gpx -out MyFavoriteRouteCopy.gpx>

where the order of command line options does not matter, except that
the same option listed more than once will result in parameters specified
last being used.

The program will calculate a "altitude quality score" of both the
original GPX file, and of the result of processing, which is based on
how much the grade changes point-to-point -- it is basically the ratio
of the root-mean-squared change in gradient to the root-mean-squared
average gradient for each point in the course.  The goal is to only
have abrupt gradient changes where they actually exist in the
real-life course.  A score of 1 on this metric is poor: it means there
are many abrupt gradient changes.  A score of 0.1 is smooth: gradients
typically change around 10% from segment-to-segment.  This quality
score can provide guidance to if altitude smoothing and point density
are sufficient. This doesn't address the issue of whether the
"top-down" view of the course is optimally smoothed.  For this careful
examination of the resulting GPX on GPX Visualizer, or simular,
with "aerial view" is a good idea.

This program has been enhanced with the ability to process "named
segments", which RGT interprets as sections of a course which should
be separately timed.  A typical application of these is for climbs,
and the program allows the auto-generation of segments using the
detection of distinct, non-overlapping climbs in the route.

=head1 DEPENDENCIES

This code uses the following Perl modules, which must be installed,
for example with the "cpan" command-line tool:

 Getopt::Long : used for processing comamnd-line options
 Geo::Gpx     : parsing and generating GPX files
 XML::Descent : processing XML (required by Geo::Gpx, as well)
 POSIX        : floor function
 Date::Parse  : for parsing time, with the -startTime option
 Pod::Usage   : for the -help option

=head1 OPTIONS

The program is generally invoked:

processGPX [option] <inputfilename> ...

where multiple input file names may be specified, and zero or more
options may be specified.

Options are case-insensitive and come in three varieties:

=over

=item * B<flags>: specifying the option by itself invokes the option.  For example,
  -nosave suppresses saving of the resulting GPX in an output file.

=item * B<values>: the option specification is followed by a value.  This may
  simultaneously invoke an option.  For example, "-spacing 10" sets the
  spacing for point interpolation to 10 meters, and additionally turns on
  point interpolation.

=item * B<lists>: the "-fixed" option is followed by a list of one or more
  numbers.  This will be explained in the section for that option.

=back

The options are the following:

=over

=item B<addDirection>

This option adds a "direction" field relative to east (in degrees) to
the GPX file.

examples:
0 degrees: east
90 degrees: north
180 degrees: west
270 degrees south

Note this is not "heading", as it is relative to east.

Direction is calculated for each point as the average of the
directions ahead and behind.  The direction of the first or last
points in a point-to-point course are calculated in only one
direction.  Directions for loop courses are calculated assuming the
loop.  The direction never changes by more than +/- 180 degrees from
one point to the next, so the direction has no limits: it can be
positive, negative, and outside the range from -360 to +360 degrees.
For example, if a route started east (0) then lapped around
counterclockwise 10 times, the final direction would be approximately
3600 degrees.

=item B<addCurvature>

This option adds a "curvature" field (in meters) to the GPX file.
Curvature is calculated as the ratio of the rate of change of angle
with distance.  Note for a unit circle (radius = 1) the rate of change
of angle (in radians) with position (along the perimeter) is 1.
In general this is the reciprical of the circle radius.

=item B<addDistance>

This option adds a "distance" field (in meters) to the GPX file.
Distance is calculated after all other operations, for example
cropping, extending, and shifting.  At present it's the horizontal
distance, so scaling a vertical cliff would count as zero.

=item B<addGradient>

This option adds a forward "gradient" field, which is
calculated for each point as the ratio of the altitude change to the
horizontal distance to the next point.  With RGT, this is useful for
checking whether altitude smoothing is sufficient.

=item B<addGradientSigns>

This flag is an i<experimental> option to calculate regions of
exceptional gradient and place "gradient signs" in the GPX as
waypoints.  RGT Cycling at present ignores waypoints, but perhaps
support will be provided in the future, in which case this feature
will need to be tuned to the appropriate specification.

=item B<addSigma>

This writes the autosmoothing "sigma" to the GPX file as a field, but only
if "-autosmoothingZ" is positive.  It is useful for tuning the autosmoothing
scale length.

=item B<anchorSF>

For point-to-point routes, this specifies that the start and finish
points should be anchored.  Smoothing would otherwise cause these
points to shift somewhat.

=item B<append> <meters>

A distance in meters which should be added to point-to-point
courses. In RGT, the finish line is typically places 140 meters prior
to the end of a point-to-point course, so if for example you design a
course to be exactly 10 miles, (a typical UK time trial distance),
then to put the finish line at the end of those 10 miles, the option
"-append 140" would add 140 meters.  This buffer is needed by RGT
because riders group along the road-side after crossing the finish.
Note the start line would also need to be extended, via -prepend, by
60 meters, in this case.

Extended points will be set to the altitude of the final point.

Since RGT tends to create loop courses when start and finish points are
close, the code may put a bend in the road it creates with this command,
if both "-append" and "-prepend" are specified (perhaps via "-extend").

Negative values crop the course by the negative distance.  So
"-append -100" will move the finish line back 100 meters.  This is
useful for preventing RGT from connecting the finish and start points,
which has a 100 meter threshold, as this is written.

=item B<author> <string>

Provide the author of the GPX, as a string.  The default will
preserve the author of the source GPX.

=item B<auto>

This option automatically turns on options based on "best practices".
It will not turn anything off, so can be used in conjunction with other
options.  Altitude auto-smoothing is used if no value for -zsmooth is
provided.

=item B<autoSegments> <threshold> <optional power>

Whether to automatically generate segments for the climb.  The threshold
is the vertical meters of a 10% gradient climb, where climbs at alternate
gradients are adjusted by a term (gradient / 10%)^power, where the default
power is 0.5.  The names can be set with "autoSegmentNames", with a generic
default.

=item B<autoSegmentNames> <list of names>

A list of names for automatically generated segments, separated by
commas or semicolons.  The default is "climb" followed by a number.
If there are more segments than names, the default will be used for
the additional climbs.

=item B<autoSegmentMargin> <meters>

A minimum buffer between auto-generated segments and either the start or
finish banners, or other auto-segments.

=item B<autoSegmentPower> <number>

If the gradient power for autosegments is not provided in the
-autoSegments option as a second value, then use this value.  The
default is 0.5.  Decent numbers are from 0.25 to 2, depending on how
much focus you want to put on steepness in defining and rating climbs.

=item B<autoSegmentStretch> <relative amount>

The amount of distance increase one is willing to extend an
auto-segment to reach a true peak or valley.  This is applied to each
side, so a value of 0.05 will result in up to a 10% increase in the
total length of an automatically generated segment.  The increase
will not be applied if it would result in the loss of mandated
margin (by -autoSegmentMargin) to an adjacent segment or to a
start or finish banner.

=item B<autoSmoothZ> <scale factor>

This invokes an auto-smoothing algorithm whereby more altitude
smoothing is applied where gradient changes rapidly point-to-point,
less altitude smoothing where gradient changes slowly.  This is done
after the conventional position and altitude smoothing specified with
"-smooth" and/or "-smoothz".  So it allows the use of less of these
fixed smoothings, and apply an additional smoothing where it is most
needed.  An application of this would be a course where the altitude
is low quality on a subset of the total course, and one thus wants
more averaging averaging focused on that subset.

The scale factor controls how much smoothing is applied.  It is
roughly calibrated so "1" works well, but you can try reducing that to
0.5, for example, and see if the results are still satisfactory, or
increasing it to 2 if the gradient is still too spiky.

Consider using "-sigmaz" instead unless you think there's a reason the
quality of the data is worse in some areas than in others: that
applies uniform smoothing over the whole course.  Or the two can be
combined.

=item B<autoSpacing>

Specify that points will be interpolated based on an algorithm.  The
key parameter is"smoothAngle", which determines where points are
placed.  This only makes sense if the a smoothing distance or a
minRadius is also provided, via the "-smooth" or "-minRadius" options.
=item B<closed>

Synonym for "-copyPoint"

=item B<circle> <meters> (1 or more)

Provide segments to be fit with circles, alternating start distance
from start of GPX, and finish distance from start of GPX.  This is an
alternative to providing values via -circleStart and/or -circleEnd.
IF both methods are used, these will be processed first.  So for
example, -circle 400 500 100 200 will fit circles for points between
400 and 500 meters from the start, then between 100 and 200 meters from
the start.  Not ethe further points are listed first so the fit of a
circle to these points does not affect the distance to the nearer points.

=item B<circleEnd> <meters> (1 or more)

Set one or more distances for circle fitting.

See -circleStart

=item B<circleStart> <meters> (1 or more)

Set one or more start distances for circle fitting.

This is an option which should be used with care.  For the special case
where a route includes circular sections, for example laps of the
San Francisco Polo Fields, you can move points to a circle which passes
thru the end-points of an interval, and a point approximately mid-way
between the end-points.  This should be followed up with a bit of smoothing
over the interval to clean up the transitions to and from the circular
arc.  Be careful in defining the endpoints so the direction doesn't change
suddenly -- for example, you don't want the circular arc to overshoot,
requiring the direction to correct in the opposite direction.  Consider
only fitting the circlar arc to a center portion of the curve.

The circular arc is fit between points starting at -circleStart and
ending at -circleEnd from the start.  If the -isLoop option is used,
the start may come after the end in which case it wraps around.
The circular arc is generated after point interpolation but before
smoothing.  If you want to generate multiple circular arcs (for example,
the Polo fields have circular arcs at each end, separated by straight
segments) then you need to run processGPX more than once. Note the
circular arc will slightly change distances so you may want to do the
corrections starting further from the start, progressing closer, for
more stability in these distances.

If multiple values are listed, then multiple sections will be replaced.
Distances will be updated after each circular segment replacement.
So if you want to do multiple circular replacements, either list them
from further to closer relative to the start to avoid the distances
for later fits being affected by earlier fits.

=item B<copyPoint>

For "-loop" courses, copy the first point to the end of the list of
points, so the circuit is explicitly closed.  This assures that RGT
Cycling will recognize it as a loop course.

=item B<copyright> <string>

If you want to specify a copyright field in the GPX, list it here.
The default will preserve the copyright of the source GPX.

=item B<crop> <meters>

This is a short-cut for the --cropMax option

=item B<cropMax> <meters>

A point will be interpolated to this distance, if needed, and all
points following will be discarded.  Distances are calculated after
smoothing but before -append or -prepend.  It can be useful to design
a course beyond the desired length, smooth it, and then crop it, since
smoothing can have anomalous effects near the boundaries of the data.
This is especially true for a route ending on a section of road
previously encountered in the route.  Since smoothing is affected by
points ahead of and behind the given point, it is good to extend the
points sufficiently ahead of and behind the finish so that smoothing
has access to similar points both on the final and on preceding passes
of that section of road.

=item B<cropMin> <meters>

Points prior to this will be stripped, and if needed, a point will be
interpolated to this position.  This shifts the start position of the
GPX route.  See --cropMax for more discussion.

=item B<crossingAngle> <meters>

If set, then this is the minimum degres by which segments need to
intercept to be treated as crossings.  If intercepting by less than
this absolute angle, they are treated as separate.  The default is
11.25.  This can be increased since the default on twisty out-and-back
sections might get marked as crossings otherwise.

=item B<crossingHeight> <meters>

If -fixCrossings is invoked, then the code will attempt to identify
crossings and adjust the altitude at them.  Typically crossings will
be either level (same altitude each direction) or at some minimum
height.  That minumum height defaults to 2 meters, but can be adjusted
with this parameter.  If the GPX file has an altitude difference
between zero and this number, it will force whichever is closer, and
transition the altitude to either side, maintaining the same mean.

=item B<crossingTransition> <meters>

If -fixCrossings is invoked, then the altitude at crossings will be
flattened over a length rCrossings.  This flattening will be
transitioned back to the original altitude over a transition length
which defaults to 3 times rCrossing.  However, this may be too short,
resulting in excessive gradients.  This option allows explicitly
setting this transition length, specified in meters

=item B<csv>

Specifies the output will be CSV rather than GPX.  This is ignored if
an output file is specied with either a "csv" or "gpx" suffix (case
insensitive), in which case the suffix is used to determine the
format.  Other suffixes are ignored.

=item B<description> <string>

List a description for the GPX metadata.  Since the description will
likely contain spaces, remember to enclose the string in "quotes",
or however else your command-line shell delimits spaces.

=item B<disableElevationFixes> <0 or 1>
=item B<disableAdvancedSmoothing> <0 or 1>
=item B<enableElevationFixes>
=item B<enableAdvancedSmoothing>

These options specify whether to explicity turn off or explicitly turn
on various RGT post-processing options.  These functions are provided
by RGT, not this program, which simply places the appropriate tags in
the GPX output.  Note the "disable" options take a number as an
argument: 0 or 1.  the "enable" options do not take a number argument.
So this provides two ways of specifying whether you want these
features.  Enabling supercedes disabling.

The default is to disable both.

=item B<extend> <meters>

This is a simultaneous specificiation of both -prepend and -append.

=item B<extendBack> <meters>

With RGT point-to-point Magic Roads, the game will reserve the final
140 meters for riders finishing.  If you've created a route to the
top of a climb, for example, you may want the riders to be able to
ride all the way to the top, rather than stopping up to 140 meters
before the top.

One way to deal with this is to use -append: this will extend
the route with a straight line at the finish.  This may be enough,
but this 140 meters might not be consistent with the real topography,
for example the top of a twisting climb.

So this is an alternative: it will create a loop of radius
specified by -rTurnaround, then start returning on the route
until the specified distance, I<including the loop>, is covered.
If the loop is large enough, the route may end on the loop itself.
If not, the route will end on the return section.

It works by doing a normal turnaround, then cropping the course.
So if there's not enough course to reach the specified distance, it will
turn the route into a full out-and-back.  But typically the distance
should be in the range of up to 140 meters or so.

This disables -loop or -lap: it's meaningless with a lap course

=item B<finishCircuitDistance> <meters>

Often races end with finishing circuits after a lead-in.  To accomodate
this, you can start with a GPX route which includes at least one lap
of the finishing circuit, and add finishing loops.  This option
allows specifying the start position where a lap of the finish circuit
begins.  The circuit is assumed to extend to the end of the GPX file.
The code will add a number of copies of these points specified by the
B<-finishCircuits> option.

So if the course goes from A to B, then completes 3 circuits of the
loop B-C-D, then find the distance in meters to point B, then specify
that distance as -finishCircuitDistance, and specify -finishCircuits 2.
This will add two cop`ies of the loop B-C-D to the end of the data.

If the desired finish of the GPX is not at the same point as the end
of the loop, then you'll need to specify a -cropMax value to remove
some of the final circuit.

=item B<finishCircuits> count

A finishing circuit starting at the position specified by the
B<-finishCircuitDistance> option, in meters, will be appended
to the initial data this number of times.  A value of 1 here
implies adding one copy, which will result in two laps of the
circuit.

=item B<fixCrossings>

If a route contains crossings, for example a true figure 8, then it
will flatten the road on either side of the crossing, and create a
transition from the flattened profile back to the unaltered profile.
The side of the flattening is determined by the "-rCrossing" option.
An issue with RGT is that if a sloped road crosses a flat road, for
example, on the upward side the sloped road will appear to rise above
the surface, while in reality the pavement would be leveled out to
allow for the crossing.  This creates that leveling.

=item B<flatten> <start-meters> <altitude-meters> <end-meters> <altitude-meters> <transition-meters> ...

This important option allows the route to be flattened over a
specified coordinate range, with a specified transition length.  This
has been used where there are overpasses in a route, where it is
important that the altitude difference between the upper and lower
roadway be maintained, even with altitude smoothing.

You sepecify a starting distance, then the altitude at that point,
then a finish distance, then (optionally) an altitude at the second
point (default is the same altitude as the first point), then
optionally a transition length (default is to calculate a reasonable
one).

The transition length is used to describe a distance over which a
cosine weighting term is used to transition between the fixed
altitude, and the prior altitude for those points.  This should be
made long enough to avoid excessive deviations in gradient, yet small
enough to limit the extent of the influence of the command.

Multiple sets of five numbers can be provided, in which case altitude
flattening is done over each of the specified segments.

Distances are calculated i<after> smoothing but before cropping or extension.

=item B<gradientPower>

For gradient signs, how much of a power to apply to gradient in
determining where signs go.  If 0, then all that matters
is altitude: put the signs between peaks and valleys.  If 1,
then a climb which is double the altitude but half the altitude
gained scores the same.  The higher this number, the more likely
a gradient sign is to go on a short steep pitch versus a longer,
more gradual climb containing the short steep pitch.

=item B<gradientThreshold>

This determines the threshold at which a gradient sign gets put in.
The units are meters: a 10% climb needs to gain this much altitude
to get a gradient sign.  How much altitude steeper or less
steep climbs need to be depends on gradientPower

=item B<interpolate> <meters>

Synonym for "-spacing"

=item B<join> <filenames>

Add the points from the first track, segment found in these files and
append them to the first track, segment in the original file.  The
files must reasonably match up end-to-end.

=item B<keywords> <meters>

Add keywords to the GPX output.  Multiple keywords can be separated
with commas.  If there are any spaces, make sure to enclose the string
in quotes, or however your command-line shell specified strings should
be delimited.

So for example, the following are allowed:
 * -keywords test
 * -keywords test1,test2,test3
 * -keywords "test1, test2, test3"

A "processGPX" keyword is automatically added.

=item B<laneShift> <meters>

This shifts the points of a road to the right (for a positive value)
or the left (for a negative value) This is used for out-and-back
sections, to provide separation between the outward and return legs of
the road, which are otherwise described with the same coordinates.  In
RGT Cycling, a 4 meter shift will cause the resulting inward and
outward roads to abut, assuring that even if cyclists use the full
road width, they will not visually collide.  A larger value may result
in a grass island between the two directions.  A smaller value may result
in the roadways overlapping.

=item B<lap>

Synonym for "-loop"

=item B<loop>

The course is considered a loop course, or a circuit, and so smoothing and other operations
can take place between the beginning and end of the loop.

=item B<maxSlope> <%>

RGT supports a "maximum slope" option for magic roads.  This
option allows that to be changed from a default.  It is specified
in percent.  If you specify a number < 1, then that will be assumed
to not have been converted into percent, so the number will be
multiplied by 100.

=item B<minRadius> <meters>

The code will calculate an effective radius of turns, and if this is
less than this value, it will shift the road to increase the radius.
This is done prior to -laneShift, which may thus result in tighter
turns. So if there is a tight switchback, for example, then applying
this option will tend to shift the road outward, increasing the turn
radius.  There is a transition for this lane shift, so for tight
S-turns, alternating left and right, or in very tight switchbacks,
where the road snakes up a hill, results may be unsatisfactory.  It
works best with an isolated corner.

=item B<minRadiusEnd> <meters>

If specified, where to stop applying minimum radius (-minRadius).
If both -minRadiusStart and -minRadiusEnd are specified, and if
the end is before the beginning, then the region between the points
is excluded, and it is applied to the region after the start and
the region before the end.  To apply multiple radii in different
regions of the course, this can be used for one region, but then the
code should be re-run on the resulting GPX file to apply a subsequent
region.

=item B<minRadiusStart> <meters>

If specified, where to start applying minimum radius (-minRadius).
If both -minRadiusStart and -minRadiusEnd are specified, and if
the end is before the beginning, then the region between the points
is excluded, and it is applied to the region after the start and
the region before the end.  To apply multiple radii in different
regions of the course, this can be used for one region, but then the
code should be re-run on the resulting GPX file to apply a subsequent
region.  This is done very late, for example after -rUTurn.

=item B<name> <string>

Specify the name of the GPX route. The default is the name listed
in the source GPX.  This is synonymous with "-title".

=item B<noSave>

The -nosave option suppressed generation of a GPX output file.  This
may be useful for debugging or for checking the distance of a file,
which is reported to standard error, and checking it for zig-zags
and loops.

=item B<out> <filename>

Instead of the default filename, which is the input file with
F<_processed.gpx>, use this filename instead.  Make sure to specify
the F<.gpx> suffix if that is what is wanted. A "-" implies standard
output.

=item B<prepend> <meters>

See the -append option for details, except instead of adding roadway
to the end of a point-to-point course, this adds it to the beginning
of the course.  RGT in general puts the start line 60 meters after
the start of a GPX file, so this can provide for that distance,
although a better solution is to design in the 60 meter buffer from
the start, so it conforms to the actual roadway.

A negative number will crop the course at the beginning, so is
an alternative to -cropMin.

=item B<prune>

This option says that colinear points (in all three dimensions) should
be removed, reducing the size of the output file.  There's no downside
to this, unless the file is being prepared for subsequent modification
with another tool, such as GPX Magic.

=item B<pruneD> <meters>

Given three points in sequence, A, B, and C, if the separation between
B and the segment connecting A and C is at least this distance, the
point B is not pruned.  The "-prune" option must still be invoked to
get pruning.  There is a default value.

=item B<pruneX> <value>

Given three points in sequence, A, B, and C, if the sine of the angle
A-B-C exceeds this value, the point B will not be removed.  There is a
default value.

=item B<prunedg> <value>

Given three points in sequence, A, B, and C, if the difference in
gradient from A to B, and B to C, exceeds this value (not specified as
a percent, but as a raw value, so for example a 45-degree include has
gradient = 1), then the point B is not removed.  There is a default
value.

=item B<quiet>

If specified, suppress all noncritical messages (to the standard error
stream).  Only warnings and error messages will go to the standard
error stream.  This will suppress things like the number of points,
the altitude smoothness score, and the course distance.

=item B<rCrossings> <meters>

If "-fixCrossings" is invoked, then how far to each side of the
crossing the road should be leveled.  A transition of three times this
length will be used, over which the altitude will be restored to the
unaltered value.  The default is 6 meters, which works fairly well
with the RGT road width of 8 meters, althouugh if the intersection is
at a particularly acute value, or if the roads will be wider than the
RGT standard of 8 meters, a larger value may be better.  If the value
is too large, the transitions too and from the flat section may be too
steep, or the influence of crossings could overlap, which the
algorithm does not handle well.

=item B<reverse>

This reverses a course immediately after loading the file.  So all
subsequent operations will be done on the reversed course rather than
the original course.  So for example, if I have an initial course
which goes from point A to point B, and I specify a turnaround with
-rTurnaround 5, instead of an route from A to B and back, it will
instead be from B to A and back.  If you want to reverse the final
product, then do a second run with just the -reverse option after an
initial run on other options.

=item B<rLap> <meters>

For an out-and-back course, create a second loop at the finish,
reconnecting to the start, to create a circuit.  This allows the
out-and-back to be repeated an arbitrary number of laps.  This only
works if "-rTurnaround" is also positive. See also "-rUTurn".

=item B<rTurnaround> <meters>

Create an out-and-back course, with a turn of this radius generated at
the turn-around point.  This may be done in conjunction with
"-laneShift" to have the return road shifted from the outward road.
If the distance is less than the laneShift value, then the loop will
have 3 parts: for example a right, then a left, then another right to
turn 180 degrees.  The turn The main turn will be to the left if
laneShift is negative (UK, for example), or to the right if laneShift
is positive (US, for example) with a default (for no laneShift) to the
right.

=item B<rUTurn> <meters>

If any 180-degree turns are identified in the course, loops
are added with this radius.

This is done late in the process, in particular after lane
shifting, so the U-turns can properly connect the land-shifted
roads (with the "-laneShift" option).  It is done before
minRadius, however.

=item B<segment> <start>,<end>,<name> ...

Define one or more non-overlapping named segments for the route.
These are defined immediately before the shiftSF option is applied.
segments are specified with groups of 3 options separated by commas: a
first coordinate specifying the starting distance in meters or
"start", a second ccoordinate specifying the ending distance in meters
or "end", and a name.  The starting coordinate instead be "start" to
begin at the course start, and the ending coordinate can instead be
"end" to end at the course end.  It is not recommended to use these
options with a loop course, since for loops, the course will not start
or finish at the GPX end.  In any case, RGT requires that segments
start a sufficient distance from the beginning of the route, and end a
sufficient distance from the end of the route, and also be separated
by a sufficient distance.  However, this code only checks that they
not overlap.  There is no way to define segments which overlap the S/F
of a lapped course.  Segments already defined in the GPX file, for
example from GPX Magic or previous runs of this code, are honored, and
so new segments may not overlap previously defined segments.  Points
are interpolated to get an essentially exact match to the specified
coordinates.

If you want multiple named segments, then split them with colons (":"),
so for example "-segments "1000,2000,segment 1;3000,4000,segment 2"

=item B<shiftEnd> <meters>

The position at which lane shifting should end. This is useful in case
you have an isolated out-and-back section and want to be able to shift
lanes over only a portion of a course, or for example for an
out-and-back where there will be little risk of head-on collisions
sufficiently far from the turn-around.  A transition zone between
shifting and non-shifting is created.  The distance is calculated
prior to lane shifting, not self-consistently (lane shifting will
subtly change distances), so to determine precise distance, run once
without lane shifting, get the distance, then do lane shifting with
that precise distance.

A reason for limiting lane shifting is that lane shifting creates a
deviation in the route from the real-world coordinates, unless the
road is sufficiently wide, and also because it can cause a decrease in
radius of tight turns to too small value.  Lane shifting should thus
be combined with a sufficient degree of position smoothing to avoid
tight corners, or else restrict the lane shifting from a portion of
the course with tight corners.

If shiftStart < shiftEnd, then the shift occurs between shiftStart and
shiftEnd.

if shiftStart > shiftEnd, then the shift occurs up to shiftEnd, then
begins again at shiftStart.  This is useful for a "lollipop" course,
where you go out on a road, then do a loop, then return along the
original road.  So put shiftEnd at the end of the outward leg, then
shiftStart at the beginning of the return leg, and leave the loop part
unshifted.  Place the transitions slightly past where the directions
diverge, so the transition regaions do not cause the lanes to come
together at the beginning of the return leg (end of the outward leg).

The -laneShift option still needs to be specified.

=item B<shiftStart> <meters>

The position on the course where lane shifting starts.  See -shiftEnd
for details, except this marks the start of the lane shift zone.

The -laneShift option still needs to be specified.

=item B<shiftSF> <meters>

For -loop courses, the amount to shift the start/finish forwards
(positive) or backwards (negative).

For loop courses, RGT Cycling puts the start/finish line 60 meters
after the start of the GPX data.  This is evidently to provide room
for riders to line up before the start, although that is only
necessary in point-to-point courses, so the reason for this is
unclear.  In circuit courses careful placement of the start/finish
line, for example at the crest of a hill, or a specific distance from
a final corner, is critical, so with this option you can carefully
place the start point for the GPX file at the desired start/finish,
then use "-loop -shiftSF -60" to move the start of the GPX file back
60 meters, putting the start where it should be.

Since this is so commonly used in loop courses, the default is -60, so to
disable it, use "-shiftSF 0 -loop".

=item B<sigma> <meters>

Synonym for "-smooth"

=item B<sigmaz> <meters>

Synonym for "-smoothz"

=item B<smooth> <meters>

Provide a Gaussian sigma value for smoothing of position and altitude.
The result will sharp corners will be rounded to corners with
approximately this radius, and grade fluctuations over less distance
than this will be lost.  Typically altitude needs more smoothing than
position, so additional altitude smoothing is required.

=item B<smoothAngle> <degrees>

For "-autoSpacing", determines how dense to place points such that
the maximum angle between points is no more than approximately this angle.

=item B<smoothEnd> <meters>

See -smoothStart.  The default is to continue smoothing to the end of
the GPX data.

=item B<smoothStart> <meters>

If specified, smoothing will be phased in starting at this position in
the course.  Note 0 has an effect, as it will phase in smoothing
starting at 0, as opposed to the default, which is to apply the same
smoothing to all points. This applies to all smoothing, so consider
running processGPX multiple times if you want different limits on
different smoothing components.  For example, you might want to
exclude position smoothing from critical corners, but maintain
altitude smoothing.  If the start is after the finish, then the region
between the two is not smoothed, rather than smoothed.

=item B<smoothz> <meters>

Additional smoothing to be applied to altitude, on top of the
smoothing applied with -smooth.  So this number, if specified, will
typically be greater than the -smooth number or there is little
effect.  Grade changes which occur over less than this distace will
tend to be averaged out.  So for example, if I am designing an urban
course, and there is a turn onto a sharp climb, then less smoothing
can be tolerated.  On the other hand, if I am designing a course with
a steady grade up winding switchbacks on a steep hillside, then more
smoothing be needed.  On roads along steep hillsides, altitude
accuracy is more challenging than it is on roads which take the direct
route oup more gradual hillsides.

=item B<snap> <option>

With snapping, the code will search for sections of road which repeat,
either in the forward or reverse directions, and "snap" one pass to
the points of the other pass, guaranteeing that the two are perfectly
aligned.  So for example, if a route covers 1.5 laps of a course,
something not presently supported by the RGT multi-lap option (which
handles only complete laps), then snapping will make the final
half-lap the same as the first half-lap, up to within close to the end
of the route (since smoothing is affected by proximity to an end of
the route).  Similarly if a route has an out-and-back section, this
will help make sure there's no altitude or position differences
between the two.

B<option 1>: later passes are "snapped" to earlier passes.

B<option 2>: earlier passes are "snapped" to later passes.

Sometimes one or the other will work better in a particular case,
depending on whether an earlier or latter pass over a section of road
has better definition.

If there are existing segments, snapping will try to map segments from
the old points to the new points, but it's more precise to define
segments after snapping.  If you define segments within the same run
of processGPS, they will be done after possible snapping.

=item B<snapAltitude> <meters>

Normally for snapping to identify two sections of road as being a
repetition, they need to be within 1 meter altitude, to avoid
"snapping" on very tight switchbacks, for example, where roads may be
close on a map but at different elevations.  But in cases where map
data have elevation errors, this may prevent legitimate snapping.
This parameter allows for the altitude tolerance to be increased from
the default, relatively tight, 1 meter limit.  Note there's an
additional tolerance for the separation, using a 30% gradient, which
is not adjustable.

=item B<snapDistance> <meters>

The distance in meters a road segment can deviate from another and
still be "snapped" (see the "-snap" option).  This example can be important:
if snapdistance is too small, instead of the repeated road being replaced
in one piece, it may be fragmented.  Look to the standard error for
text describing which segments have been snapped.  For example, the
following from a criterium course with an out-and-back section:

snapping reverse segment: iRange = 25 35 <=> jRange = 54 47

This is a nice clean replacement

=item B<snapTransition> <meters>

B<WARNING>: this may be buggy.  Check results carefully.

This is an i<experimental> feature whereby points within this distance
of a snap transition on partially syncronized in altitude, with a
transition weighting depending on distance along the course.  This is
designed to avoid having divergent roads having different slopes while
still overlapping, which can create "ridges" in the pavement which in
real life would cause riders to crash.  It's experimental, however,
and there is no guarantee it will help rather than hurt, because of
the way smoothing affects points near snap transitions, and snapping
is almost always combined with smoothing to avoid abrupt jumps in
position.

=item B<snapZ> <meters>

This is a synonym for snapAltitude

=item B<spacing> <meters>

As an early stage to processing, interpolate points on the route so
that the spacing between points is no more than approximately this
spacing.  If -smoothing and/or -smoothingz are specified, then
smoothing doesn't work over distances much smaller than this spacing.
-autospacing is another option, in which case the code will
selectively interpolate points near points where the direction is
changing.

=item B<splineDegs> <degrees>

If splines are desired, specifying this will cause spline
interpolation to be done for corners turning at least this much, but
less than the -splineMaxDegs option.  A typical value is 5 degrees.
This angle is the angle between course points, not an angle of a total
turn: the algorithm only looks at points ahead of and behind a given
point.

=item B<splineMaxDegs> <degrees>

If a -splineDegs option is specified, specifying this limit the
maximum angle corner for which spline interpolation will be applied.
Splines are good for gradual, rounded corners but are not good for
sharp corners, so an upper bound in the 60 degree range (which is the
default) works generally well.  Splines have the advantage of rounding
corners without "blunting" them, but sometimes they create "S" shapes
where they are not wanted.  Make sure to check the results if using
spline interpolation: verty strange results can occur if the corner
is too sharp.

=item B<startCircuitDistance> <meters>

Sometimes races start with multiple circuits of a loop, before leaving
the circuit for a remainder of the course.  This option allows you to
repeat a beginning portion of the GPX file as a finishing circuit.
To do this, you specify the distance to the end of the circuit, then
an use the -startCircuits option to specify how many copies of this
circuit should be prepended to the route at the beginning.

If the start/end of the circuit lap is not the same place as the desired
beginning of the route, then you'll need to specify a -cropMin value to remove
some of the initial circuit

=item B<startCircuits> <count>

The number of copies of the starting circuit (from distance 0 to the
value in meters specified with the -startCircuitDistance option) to be
added to the beginning of the data.  So a value 1 means adding one
copy, which implies two laps of the circuit, including the one defined
in the original file.

=item B<startTime> "<time string>"

Specify a start line for an activity using clear notation, for example:

processGPX -startTime "15 Feb 2021 08:00"

would generate a time field beginning at that time, in the local time
zone.  This is useful for uploading a GPX route to "Relive", a website
which generates animations of routes, and requires a time field.  The
time is generated using a heureistic formula which has rider speed
depend on the road grade.

=item B<straight> <meters> (1 or more)

Provide segments to be fit with straights, alternating start distance
from start of GPX, and finish distance from start of GPX.  This is an
alternative to providing values via -straightStart and/or -straightEnd.
IF both methods are used, these will be processed first.  So for
example, -straight 400 500 100 200 will fit straights for points between
400 and 500 meters from the start, then between 100 and 200 meters from
the start.  Not ethe further points are listed first so the fit of a
straight to these points does not affect the distance to the nearer points.

=item B<straightEnd> <meters> (1 or more)

Set one or more distances for straight fitting.

See -straightStart

=item B<straightStart> <meters> (1 or more)

Set one or more start distances for straight fitting.

Straight fitting is done by finding the endpoints of the straight segment
using the provided distances.  Only existing points will be used: no point
interpolation will be done. Then for points between these endpoints, a projection
operator is used to map the new point onto the segment connecting the two endpoints.
The original data should be close to straight so this projection operation does
not result in any retrograde motion.  This would result in 180 degree turns.
So if the points are nearly straight, and the end points are good, this can
help straighten out sections of road which should be perfectly straight.
The points are moved onto the projected position on the line segment, but 
the elevations (or other parameters) are not changed.  So the assumption is that
moving onto the staight line is perpendicular to any altitude gradients.
This could result in a road with a constant gradient but following a curvy
path ending up with a non-constant gradient.  So check altitudes with care.
One possible approach is to use the -flatten option to interpolate the altitudes,
after doing the straight-line fit.

If multiple values are listed, then multiple sections will be replaced.
Distances will be updated after each circular segment replacement.
So if you want to do multiple circular replacements, either list them
from further to closer relative to the start to avoid the distances
for later fits being affected by earlier fits.

=item B<stripSegments>

if specified, this results in existing segment definitions on input files (including
those specified with -join) being stripped before processing.  This would typically
be used if -autoSegments is specified.

=item B<title> <string>

Specify the name of the GPX route. The default is the name listed
in the source GPX.  This is synonymous with "-name".

=item B<v> or B<version>

Print the version number and exit.

=item B<zAutoSmooth>

Synonym for -autoSmoothZ

=item B<zOffset> <meters>

Add this to the altitudes in the original file.  This is useful for
"fantasy courses", or where altiude is recorded by an improperly
zeroed altimeter.  This is applied I<before scaling>.  Use -zShift for
changing altitude after scaling.

=item B<zScale> <factor>

Multiply altitudes in the original file I<after offset>. but I<before
shift>.  This is useful for fantasy routes where climbing should be
adjusted, or potentially for data from a poorly calibrated barometer
where I want to perfectly tune the net altitude change of a climb.

=item B<zShift> <meters>

Add this to the altitudes in the original file.  This is useful for
"fantasy courses", or where altiude is recorded by an improperly
zeroed altimeter.  This is applied I<after scaling>.  Use -zOffset for
before scaling.

=item B<zShift> <meters>

Add this to the altitudes in the original file.  This is useful for
"fantasy courses", or where altiude is recorded by an improperly
zeroed altimeter.  This is applied I<after scaling>.  Use -zOffset for
before scaling.

=item B<zShiftEnd> <meters>

Distance on the route to end altitude shift.  There will be a transition
outside of this range.

=item B<zShiftStart> <meters>

Distance on the route to start altitude shift.  There will be a transition
outside of this range.

=item B<zSmooth>

Synonym for -smoothz

=item B<zsigma>

Synonym for -smoothz

=back

=head1 SEGMENTS

The code has been enhanced to handle "named segments" as interpreted
by RGT.  Segments are defined in the GPX standard such that a "track"
consists of a series of "segments", and a "segment" consists of a
series of "trackpoints".  In RGT, segments are assumed to be
contiguous, such that a route is defined as the first segment,
connected to the second segment, connected to the third segment, etc.

Segments can be either named or unnamed.  Named segments are
intepreted by RGT to be timed separately, similar to Strava segments,
where times it takes riders to go from the beginning to end of the
segment are recorded.  This program interacts with segments in several
ways:

=over

1. if the input file has segments defined in the manner required by
RGT, then these segments will be retained, unless the -stripSegments
option is used.  If there are gaps between segments, then these gaps
will be filled with additional segments, such that there is no
ambiguity about whether a gap belongs to the prior or following
segment.

2. Adjacent unnamed segments will be merged, so for example the
artificial segments assigned to gaps between segments will be assigned
to adjacent unnamed segment(s).

3. You can define your own segments using the -segments option.  This
is followed by a comma-delimited list of a start position, a finish
position, and a name, followed optionally by more of these three
items.  So it can be followed by a number of comma-delimited elements
divisible by three.  For each triplet, a segment is formed between the
first coordinate and the second coordinate and assigned the name of
the third element (if non-blank).  For example, -segment
1000,2000,"timed km" creates a segment from 1000 meters into the
route, up to 2000 meters into the route, and named the segment "timed
km".  These coordinates are of course affected by other operations
performed by this code so order of these operations is important.  The
segments are evaluated after most operations such as smoothing, but
before cropping, so the coordinates do not take into account potential
crops.

4. A more powerful way to create segments is to do so automatically.
This uses an algorithm which examines the route profile and identifies
what it considers to be "climbs".  The default is for no automatic
segments to be generated, so to request this, the -autoSegments option
is used.  It's followed by two numbers.  The first is the threshold
for a climb: small bumps in the road are not assigned for timing.  The
number is vertical meters at a reference 10% grade.  The second number
is a power which describes how much weight is put on steepness for
defining a climb.  A typical range is 0.3 to 1.0, with 0.5 to 0.7
working fairly well in many cases.  A lower number will tend to create
longer segments rather than focusing on steep sections, and will tend
to combine sections which are separated by plateaus or brief descents.
A larger number will tent to split these segmented climbs into
individual climbs, so for example if a road is 10% for 1 km, then flat
for 500 meters, then 8% for the next km, that might be considered one
climb or two.  Additionally automatic segments need to be separated
from each other and from the start or finish banners.  The amount of
this separation is specified with the -autoSegmentMargin option
(default is 100).  If climbs would be too close to each other, the
lower rated one is ignored, as are climbs which would be too close to
the start and/or finish.  So if you're designing a route for a
hillclimbing competition, unless the finish is sufficiently past the
start of the climb and the start is suffiently separate from the start
of the climb, there will not be a segment defined for the climb.

=back

=head1 EXAMPLES

=head2 -auto option

The -auto option attempts to use "reasonable" parameters which may not
be the best in each case, and which may require some fine-tuning, but should
work fairly well:

C<processGPX -auto GPXData.gpx>

This will create an output file "GPXData_processed.gpx" with various options
automatically chosen.

=head2 criterium course

The following example was from a criterium course:

C<processGPX -laneShift -7 -shiftStart 740 -shiftEnd 1390 -spacing 3 -minRadius 6 \
    -prune -smooth 7 -snapDistance 2 -snap 1 -copyPoint -lap CherryPieCritRGT.gpx>

The course has an out-and-back section ending in a loop.  In the
actual race, the out-and-back is separated by cones. However, for RGT
cycling, riders use the full road width of 8 meters, so the out and
back portions needed to be separated.

Options:

=over

=item B<-laneshift -6>

Riders remain to the left left on the out-and-back portion, so each
direction is shifted 4 meters to the left.  The negative number
implies left, a positive number implies right.

At one time a lane shift of 4 meters was adequate, but with changes to
"asset" placement, a larger lane shift is now needed.  This example
uses 7 meters to the left (UK, perhaps).

=item B<-shiftStart 740 -shiftEnd 1390>

The lane shift is applied starting at 740 meters and ending at 1390
meters, with a transition calculated from the lane shift.  This is
applied after all smoothing, but before the lane shifting, and
importantly, before the route start shift.  Note there is a default
"-shiftSF -60" applied at the end of the process, so if you want to
determine the distance to apply the lane shift, then make sure to
either do a run first with "-shiftSF 0 -laneShift 0", or subtract 100
meters from the distance coordinates to judge what the distance would
have been at the time the lane shift is applied.

It's important to check to make sure at the edge of the lane shift region
the two directions don't get too close, due to the transition.  If they do,
then extend the lane shift region somewhat to make room for the transition.
Also check the lane shift hasn't caused any corners to fold into points,
or invert. If this happens, apply more smoothing to round the corners more
before applying the lane shift.  Unfortunately there is no support yet
for position-dependent smoothing, which would help.

=item B<-spacing 3>

This is a short criterium course with a lot of tight corners, so the initial
spacing between points is set to 3 meters.  This works for the 1.6 km criterium,
but would perhaps be too many points for a 75 km point-to-point course,
for example.  But for longer routes, sharp corners are probably less of a factor.
Note this number should probably be no greater than the "-smooth" parameter, unless
"-autospacing" is used, in which case corners will set with finer spacing.

=item B<-minRadius 6>

If a corner turns out sharper than 6 meters, RGT will try to increase the radius
of the turn by extending the road outward, with a smooth transition into
and out of the correction.

=item B<-prune>

Remove useless points which don't affect either the shape of the
route, or the altitude profile.  This should probably be the default.

=item B<-smooth 7>

Position is smoothed with a Gaussin with sigma = 7 meters.  This was done
here to tune the corner rounding, especially since there was a lane-shifted
corner, and lane-shifting reduces inside corner radii.

=item B<-snapDistance 2 -snap 1>

Snap the return leg in the out-and-back to match the outgoing leg when
the two are within 2 meters. The "1" refers to replacing later
occurances of road with preceding cases: "2" would replace the earlier
occurance.  2 meters is presently the default snap distance.  With
Strava Route Editor data, 1 meter can result in a fragmented
replacement, and bad results.  When a road has curves, a larger
snapDistance than the default may be necessary.  Too large a value may
cause merging roads to suddenly "snap" together from too far a range,
however, or even adjacent roads or lanes to merge.  For reference, in
RGT Cycling, road width is 8 meters.

=item B<-copyPoint>

Make sure the last point matches the first, so RGT Cycling recognizes
it as a circuit

=item B<-lap>

It is a multi-lap race, so assure a smooth transition from the end of a lap
to the beginning of a next.  This is also necessary for "-copyPoint" to work.

=back

=head2 road course w/ out-and-back

This is from a road course with an out-and-back section:

C<processGPX -crop 38730 -anchor -spacing 10 -autoSpacing -smoothAngle 20 -prune -smooth 10 -smoothz 20 -snapDistance 5 -snap 1 -minRadius 6 NoonRide.gpx>

=over

=item B<-crop 38730>

The course was designed beyond the desired end of the RGT course,
since the end is on an out-and-back section, and to assure the end is
perfectly aligned with the outward portion of the same road, it was
extended further and cropped back.  This is important since smoothing
uses both the road ahead of and behind a certain point, so at an
endpoint of GPX data, smoothing will be different than if that road
had been extended further.  This course ended up being 38.73 km, which
corresponds to a distance between banners of 37.63 km, since 60 meters
(start) and 140 meters (finish) each end is reserved for riders gathering.

=item B<-anchor>

Don't move the start point or the finish point of the course.
Smoothing is done as normal, but then at the end, these points are
returned to their original positions, and nearby points nudged to keep
a smooth transition.

=item B<-spacing 10>

A point spacing of 10 meters is initially established.  This is more
than what was used in the criterium course example, since for a longer
course, smaller spacing results in more points.

=item B<-autospacing>

Automatically put extra points near corners before smoothing.  This is
a good option to assure smooth corners.

=item B<-smoothAngle 20>

Target the angle between segments at the apex of corners to be no more
than 20 degrees.  This seems to work fairly well.  You can compare to
10 degrees.  Most of the corner will end up with smaller angles than this,
as will corners which are less than 90 degrees.

=item B<-prune>

Eliminate unnecessary points at the end.  This should probably always
be used.

=item B<-smooth 10>

Use 10 meter smoothing on position and, initially, on altitude.  This
results in some rounding of corners.  For this course the result was
compared with the "GPX Visualizer" website to satellite data, to make
sure corners were fairly well aligned with actual corners, but
additionally that there were no anomalies such as "zig-zags" which did
not exist in the real road.  More than 10 meters and some detail from
the actual road may be lost, such as switchbacks with imperfect
variable radius.

=item B<-smoothz 20>

Additionally smooth altitude with a 20 meter smoothing distance.  On this
course, there were still gradient spikes with 10 meter smoothing, while more
than 20 meter smoothing would have lost some of the actual variations in
steepness.

=item B<-snapDistance 5 -snap 1>

The course is a "lollypop", meaning it heads out, does a big loop,
then returns (part way).  To make sure the return is well-aligned
with the out, snapping is used.  "-snap 1" means align the return
to the out (rather than the reverse).  "-snapDistance 5" means to snap
points which are as much as 5 meters apart.  5 meters is a lot, and the
result needs to be checked afterwards to make sure this doesn't result
in transitions are too abrupt, but a large snapdistance can help make sure
corners get snapped together.

=item B<-minRadius 6>

If a corner turns out sharper than 6 meters, RGT will try to increase the radius
of the turn by extending the road outward, with a smooth transition into
and out of the correction.

=item B<NoonRide.gpx>

This is the name of the original file.  The processed file will be
F<NoonRide_processed.gpx>.  If the result is good, it's best
to rename this to something different, so if you rerun the C<smoothGPX>, it
doesn't get over-written.

=back

=head2 Multi-step processing: selective smoothing

Here is an example where an urban route with reasonably sharp corners,
except it followed an oval path around a park.  The oval path came out
of Strava Route Editor slightly ragged, so I wanted enough smoothing
there to make it smooth, but the rest of the route, I wanted less
smoothing.  For this I used -smoothStart and -smoothEnd, to isolate
the oval, but then to get smoothing on the rest of the loop as well,
I needed to run the code twice:

C<processGPX -shiftSF 0 -lap -spacing 3 -zsmooth 10 -smooth 5 original.gpx -out - | processGPX - -copyPoint -lap -smooth 15 -prune -smoothStart 1540 -smoothEnd 270 -minRadius 6 -out processed.gpx>

This uses a shell "pipe", which is a way to run the program twice on
the same data without saving to an intermediate file. although the
intermediate file would be useful for debugging.

=over

=item B<-shiftSF 0>

The first call to processGPX specifies no S/F line shift (that will be done the
second call, and I want to maintain the position of the start of the GPX for
the first call).

=item B<-lap>

It is a lap course.

=item B<-spacing 3>

A fine spacing is used here, as the loop is only 1600 meters, and I'll rely on
pruning to reduce the number of points later.

=item B<-zsmooth 10>

This is moderate altitude smoothing.  It's an urban course, but the climbs
have fairly smooth transitions, and observing the gradient profile, there
were some anomalies with using 5 meter smoothing.  Strava Route Editor
tends to produce abrupt gradient changes.

=item B<-smooth 5>

This is a fairly small amount of smoothing, for urban corners with some
rounding, or where the actual road is wider than the Magic Roads 8 meter
road width, and wider lines are available.

=item B<original.gpx>

This is the name of the original GPX file

=item B<-out ->

This tells the code to write the resulting GPX to "the standard
output".

=item B<| processGPX ->"

This tells the command line shell to "send the standard output to the
standard input of the next program", which is a sepearate call to
processGPX.  It's called a "pipe".  The "-" tells the code that this
call takes its input from the pipe.  So think of it as a virtual file, a
direct line of communication from one call of the code to the next.

=item B<-copyPoint -lap>

Tell this call to the code that it's a lap, and I want to copy the
first point to the last point to close the loop.

=item B<-smooth 15 -smoothStart 1540 -smoothEnd 270>

Apply 15 meter smoothing this time, except start it at 1540 meters
into the course, and end it as 270 meters into the course.  The
smoothing domain wraps around, because it starts after it finishes.
So the end of the loop, and the beginning of the loop, will be
additionally smoothed, while the rest will be kept unaltered, with a
transitional range applied to avoid abrupt changes.

=item B<-minRadius 6>

This sets the minimum radius of corners to 6 meters.  This is done in the second step
here to include effects from processing in both steps.

=item B<-out processed.gpx>

=back

=head2 Multi-step processing: snapping after spacing

Snapping (making sure the course is aligned where it repeats itself)
is performed before any point interpolation or smoothing.  However,
especially with short courses, it may not work well where straigh
sections in the initial route have only two points, or elsewhere when
the number of points is very sparse.  A solution in this case is to
run the program twice.  This is an example:

C<processGPX -loop -copyPoint -shiftSF -50 -snapDistance 3 -spacing 2 -snap 1 -smoothz 10  -lap CritRGT.gpx -out Crit_step1.gpx>

C<processGPX -loop -copyPoint -shiftSF 0 -snapDistance 1 -snapTransition 20 -prune -snap 1 -smooth 10 CritRGT_step1.gpx -out Crit_processed_v1.gpx>

Here the first pass does a first pass of snapping, and afterwards it
adds points to a very fine spacing of 2 meters, It shifts the start of
the GPX back 50 meters. The goal here is to do the first crude point
snapping on the low-resolution data,then reduce the point spacing for
a second snap pass which will be done next, since the code snaps only
before adding points.  The result of the first pass is the file
F<Crit_step1.gpx>.

The second pass is not going to shift the start of the GPX any
further: that was already done the first pass.  Gross snapping was
done the first pass, so a smaller snap distance is used here, since
with the finer spacing of points after pass 1, some additional
snapping may be needed here.  The experimental "-snapTransition"
option is used here.  It makes sure points entering or leaving snap
regions are aligned in altitude.  This was a reason for the very fine
point spacing used here: this course has a lot of repeated sections,
and the goal is to keep the roads at similar altitude as they converge
or diverge to avoid ridges in the asphault. Smoothing is done this
step, with a 10 nm smoothing length.  Note the snap transition was
twice this value: we don't want smoothing to compromise our
synchronization of altitude.  The resulting file is
F<Crit_processed_v1.gpx>.

Some experimentation is needed with these options, but it helps to
have an idea of what the requirements are of each specific course.
The course shown here was special in taking multiple passes over the
same roads (actually paths) and having a complicated altitude profile.
This situation is particularly challenging with Magic Roads if you
want the transitions to look good.

=head2 segment generation

C<processGPX -stripSegments -autoSegments 100 0.5 -segments 1500,2000,"bonus segment" input.gpx -out output.gpx>

=over

=item B<-stripSegments>

If the input file has segments already defined, this will ignore those.

=item B<-autoSegments 20 0.5>

This tells the code that automatic segments should be generated for
climbs gaining at least 20 meters if they average 10%
gradient. Shallower climbs need to gain more, steeper climbs don't
need to gain as much.  The power assigned to gradient is 0.5, so for
example if the gradient is 5% instead of 10%, then since the square
root of 5/10 = 0.71, this climb would need to gain at least 28.2
meters instead of 20 meters to be considered as a timed segment.

=item B<-segments 1500,2000,"bonus segment">

This adds an additional segment to the route.  between 1500 and 2000
meters from the start of the route.  This is defined before any
automatic segments are generated, so care should be taken that this
segment is not overlapping anything which will be considered to be a
climb.

=back

C<processGPX -stripSegments -autoSegmentMargin 400 -autoSegmentStretch 1 -autoSegments 5 1 input.gpx -out output.gpx>

This example uses a gradient power of 1, placing a large emphasis on
local gradient, but then increases the auto-segment stretch factor
from its default to 1.  This might be useful if I had a long climb
with intermediate descents along the way, and I wanted separate climb
segments for each climbing portion rather than the net climb, but I
wanted the endpoints of these segments to be on flat road if that was
at all possible within the constraints of he margin, which is set to
400 meters.

=over

=item B<-autoSegmentMargin 400>

The minimum spacing between auto-segments is set to 400 meters.  This
will also be applied to the spacing between auto-segments and the
start or finish banner.

=item B<-autoSegmentStretch 1>

Be willing to increase auto-segment lengths up to their original length
in order to either reach a flat portion for the start or a flat portion
for the finish,

=item B<-autoSegments 5 1>

The climb threshold is set to a relatively low value of 5
meters, meaning I want to pick up even small steps in the larger
climb, and the gradient factor is set to 1, putting an emphasis on
isolating individual climbing portions.

=back

=head2 adding time to an activity

Suppose I wanted to add a time field to the result of the preceding example,
because I want to upload the GPX to "Relive.cc" so I can generate an animation
of the route to include in an event description of a race I'm organizing on
the course.

C<processGPX -startTime "Feb 25 2021 07:00" NoonRide_processed.gpx>

Here I am telling the code to use its bike speed model to predict how
long it will take a relatively fast rider to reach each point of the route,
and to add a time (and "duration") field to the GPX file, which will be
accepted by the RideWithGPX website.  The resulting file will be
F<NoonRide_processed_processed.gpx>.

=over

=item B<-startTime "Feb 25 2021 07:00">

This specifies that the time points begin on the listed data and time
in the local time zone (local to the user, not the course).  The
format of the data and time are flexible, but try to be unambiguous.
For example, rather than put "01/02/03" for a date, try "02 Jan 2003".

=back

=head2 adding gradient signs

This is an i<experimental> feature since RGT, the game which is the
primary target of this code, does not at present include waypoint support.

The following shows a partial command line, so added to other
elements of a command line:

C<-addGradientSigns -gradientThreshold 20 -gradientPower 2>

=over

=item B<-addGradientSigns>

Tells the code to add waypoints where gradient signs should be placed.

=item B<auto>

This option will attempt to guess at some good settings based on the
course.

=item B<-gradientThreshold 20>

A 10% grade would need to gain or lose 20 meters to get a sign.  The altitude
required for other gradients depends on the next option.

=item B<-gradientPower 2>

This is the default value, but is listed here for documentation purposes.
It says the suitability of a climb for a gradient sign is proportional to gradient
squared.  So for example, if a 10% climb gets one if it climbs 20 meters, than a
5% grade would need to gain 40 meters.  This also affects the placement of signs,
since if a climb is gradual, then steeper, then gradual again, should a single
sign be used to cover the entire climb, or should signs be prioritized to the steep
portion, then possibly add addiitonal signs to the gradual portions if they meet the
threshold?  The higher gradient power, the greater the priority placed on steepness.
The default of "2" seems to work well.

=back

=head2 specifying metadata

GPX files have "metadata" which is various tags. You can change values of
metadata with various options. This is an example:

C<processGPX -author "Dan Connelly" -keywords "race, RGT" -copyright "Dan Connelly" -name "Crit Course" crit.gpx -out critRGT.gpx -description "the best crit course">

This example specifies an author name, adds keywords, a copyright, a
title, and a description, taking the trackpoints from the file
"crit.gpx", and writing the reslt to "critRGT.gpx".  The time the file
was generated is automatically stored in the "time" metadata field.  A
"processGPX" keywords is additionally automatically added, to record
this program was used,

=head1 BUGS

=over

=item B<lane shifting and sharp corners>

If you apply more lane shift than the radius of the tightest corner,
the corner could end up with a non-positive radius, which is not what
you want.  The code may in the future be enhanced to make sure lane
shifting doesn't reverse the direction of any road segments.  But if
you want, for example, 4 meter lane shifting, then make sure smoothing
is at least 5 meters.

=item B<snapping not perfect>

The snapping algorithm makes certain assumptions to reduce computation
time and can be conflused for sufficiently complicated routes.  More
testing is needed.

=item B<-snapTransition is suspect.>

This option needs more debugging.

=item B<RGT ignores gradient signs, and puts in its own>

This isn't the fault of this code: complain to RGT.

=item B<segment limitations>

RGT has restrictions on how close segments can be to each other, or to
the start or finish of a route.  Officially this margin is 400 meters,
but it allows for smaller margins than this.  The exact limit is uncertain
so some experimentation is needed.  With automatic segment generation the
-autoSegmentMargin option can be used, for example -autoSegmentMargin 400
would adhere to the official RGT guideline.

=item B<snapping and segments>

If segments are defined before snapping, the code will try to assign
the appropriate segment to each snapped point, but this is imperfect.
It is better to define segments after snapping points.

=back

=head1 AUTHORS

Daniel Connelly <F<djconnel!at!gmail.com>>

=head1 LICENSE

This application is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

# eof
