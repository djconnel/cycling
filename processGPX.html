<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@catalina.internal.macports.net" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#DEPENDENCIES">DEPENDENCIES</a></li>
  <li><a href="#OPTIONS">OPTIONS</a></li>
  <li><a href="#EXAMPLES">EXAMPLES</a>
    <ul>
      <li><a href="#auto-option">-auto option</a></li>
      <li><a href="#criterium-course">criterium course</a></li>
      <li><a href="#road-course-w-out-and-back">road course w/ out-and-back</a></li>
      <li><a href="#Multi-step-processing:-selective-smoothing">Multi-step processing: selective smoothing</a></li>
      <li><a href="#Multi-step-processing:-snapping-after-spacing">Multi-step processing: snapping after spacing</a></li>
      <li><a href="#adding-time-to-an-activity">adding time to an activity</a></li>
      <li><a href="#adding-gradient-signs">adding gradient signs</a></li>
      <li><a href="#specifying-metadata">specifying metadata</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#LICENSE">LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>processGPX</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>smoothGPX [options] &lt;input files&gt;</p>

<h1 id="VERSION">VERSION</h1>

<p>0.33</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>smoothGPX is a series of algorithms to improve and create GPX files, in particular for cycling emulation platforms like RGT Cycling.</p>

<p>At the time of this writing, RGT Cycling has a &quot;Magic Roads&quot; functionality whereby a GPX file can be submitted for conversion into a virtual envirment. The GPX file can be initially generate by on-line mapping tools, among which one excellent option is Strava Route Editor, which exports GPX. However, these tools tend to produce GPX files with too low resolution in position, and small errors in altitude, so that corners are not sufficiently round, and the gradient between points can have anomalously large magnitude. Additionally, RGT requires the route to be specified continuously from start to finish, rather than allowing arbitrary navigation over a network of roads, and so sometimes the same section of road needs to be repeated, either in the same or in the opposite direction. Also, RGT at present allows cyclists to use the full width of the roadway, even if there is an out-and-back section where there may be oncoming riders. So it is useful to allow the generation of out-and-back courses where the return route is shifted to the right or too the left, to avoid the possibility of virtual collisions.</p>

<p>These are just some examples of the sort of processing which can be done to improve the quality and functionality of Magic Roads in RGT, and presumibly other cycling emulators as well. There exist online tools such as GPX Magic, which is excellent, but requires extensive user interaction, and a command-line tool able to process an entire file at once has benefit.</p>

<p>The file takes GPX files on the command line, and generates a file with a suffix &quot;_processed&quot; for each, unless the &quot;-out&quot; option is used, in which case that is used as the output (this works for only one input file). So for example, if I type:</p>

<p><code>processGPX myFavoriteRoute.gpx</code></p>

<p>the result will be a file:</p>

<p><i>myFavoriteRoute_processed.gpx</i></p>

<p>This file will be essentially equivalent to the input file, in the absence of any comment line options, although if there are any &quot;zig-zags&quot; identified, those will be removed. The file will also be checked for &quot;loops&quot;, where the direction spins around within 100 meters, which might be from a poorly placed control point with mapping software.</p>

<p>If an alternate filename were desired for the output, that could be specified with the &quot;-out&quot; option:</p>

<p><code>processGPX myFavoriteRoute.gpx -out MyFavoriteRouteCopy.gpx</code></p>

<p>where the order of command line options does not matter, except that the same option listed more than once will result in parameters specified last being used.</p>

<p>The program will calculate a &quot;altitude quality score&quot; of both the original GPX file, and of the result of processing, which is based on how much the grade changes point-to-point -- it is basically the ratio of the root-mean-squared change in gradient to the root-mean-squared average gradient for each point in the course. The goal is to only have abrupt gradient changes where they actually exist in the real-life course. A score of 1 on this metric is poor: it means there are many abrupt gradient changes. A score of 0.1 is smooth: gradients typically change around 10% from segment-to-segment. This quality score can provide guidance to if altitude smoothing and point density are sufficient. This doesn&#39;t address the issue of whether the &quot;top-down&quot; view of the course is optimally smoothed. For this careful examination of the resulting GPX on GPX Visualizer, or simular, with &quot;aerial view&quot; is a good idea.</p>

<h1 id="DEPENDENCIES">DEPENDENCIES</h1>

<p>This code uses the following Perl modules, which must be installed, for example with the &quot;cpan&quot; command-line tool:</p>

<pre><code> Getopt::Long : used for processing comamnd-line options
 Geo::Gpx     : parsing and generating GPX files
 POSIX        : floor function
 Date::Parse  : for parsing time, with the -startTime option
 Pod::Usage   : for the -help option</code></pre>

<h1 id="OPTIONS">OPTIONS</h1>

<p>The program is generally invoked:</p>

<p>processGPX [option] &lt;inputfilename&gt; ...</p>

<p>where multiple input file names may be specified, and zero or more options may be specified.</p>

<p>Options are case-insensitive and come in three varieties:</p>

<ul>

<li><p><b>flags</b>: specifying the option by itself invokes the option. For example, -nosave suppresses saving of the resulting GPX in an output file.</p>

</li>
<li><p><b>values</b>: the option specification is followed by a value. This may simultaneously invoke an option. For example, &quot;-spacing 10&quot; sets the spacing for point interpolation to 10 meters, and additionally turns on point interpolation.</p>

</li>
<li><p><b>lists</b>: the &quot;-fixed&quot; option is followed by a list of one or more numbers. This will be explained in the section for that option.</p>

</li>
</ul>

<p>The options are the following:</p>

<dl>

<dt id="addDirection"><b>addDirection</b></dt>
<dd>

<p>This option adds a &quot;direction&quot; field relative to east (in degrees) to the GPX file.</p>

<p>examples: 0 degrees: east 90 degrees: north 180 degrees: west 270 degrees south</p>

<p>Note this is not &quot;heading&quot;, as it is relative to east.</p>

<p>Direction is calculated for each point as the average of the directions ahead and behind. The direction of the first or last points in a point-to-point course are calculated in only one direction. Directions for loop courses are calculated assuming the loop. The direction never changes by more than +/- 180 degrees from one point to the next, so the direction has no limits: it can be positive, negative, and outside the range from -360 to +360 degrees. For example, if a route started east (0) then lapped around counterclockwise 10 times, the final direction would be approximately 3600 degrees.</p>

</dd>
<dt id="addCurvature"><b>addCurvature</b></dt>
<dd>

<p>This option adds a &quot;curvature&quot; field (in meters) to the GPX file. Curvature is calculated as the ratio of the rate of change of angle with distance. Note for a unit circle (radius = 1) the rate of change of angle (in radians) with position (along the perimeter) is 1. In general this is the reciprical of the circle radius.</p>

</dd>
<dt id="addDistance"><b>addDistance</b></dt>
<dd>

<p>This option adds a &quot;distance&quot; field (in meters) to the GPX file. Distance is calculated after all other operations, for example cropping, extending, and shifting. At present it&#39;s the horizontal distance, so scaling a vertical cliff would count as zero.</p>

</dd>
<dt id="addGradient"><b>addGradient</b></dt>
<dd>

<p>This option adds a forward &quot;gradient&quot; field, which is calculated for each point as the ratio of the altitude change to the horizontal distance to the next point. With RGT, this is useful for checking whether altitude smoothing is sufficient.</p>

</dd>
<dt id="addGradientSigns"><b>addGradientSigns</b></dt>
<dd>

<p>This flag is an i&lt;experimental&gt; option to calculate regions of exceptional gradient and place &quot;gradient signs&quot; in the GPX as waypoints. RGT Cycling at present ignores waypoints, but perhaps support will be provided in the future, in which case this feature will need to be tuned to the appropriate specification.</p>

</dd>
<dt id="addSigma"><b>addSigma</b></dt>
<dd>

<p>This writes the autosmoothing &quot;sigma&quot; to the GPX file as a field, but only if &quot;-autosmoothingZ&quot; is positive. It is useful for tuning the autosmoothing scale length.</p>

</dd>
<dt id="anchorSF"><b>anchorSF</b></dt>
<dd>

<p>For point-to-point routes, this specifies that the start and finish points should be anchored. Smoothing would otherwise cause these points to shift somewhat.</p>

</dd>
<dt id="append-meters"><b>append</b> &lt;meters&gt;</dt>
<dd>

<p>A distance in meters which should be added to point-to-point courses. In RGT, the finish line is typically places 140 meters prior to the end of a point-to-point course, so if for example you design a course to be exactly 10 miles, (a typical UK time trial distance), then to put the finish line at the end of those 10 miles, the option &quot;-append 140&quot; would add 140 meters. This buffer is needed by RGT because riders group along the road-side after crossing the finish. Note the start line would also need to be extended, via -prepend, by 60 meters, in this case.</p>

<p>Extended points will be set to the altitude of the final point.</p>

<p>Since RGT tends to create loop courses when start and finish points are close, the code may put a bend in the road it creates with this command, if both &quot;-append&quot; and &quot;-prepend&quot; are specified (perhaps via &quot;-extend&quot;).</p>

<p>Negative values crop the course by the negative distance. So &quot;-append -100&quot; will move the finish line back 100 meters. This is useful for preventing RGT from connecting the finish and start points, which has a 100 meter threshold, as this is written.</p>

</dd>
<dt id="author-string"><b>author</b> &lt;string&gt;</dt>
<dd>

<p>Provide the author of the GPX, as a string. The default will preserve the author of the source GPX.</p>

</dd>
<dt id="auto"><b>auto</b></dt>
<dd>

<p>This option automatically turns on options based on &quot;best practices&quot;. It will not turn anything off, so can be used in conjunction with other options. Altitude auto-smoothing is used if no value for -zsmooth is provided.</p>

</dd>
<dt id="autoSmoothZ-scale-factor"><b>autoSmoothZ</b> &lt;scale factor&gt;</dt>
<dd>

<p>This invokes an auto-smoothing algorithm whereby more altitude smoothing is applied where gradient changes rapidly point-to-point, less altitude smoothing where gradient changes slowly. This is done after the conventional position and altitude smoothing specified with &quot;-smooth&quot; and/or &quot;-smoothz&quot;. So it allows the use of less of these fixed smoothings, and apply an additional smoothing where it is most needed. An application of this would be a course where the altitude is low quality on a subset of the total course, and one thus wants more averaging averaging focused on that subset.</p>

<p>The scale factor controls how much smoothing is applied. It is roughly calibrated so &quot;1&quot; works well, but you can try reducing that to 0.5, for example, and see if the results are still satisfactory, or increasing it to 2 if the gradient is still too spiky.</p>

<p>Consider using &quot;-sigmaz&quot; instead unless you think there&#39;s a reason the quality of the data is worse in some areas than in others: that applies uniform smoothing over the whole course. Or the two can be combined.</p>

</dd>
<dt id="autoSpacing"><b>autoSpacing</b></dt>
<dd>

<p>Specify that points will be interpolated based on an algorithm. The key parameter is&quot;smoothAngle&quot;, which determines where points are placed. This only makes sense if the a smoothing distance is also provided, via the &quot;-smooth&quot; option.</p>

</dd>
<dt id="closed"><b>closed</b></dt>
<dd>

<p>Synonym for &quot;-copyPoint&quot;</p>

</dd>
<dt id="copyPoint"><b>copyPoint</b></dt>
<dd>

<p>For &quot;-loop&quot; courses, copy the first point to the end of the list of points, so the circuit is explicitly closed. This assures that RGT Cycling will recognize it as a loop course.</p>

</dd>
<dt id="copyright-strong"><b>copyright</b> &lt;strong&gt;</dt>
<dd>

<p>If you want to specify a copyright field in the GPX, list it here. The default will preserve the copyright of the source GPX.</p>

</dd>
<dt id="crop-meters"><b>crop</b> &lt;meters&gt;</dt>
<dd>

<p>This is a short-cut for the --cropMax option</p>

</dd>
<dt id="cropMax-meters"><b>cropMax</b> &lt;meters&gt;</dt>
<dd>

<p>A point will be interpolated to this distance, if needed, and all points following will be discarded. Distances are calculated after smoothing but before -append or -prepend. It can be useful to design a course beyond the desired length, smooth it, and then crop it, since smoothing can have anomalous effects near the boundaries of the data. This is especially true for a route ending on a section of road previously encountered in the route. Since smoothing is affected by points ahead of and behind the given point, it is good to extend the points sufficiently ahead of and behind the finish so that smoothing has access to similar points both on the final and on preceding passes of that section of road.</p>

</dd>
<dt id="cropMin-meters"><b>cropMin</b> &lt;meters&gt;</dt>
<dd>

<p>Points prior to this will be stripped, and if needed, a point will be interpolated to this position. This shifts the start position of the GPX route. See --cropMax for more discussion.</p>

</dd>
<dt id="crossingAngle-meters"><b>crossingAngle</b> &lt;meters&gt;</dt>
<dd>

<p>If set, then this is the minimum degres by which segments need to intercept to be treated as crossings. If intercepting by less than this absolute angle, they are treated as separate. The default is 11.25. This can be increased since the default on twisty out-and-back sections might get marked as crossings otherwise.</p>

</dd>
<dt id="crossingHeight-meters"><b>crossingHeight</b> &lt;meters&gt;</dt>
<dd>

<p>If -fixCrossings is invoked, then the code will attempt to identify crossings and adjust the altitude at them. Typically crossings will be either level (same altitude each direction) or at some minimum height. That minumum height defaults to 2 meters, but can be adjusted with this parameter. If the GPX file has an altitude difference between zero and this number, it will force whichever is closer, and transition the altitude to either side, maintaining the same mean.</p>

</dd>
<dt id="crossingTransition-meters"><b>crossingTransition</b> &lt;meters&gt;</dt>
<dd>

<p>If -fixCrossings is invoked, then the altitude at crossings will be flattened over a length rCrossings. This flattening will be transitioned back to the original altitude over a transition length which defaults to 3 times rCrossing. However, this may be too short, resulting in excessive gradients. This option allows explicitly setting this transition length, specified in meters</p>

</dd>
<dt id="csv"><b>csv</b></dt>
<dd>

<p>Specifies the output will be CSV rather than GPX. This is ignored if an output file is specied with either a &quot;csv&quot; or &quot;gpx&quot; suffix (case insensitive), in which case the suffix is used to determine the format. Other suffixes are ignored.</p>

</dd>
<dt id="description-string"><b>description</b> &lt;string&gt;</dt>
<dd>

<p>List a description for the GPX metadata. Since the description will likely contain spaces, remember to enclose the string in &quot;quotes&quot;, or however else your command-line shell delimits spaces.</p>

</dd>
<dt id="extend-meters"><b>extend</b> &lt;meters&gt;</dt>
<dd>

<p>This is a simultaneous specificiation of both -prepend and -append.</p>

</dd>
<dt id="extendBack-meters"><b>extendBack</b> &lt;meters&gt;</dt>
<dd>

<p>With RGT point-to-point Magic Roads, the game will reserve the final 140 meters for riders finishing. If you&#39;ve created a route to the top of a climb, for example, you may want the riders to be able to ride all the way to the top, rather than stopping up to 140 meters before the top.</p>

<p>One way to deal with this is to use -append: this will extend the route with a straight line at the finish. This may be enough, but this 140 meters might not be consistent with the real topography, for example the top of a twisting climb.</p>

<p>So this is an alternative: it will create a loop of radius specified by -rTurnaround, then start returning on the route until the specified distance, <i>including the loop</i>, is covered. If the loop is large enough, the route may end on the loop itself. If not, the route will end on the return section.</p>

<p>It works by doing a normal turnaround, then cropping the course. So if there&#39;s not enough course to reach the specified distance, it will turn the route into a full out-and-back. But typically the distance should be in the range of up to 140 meters or so.</p>

<p>This disables -loop or -lap: it&#39;s meaningless with a lap course</p>

</dd>
<dt id="finishCircuitDistance-meters"><b>finishCircuitDistance</b> &lt;meters&gt;</dt>
<dd>

<p>Often races end with finishing circuits after a lead-in. To accomidate this, you can start with a GPX route which includes at least one lap of the finishing circuit, and add finishing loops. This option allows specifying the start position where a lap of the finish circuit begins. The circuit is assumed to extend to the end of the GPX file. The code will add a number of copies of these points specified by the <b>-finishCircuits</b> option.</p>

<p>So if the course goes from A to B, then completes 3 circuits of the loop B-C-D, then find the distance in meters to point B, then specify that distance as -finishCircuitDistance, and specify -finishCircuits 2. This will add two copies of the loop B-C-D to the end of the data.</p>

<p>If the desired finish of the GPX is not at the same point as the end of the loop, then you&#39;ll need to specify a -cropMax value to remove some of the final circuit.</p>

</dd>
<dt id="finishCircuits-meters"><b>finishCircuits</b> &lt;meters&gt;</dt>
<dd>

<p>A finishing circuit starting at the position specified by the <b>-finishCircuitDistance</b> option, in meters, will be appended to the initial data this number of times. A value of 1 here implies adding one copy, which will result in two laps of the circuit.</p>

</dd>
<dt id="fixCrossings"><b>fixCrossings</b></dt>
<dd>

<p>If a route contains crossings, for example a true figure 8, then it will flatten the road on either side of the crossing, and create a transition from the flattened profile back to the unaltered profile. The side of the flattening is determined by the &quot;-rCrossing&quot; option. An issue with RGT is that if a sloped road crosses a flat road, for example, on the upward side the sloped road will appear to rise above the surface, while in reality the pavement would be leveled out to allow for the crossing. This creates that leveling.</p>

</dd>
<dt id="flatten-start-meters-altitude-meters-end-meters-altitude-meters-transition-meters"><b>flatten</b> &lt;start-meters&gt; &lt;altitude-meters&gt; &lt;end-meters&gt; &lt;altitude-meters&gt; &lt;transition-meters&gt; ...</dt>
<dd>

<p>This important option allows the route to be flattened over a specified coordinate range, with a specified transition length. This has been used where there are overpasses in a route, where it is important that the altitude difference between the upper and lower roadway be maintained, even with altitude smoothing.</p>

<p>You sepecify a starting distance, then the altitude at that point, then a finish distance, then (optionally) an altitude at the second point (default is the same altitude as the first point), then optionally a transition length (default is to calculate a reasonable one).</p>

<p>The transition length is used to describe a distance over which a cosine weighting term is used to transition between the fixed altitude, and the prior altitude for those points. This should be made long enough to avoid excessive deviations in gradient, yet small enough to limit the extent of the influence of the command.</p>

<p>Multiple sets of five numbers can be provided, in which case altitude flattening is done over each of the specified segments.</p>

<p>Distances are calculated i&lt;after&gt; smoothing but before cropping or extension.</p>

</dd>
<dt id="gradientPower"><b>gradientPower</b></dt>
<dd>

<p>For gradient signs, how much of a power to apply to gradient in determining where signs go. If 0, then all that matters is altitude: put the signs between peaks and valleys. If 1, then a climb which is double the altitude but half the altitude gained scores the same. The higher this number, the more likely a gradient sign is to go on a short steep pitch versus a longer, more gradual climb containing the short steep pitch.</p>

</dd>
<dt id="gradientThreshold"><b>gradientThreshold</b></dt>
<dd>

<p>This determines the threshold at which a gradient sign gets put in. The units are meters: a 10% climb needs to gain this much altitude to get a gradient sign. How much altitude steeper or less steep climbs need to be depends on gradientPower</p>

</dd>
<dt id="interpolate-meters"><b>interpolate</b> &lt;meters&gt;</dt>
<dd>

<p>Synonym for &quot;-spacing&quot;</p>

</dd>
<dt id="join-filename"><b>join</b> &lt;filename&gt;</dt>
<dd>

<p>Add the points from the first track, segment found in this file and append them to the first track, segment in the original file.</p>

</dd>
<dt id="keywords-meters"><b>keywords</b> &lt;meters&gt;</dt>
<dd>

<p>Add keywords to the GPX output. Multiple keywords can be separated with commas. If there are any spaces, make sure to enclose the string in quotes, or however your command-line shell specified strings should be delimited.</p>

<p>So for example, the following are allowed: * -keywords test * -keywords test1,test2,test3 * -keywords &quot;test1, test2, test3&quot;</p>

<p>A &quot;processGPX&quot; keyword is automatically added.</p>

</dd>
<dt id="laneShift-meters"><b>laneShift</b> &lt;meters&gt;</dt>
<dd>

<p>This shifts the points of a road to the right (for a positive value) or the left (for a negative value) This is used for out-and-back sections, to provide separation between the outward and return legs of the road, which are otherwise described with the same coordinates. In RGT Cycling, a 4 meter shift will cause the resulting inward and outward roads to abut, assuring that even if cyclists use the full road width, they will not visually collide. A larger value may result in a grass island between the two directions. A smaller value may result in the roadways overlapping.</p>

</dd>
<dt id="lap"><b>lap</b></dt>
<dd>

<p>Synonym for &quot;-loop&quot;</p>

</dd>
<dt id="loop"><b>loop</b></dt>
<dd>

<p>The course is considered a loop course, or a circuit, and so smoothing and other operations can take place between the beginning and end of the loop.</p>

</dd>
<dt id="minRadius-meters"><b>minRadius</b> &lt;meters&gt;</dt>
<dd>

<p>The code will calculate an effective radius of turns, and if this is less than this value, it will shift the road to increase the radius. This is done prior to -laneShift, which may thus result in tighter turns. So if there is a tight switchback, for example, then applying this option will tend to shift the road outward, increasing the turn radius. There is a transition for this lane shift, so for tight S-turns, alternating left and right, or in very tight switchbacks, where the road snakes up a hill, results may be unsatisfactory. It works best with an isolated corner.</p>

</dd>
<dt id="minRadiusEnd-meters"><b>minRadiusEnd</b> &lt;meters&gt;</dt>
<dd>

<p>If specified, where to stop applying minimum radius (-minRadius). If both -minRadiusStart and -minRadiusEnd are specified, and if the end is before the beginning, then the region between the points is excluded, and it is applied to the region after the start and the region before the end. To apply multiple radii in different regions of the course, this can be used for one region, but then the code should be re-run on the resulting GPX file to apply a subsequent region.</p>

</dd>
<dt id="minRadiusStart-meters"><b>minRadiusStart</b> &lt;meters&gt;</dt>
<dd>

<p>If specified, where to start applying minimum radius (-minRadius). If both -minRadiusStart and -minRadiusEnd are specified, and if the end is before the beginning, then the region between the points is excluded, and it is applied to the region after the start and the region before the end. To apply multiple radii in different regions of the course, this can be used for one region, but then the code should be re-run on the resulting GPX file to apply a subsequent region.</p>

</dd>
<dt id="name-string"><b>name</b> &lt;string&gt;</dt>
<dd>

<p>Specify the name of the GPX route. The default is the name listed in the source GPX. This is synonymous with &quot;-title&quot;.</p>

</dd>
<dt id="noSave"><b>noSave</b></dt>
<dd>

<p>The -nosave option suppressed generation of a GPX output file. This may be useful for debugging or for checking the distance of a file, which is reported to standard error, and checking it for zig-zags and loops.</p>

</dd>
<dt id="out-filename"><b>out</b> &lt;filename&gt;</dt>
<dd>

<p>Instead of the default filename, which is the input file with <i>_processed.gpx</i>, use this filename instead. Make sure to specify the <i>.gpx</i> suffix if that is what is wanted. A &quot;-&quot; implies standard output.</p>

</dd>
<dt id="prepend-meters"><b>prepend</b> &lt;meters&gt;</dt>
<dd>

<p>See the -append option for details, except instead of adding roadway to the end of a point-to-point course, this adds it to the beginning of the course. RGT in general puts the start line 60 meters after the start of a GPX file, so this can provide for that distance, although a better solution is to design in the 60 meter buffer from the start, so it conforms to the actual roadway.</p>

<p>A negative number will crop the course at the beginning, so is an alternative to -cropMin.</p>

</dd>
<dt id="prune"><b>prune</b></dt>
<dd>

<p>This option says that colinear points (in all three dimensions) should be removed, reducing the size of the output file. There&#39;s no downside to this, unless the file is being prepared for subsequent modification with another tool, such as GPX Magic.</p>

</dd>
<dt id="pruneD-meters"><b>pruneD</b> &lt;meters&gt;</dt>
<dd>

<p>Given three points in sequence, A, B, and C, if the separation between B and the segment connecting A and C is at least this distance, the point B is not pruned. The &quot;-prune&quot; option must still be invoked to get pruning. There is a default value.</p>

</dd>
<dt id="pruneX-value"><b>pruneX</b> &lt;value&gt;</dt>
<dd>

<p>Given three points in sequence, A, B, and C, if the sine of the angle A-B-C exceeds this value, the point B will not be removed. There is a default value.</p>

</dd>
<dt id="prunedg-value"><b>prunedg</b> &lt;value&gt;</dt>
<dd>

<p>Given three points in sequence, A, B, and C, if the difference in gradient from A to B, and B to C, exceeds this value (not specified as a percent, but as a raw value, so for example a 45-degree include has gradient = 1), then the point B is not removed. There is a default value.</p>

</dd>
<dt id="quiet"><b>quiet</b></dt>
<dd>

<p>If specified, suppress all noncritical messages (to the standard error stream). Only warnings and error messages will go to the standard error stream. This will suppress things like the number of points, the altitude smoothness score, and the course distance.</p>

</dd>
<dt id="rCrossings-meters"><b>rCrossings</b> &lt;meters&gt;</dt>
<dd>

<p>If &quot;-fixCrossings&quot; is invoked, then how far to each side of the crossing the road should be leveled. A transition of three times this length will be used, over which the altitude will be restored to the unaltered value. The default is 6 meters, which works fairly well with the RGT road width of 8 meters, althouugh if the intersection is at a particularly acute value, or if the roads will be wider than the RGT standard of 8 meters, a larger value may be better. If the value is too large, the transitions too and from the flat section may be too steep, or the influence of crossings could overlap, which the algorithm does not handle well.</p>

</dd>
<dt id="reverse"><b>reverse</b></dt>
<dd>

<p>This reverses a course immediately after loading the file. So all subsequent operations will be done on the reversed course rather than the original course. So for example, if I have an initial course which goes from point A to point B, and I specify a turnaround with -rTurnaround 5, instead of an route from A to B and back, it will instead be from B to A and back. If you want to reverse the final product, then do a second run with just the -reverse option after an initial run on other options.</p>

</dd>
<dt id="rLap-meters"><b>rLap</b> &lt;meters&gt;</dt>
<dd>

<p>For an out-and-back course, create a second loop at the finish, reconnecting to the start, to create a circuit. This allows the out-and-back to be repeated an arbitrary number of laps. This only works if &quot;-rTurnaround&quot; is also positive. See also &quot;-rUTurn&quot;.</p>

</dd>
<dt id="rTurnaround-meters"><b>rTurnaround</b> &lt;meters&gt;</dt>
<dd>

<p>Create an out-and-back course, with a turn of this radius generated at the turn-around point. This may be done in conjunction with &quot;-laneShift&quot; to have the return road shifted from the outward road. If the distance is less than the laneShift value, then the loop will have 3 parts: for example a right, then a left, then another right to turn 180 degrees. The turn The main turn will be to the left if laneShift is negative (UK, for example), or to the right if laneShift is positive (US, for example) with a default (for no laneShift) to the right.</p>

</dd>
<dt id="rUTurn-meters"><b>rUTurn</b> &lt;meters&gt;</dt>
<dd>

<p>If any 180-degree turns are identified in the course, loops are added with this radius.</p>

<p>This is done late in the process, in particular after lane shifting, so the U-turns can properly connect the land-shifted roads (with the &quot;-laneShift&quot; option).</p>

</dd>
<dt id="shiftEnd-meters"><b>shiftEnd</b> &lt;meters&gt;</dt>
<dd>

<p>The position at which lane shifting should end. This is useful in case you have an isolated out-and-back section and want to be able to shift lanes over only a portion of a course, or for example for an out-and-back where there will be little risk of head-on collisions sufficiently far from the turn-around. A transition zone between shifting and non-shifting is created. The distance is calculated prior to lane shifting, not self-consistently (lane shifting will subtly change distances), so to determine precise distance, run once without lane shifting, get the distance, then do lane shifting with that precise distance.</p>

<p>A reason for limiting lane shifting is that lane shifting creates a deviation in the route from the real-world coordinates, unless the road is sufficiently wide, and also because it can cause a decrease in radius of tight turns to too small value. Lane shifting should thus be combined with a sufficient degree of position smoothing to avoid tight corners, or else restrict the lane shifting from a portion of the course with tight corners.</p>

<p>If shiftStart &lt; shiftEnd, then the shift occurs between shiftStart and shiftEnd.</p>

<p>if shiftStart &gt; shiftEnd, then the shift occurs up to shiftEnd, then begins again at shiftStart. This is useful for a &quot;lollipop&quot; course, where you go out on a road, then do a loop, then return along the original road. So put shiftEnd at the end of the outward leg, then shiftStart at the beginning of the return leg, and leave the loop part unshifted. Place the transitions slightly past where the directions diverge, so the transition regaions do not cause the lanes to come together at the beginning of the return leg (end of the outward leg).</p>

<p>The -laneShift option still needs to be specified.</p>

</dd>
<dt id="shiftStart-meters"><b>shiftStart</b> &lt;meters&gt;</dt>
<dd>

<p>The position on the course where lane shifting starts. See -shiftEnd for details, except this marks the start of the lane shift zone.</p>

<p>The -laneShift option still needs to be specified.</p>

</dd>
<dt id="shiftSF-meters"><b>shiftSF</b> &lt;meters&gt;</dt>
<dd>

<p>For -loop courses, the amount to shift the start/finish forwards (positive) or backwards (negative).</p>

<p>For loop courses, RGT Cycling puts the start/finish line 60 meters after the start of the GPX data. This is evidently to provide room for riders to line up before the start, although that is only necessary in point-to-point courses, so the reason for this is unclear. In circuit courses careful placement of the start/finish line, for example at the crest of a hill, or a specific distance from a final corner, is critical, so with this option you can carefully place the start point for the GPX file at the desired start/finish, then use &quot;-loop -shiftSF -60&quot; to move the start of the GPX file back 60 meters, putting the start where it should be.</p>

<p>Since this is so commonly used in loop courses, the default is -60, so to disable it, use &quot;-shiftSF 0 -loop&quot;.</p>

</dd>
<dt id="sigma-meters"><b>sigma</b> &lt;meters&gt;</dt>
<dd>

<p>Synonym for &quot;-smooth&quot;</p>

</dd>
<dt id="sigmaz-meters"><b>sigmaz</b> &lt;meters&gt;</dt>
<dd>

<p>Synonym for &quot;-smoothz&quot;</p>

</dd>
<dt id="smooth-meters"><b>smooth</b> &lt;meters&gt;</dt>
<dd>

<p>Provide a Gaussian sigma value for smoothing of position and altitude. The result will sharp corners will be rounded to corners with approximately this radius, and grade fluctuations over less distance than this will be lost. Typically altitude needs more smoothing than position, so additional altitude smoothing is required.</p>

</dd>
<dt id="smoothAngle-degrees"><b>smoothAngle</b> &lt;degrees&gt;</dt>
<dd>

<p>For &quot;-autoSpacing&quot;, determines how dense to place points such that the maximum angle between points is no more than approximately this angle.</p>

</dd>
<dt id="smoothEnd-meters"><b>smoothEnd</b> &lt;meters&gt;</dt>
<dd>

<p>See -smoothStart. The default is to continue smoothing to the end of the GPX data.</p>

</dd>
<dt id="smoothStart-meters"><b>smoothStart</b> &lt;meters&gt;</dt>
<dd>

<p>If specified, smoothing will be phased in starting at this position in the course. Note 0 has an effect, as it will phase in smoothing starting at 0, as opposed to the default, which is to apply the same smoothing to all points. This applies to all smoothing, so consider running processGPX multiple times if you want different limits on different smoothing components. For example, you might want to exclude position smoothing from critical corners, but maintain altitude smoothing. If the start is after the finish, then the region between the two is not smoothed, rather than smoothed.</p>

</dd>
<dt id="smoothz-meters"><b>smoothz</b> &lt;meters&gt;</dt>
<dd>

<p>Additional smoothing to be applied to altitude, on top of the smoothing applied with -smooth. So this number, if specified, will typically be greater than the -smooth number or there is little effect. Grade changes which occur over less than this distace will tend to be averaged out. So for example, if I am designing an urban course, and there is a turn onto a sharp climb, then less smoothing can be tolerated. On the other hand, if I am designing a course with a steady grade up winding switchbacks on a steep hillside, then more smoothing be needed. On roads along steep hillsides, altitude accuracy is more challenging than it is on roads which take the direct route oup more gradual hillsides.</p>

</dd>
<dt id="snap-option"><b>snap</b> &lt;option&gt;</dt>
<dd>

<p>With snapping, the code will search for sections of road which repeat, either in the forward or reverse directions, and &quot;snap&quot; one pass to the points of the other pass, guaranteeing that the two are perfectly aligned. So for example, if a route covers 1.5 laps of a course, something not presently supported by the RGT multi-lap option (which handles only complete laps), then snapping will make the final half-lap the same as the first half-lap, up to within close to the end of the route (since smoothing is affected by proximity to an end of the route). Similarly if a route has an out-and-back section, this will help make sure there&#39;s no altitude or position differences between the two.</p>

<p><b>option 1</b>: later passes are &quot;snapped&quot; to earlier passes.</p>

<p><b>option 2</b>: earlier passes are &quot;snapped&quot; to later passes.</p>

<p>Sometimes one or the other will work better in a particular case, depending on whether an earlier or latter pass over a section of road has better definition.</p>

</dd>
<dt id="snapAltitude-meters"><b>snapAltitude</b> &lt;meters&gt;</dt>
<dd>

<p>Normally for snapping to identify two sections of road as being a repetition, they need to be within 1 meter altitude, to avoid &quot;snapping&quot; on very tight switchbacks, for example, where roads may be close on a map but at different elevations. But in cases where map data have elevation errors, this may prevent legitimate snapping. This parameter allows for the altitude tolerance to be increased from the default, relatively tight, 1 meter limit. Note there&#39;s an additional tolerance for the separation, using a 30% gradient, which is not adjustable.</p>

</dd>
<dt id="snapDistance-meters"><b>snapDistance</b> &lt;meters&gt;</dt>
<dd>

<p>The distance in meters a road segment can deviate from another and still be &quot;snapped&quot; (see the &quot;-snap&quot; option). This example can be important: if snapdistance is too small, instead of the repeated road being replaced in one piece, it may be fragmented. Look to the standard error for text describing which segments have been snapped. For example, the following from a criterium course with an out-and-back section:</p>

<p>snapping reverse segment: iRange = 25 35 &lt;=&gt; jRange = 54 47</p>

<p>This is a nice clean replacement</p>

</dd>
<dt id="snapTransition-meters"><b>snapTransition</b> &lt;meters&gt;</dt>
<dd>

<p><b>WARNING</b>: this may be buggy. Check results carefully.</p>

<p>This is an i&lt;experimental&gt; feature whereby points within this distance of a snap transition on partially syncronized in altitude, with a transition weighting depending on distance along the course. This is designed to avoid having divergent roads having different slopes while still overlapping, which can create &quot;ridges&quot; in the pavement which in real life would cause riders to crash. It&#39;s experimental, however, and there is no guarantee it will help rather than hurt, because of the way smoothing affects points near snap transitions, and snapping is almost always combined with smoothing to avoid abrupt jumps in position.</p>

</dd>
<dt id="snapZ-meters"><b>snapZ</b> &lt;meters&gt;</dt>
<dd>

<p>This is a synonym for snapAltitude</p>

</dd>
<dt id="spacing-meters"><b>spacing</b> &lt;meters&gt;</dt>
<dd>

<p>As an early stage to processing, interpolate points on the route so that the spacing between points is no more than approximately this spacing. If -smoothing and/or -smoothingz are specified, then smoothing doesn&#39;t work over distances much smaller than this spacing. -autospacing is another option, in which case the code will selectively interpolate points near points where the direction is changing.</p>

</dd>
<dt id="splineDegs-degrees"><b>splineDegs</b> &lt;degrees&gt;</dt>
<dd>

<p>If splines are desired, specifying this will cause spline interpolation to be done for corners turning at least this much, but less than the -splineMaxDegs option.</p>

</dd>
<dt id="splineMaxDegs-degrees"><b>splineMaxDegs</b> &lt;degrees&gt;</dt>
<dd>

<p>If a -splineDegs option is specified, specifying this limit the maximum angle corner for which spline interpolation will be applied. Splines are good for gradual, rounded corners but are not good for sharp corners, so an upper bound in the 60 degree range (which is the default) works generally well. Splines have the advantage of rounding corners without &quot;blunting&quot; them, but sometimes they create &quot;S&quot; shapes where they are not wanted.</p>

</dd>
<dt id="startCircuitDistance-meters"><b>startCircuitDistance</b> &lt;meters&gt;</dt>
<dd>

<p>Sometimes races start with multiple circuits of a loop, before leaving the circuit for a remainder of the course. This option allows you to repeat a beginning portion of the GPX file as a finishing circuit. To do this, you specify the distance to the end of the circuit, then an use the -startCircuits option to specify how many copies of this circuit should be prepended to the route at the beginning.</p>

<p>If the start/end of the circuit lap is not the same place as the desired beginning of the route, then you&#39;ll need to specify a -cropMin value to remove some of the initial circuit</p>

</dd>
<dt id="startCircuits-count"><b>startCircuits</b> &lt;count&gt;</dt>
<dd>

<p>The number of copies of the starting circuit (from distance 0 to the value in meters specified with the -startCircuitDistance option) to be added to the beginning of the data. So a value 1 means adding one copy, which implies two laps of the circuit, including the one defined in the original file.</p>

</dd>
<dt id="startTime-time-string"><b>startTime</b> &quot;&lt;time string&gt;&quot;</dt>
<dd>

<p>Specify a start line for an activity using clear notation, for example:</p>

<p>processGPX -startTime &quot;15 Feb 2021 08:00&quot;</p>

<p>would generate a time field beginning at that time, in the local time zone. This is useful for uploading a GPX route to &quot;Relive&quot;, a website which generates animations of routes, and requires a time field. The time is generated using a heureistic formula which has rider speed depend on the road grade.</p>

</dd>
<dt id="title-string"><b>title</b> &lt;string&gt;</dt>
<dd>

<p>Specify the name of the GPX route. The default is the name listed in the source GPX. This is synonymous with &quot;-name&quot;.</p>

</dd>
<dt id="v-or-version"><b>v</b> or <b>version</b></dt>
<dd>

<p>Print the version number and exit.</p>

</dd>
<dt id="zAutoSmooth"><b>zAutoSmooth</b></dt>
<dd>

<p>Synonym for -autoSmoothZ</p>

</dd>
<dt id="zOffset-meters"><b>zOffset</b> &lt;meters&gt;</dt>
<dd>

<p>Add this to the altitudes in the original file. This is useful for &quot;fantasy courses&quot;, or where altiude is recorded by an improperly zeroed altimeter. This is applied <i>before scaling</i>. Use -zShift for changing altitude after scaling.</p>

</dd>
<dt id="zScale-factor"><b>zScale</b> &lt;factor&gt;</dt>
<dd>

<p>Multiply altitudes in the original file <i>after offset</i>. but <i>before shift</i>. This is useful for fantasy routes where climbing should be adjusted, or potentially for data from a poorly calibrated barometer where I want to perfectly tune the net altitude change of a climb.</p>

</dd>
<dt id="zShift-meters"><b>zShift</b> &lt;meters&gt;</dt>
<dd>

<p>Add this to the altitudes in the original file. This is useful for &quot;fantasy courses&quot;, or where altiude is recorded by an improperly zeroed altimeter. This is applied <i>after scaling</i>. Use -zOffset for before scaling.</p>

</dd>
<dt id="zShift-meters1"><b>zShift</b> &lt;meters&gt;</dt>
<dd>

<p>Add this to the altitudes in the original file. This is useful for &quot;fantasy courses&quot;, or where altiude is recorded by an improperly zeroed altimeter. This is applied <i>after scaling</i>. Use -zOffset for before scaling.</p>

</dd>
<dt id="zShiftEnd-meters"><b>zShiftEnd</b> &lt;meters&gt;</dt>
<dd>

<p>Distance on the route to end altitude shift. There will be a transition outside of this range.</p>

</dd>
<dt id="zShiftStart-meters"><b>zShiftStart</b> &lt;meters&gt;</dt>
<dd>

<p>Distance on the route to start altitude shift. There will be a transition outside of this range.</p>

</dd>
<dt id="zSmooth"><b>zSmooth</b></dt>
<dd>

<p>Synonym for -smoothz</p>

</dd>
<dt id="zsigma"><b>zsigma</b></dt>
<dd>

<p>Synonym for -smoothz</p>

</dd>
</dl>

<h1 id="EXAMPLES">EXAMPLES</h1>

<h2 id="auto-option">-auto option</h2>

<p>The -auto option attempts to use &quot;reasonable&quot; parameters which may not be the best in each case, and which may require some fine-tuning, but should work fairly well:</p>

<p><code>processGPX -auto GPXData.gpx</code></p>

<p>This will create an output file &quot;GPXData_processed.gpx&quot; with various options automatically chosen.</p>

<h2 id="criterium-course">criterium course</h2>

<p>The following example was from a criterium course:</p>

<p><code>processGPX -laneShift -4 -shiftStart 740 -shiftEnd 1390 -spacing 3 \ -prune -smooth 7 -snapDistance 2 -snap 1 -copyPoint -lap CherryPieCritRGT.gpx</code></p>

<p>The course has an out-and-back section ending in a loop. In the actual race, the out-and-back is separated by cones. However, for RGT cycling, riders use the full road width of 8 meters, so the out and back portions needed to be separated.</p>

<p>Options:</p>

<dl>

<dt id="laneshift--4"><b>-laneshift -4</b></dt>
<dd>

<p>Riders remain to the left left on the out-and-back portion, so each direction is shifted 4 meters to the left. The negative number implies left, a positive number implies right.</p>

</dd>
<dt id="shiftStart-740--shiftEnd-1390"><b>-shiftStart 740 -shiftEnd 1390</b></dt>
<dd>

<p>The lane shift is applied starting at 740 meters and ending at 1390 meters, with a transition calculated from the lane shift. This is applied after all smoothing, but before the lane shifting, and importantly, before the route start shift. Note there is a default &quot;-shiftSF -60&quot; applied at the end of the process, so if you want to determine the distance to apply the lane shift, then make sure to either do a run first with &quot;-shiftSF 0 -laneShift 0&quot;, or subtract 100 meters from the distance coordinates to judge what the distance would have been at the time the lane shift is applied.</p>

<p>It&#39;s important to check to make sure at the edge of the lane shift region the two directions don&#39;t get too close, due to the transition. If they do, then extend the lane shift region somewhat to make room for the transition. Also check the lane shift hasn&#39;t caused any corners to fold into points, or invert. If this happens, apply more smoothing to round the corners more before applying the lane shift. Unfortunately there is no support yet for position-dependent smoothing, which would help.</p>

</dd>
<dt id="spacing-3"><b>-spacing 3</b></dt>
<dd>

<p>This is a short criterium course with a lot of tight corners, so the initial spacing between points is set to 3 meters. This works for the 1.6 km criterium, but would perhaps be too many points for a 75 km point-to-point course, for example. But for longer routes, sharp corners are probably less of a factor. Note this number should probably be no greater than the &quot;-smooth&quot; parameter, unless &quot;-autospacing&quot; is used, in which case corners will set with finer spacing.</p>

</dd>
<dt id="prune1"><b>-prune</b></dt>
<dd>

<p>Remove useless points which don&#39;t affect either the shape of the route, or the altitude profile. This should probably be the default.</p>

</dd>
<dt id="smooth-7"><b>-smooth 7</b></dt>
<dd>

<p>Position is smoothed with a Gaussin with sigma = 7 meters. This was done here to tune the corner rounding, especially since there was a lane-shifted corner, and lane-shifting reduces inside corner radii.</p>

</dd>
<dt id="snapDistance-2--snap-1"><b>-snapDistance 2 -snap 1</b></dt>
<dd>

<p>Snap the return leg in the out-and-back to match the outgoing leg when the two are within 2 meters. The &quot;1&quot; refers to replacing later occurances of road with preceding cases: &quot;2&quot; would replace the earlier occurance. 2 meters is presently the default snap distance. With Strava Route Editor data, 1 meter can result in a fragmented replacement, and bad results. When a road has curves, a larger snapDistance than the default may be necessary. Too large a value may cause merging roads to suddenly &quot;snap&quot; together from too far a range, however, or even adjacent roads or lanes to merge. For reference, in RGT Cycling, road width is 8 meters.</p>

</dd>
<dt id="copyPoint1"><b>-copyPoint</b></dt>
<dd>

<p>Make sure the last point matches the first, so RGT Cycling recognizes it as a circuit</p>

</dd>
<dt id="lap1"><b>-lap</b></dt>
<dd>

<p>It is a multi-lap race, so assure a smooth transition from the end of a lap to the beginning of a next. This is also necessary for &quot;-copyPoint&quot; to work.</p>

</dd>
</dl>

<h2 id="road-course-w-out-and-back">road course w/ out-and-back</h2>

<p>This is from a road course with an out-and-back section:</p>

<p><code>processGPX -crop 38730 -anchor -spacing 10 -autoSpacing -smoothAngle 20 -prune -smooth 10 -smoothz 20 -snapDistance 5 -snap 1 NoonRide.gpx</code></p>

<dl>

<dt id="crop-38730"><b>-crop 38730</b></dt>
<dd>

<p>The course was designed beyond the desired end of the RGT course, since the end is on an out-and-back section, and to assure the end is perfectly aligned with the outward portion of the same road, it was extended further and cropped back. This is important since smoothing uses both the road ahead of and behind a certain point, so at an endpoint of GPX data, smoothing will be different than if that road had been extended further. This course ended up being 38.73 km, which corresponds to a distance between banners of 37.63 km, since 60 meters (start) and 140 meters (finish) each end is reserved for riders gathering.</p>

</dd>
<dt id="anchor"><b>-anchor</b></dt>
<dd>

<p>Don&#39;t move the start point or the finish point of the course. Smoothing is done as normal, but then at the end, these points are returned to their original positions, and nearby points nudged to keep a smooth transition.</p>

</dd>
<dt id="spacing-10"><b>-spacing 10</b></dt>
<dd>

<p>A point spacing of 10 meters is initially established. This is more than what was used in the criterium course example, since for a longer course, smaller spacing results in more points.</p>

</dd>
<dt id="autospacing"><b>-autospacing</b></dt>
<dd>

<p>Automatically put extra points near corners before smoothing. This is a good option to assure smooth corners.</p>

</dd>
<dt id="smoothAngle-20"><b>-smoothAngle 20</b></dt>
<dd>

<p>Target the angle between segments at the apex of corners to be no more than 20 degrees. This seems to work fairly well. You can compare to 10 degrees. Most of the corner will end up with smaller angles than this, as will corners which are less than 90 degrees.</p>

</dd>
<dt id="prune2"><b>-prune</b></dt>
<dd>

<p>Eliminate unnecessary points at the end. This should probably always be used.</p>

</dd>
<dt id="smooth-10"><b>-smooth 10</b></dt>
<dd>

<p>Use 10 meter smoothing on position and, initially, on altitude. This results in some rounding of corners. For this course the result was compared with the &quot;GPX Visualizer&quot; website to satellite data, to make sure corners were fairly well aligned with actual corners, but additionally that there were no anomalies such as &quot;zig-zags&quot; which did not exist in the real road. More than 10 meters and some detail from the actual road may be lost, such as switchbacks with imperfect variable radius.</p>

</dd>
<dt id="smoothz-20"><b>-smoothz 20</b></dt>
<dd>

<p>Additionally smooth altitude with a 20 meter smoothing distance. On this course, there were still gradient spikes with 10 meter smoothing, while more than 20 meter smoothing would have lost some of the actual variations in steepness.</p>

</dd>
<dt id="snapDistance-5--snap-1"><b>-snapDistance 5 -snap 1</b></dt>
<dd>

<p>The course is a &quot;lollypop&quot;, meaning it heads out, does a big loop, then returns (part way). To make sure the return is well-aligned with the out, snapping is used. &quot;-snap 1&quot; means align the return to the out (rather than the reverse). &quot;-snapDistance 5&quot; means to snap points which are as much as 5 meters apart. 5 meters is a lot, and the result needs to be checked afterwards to make sure this doesn&#39;t result in transitions are too abrupt, but a large snapdistance can help make sure corners get snapped together.</p>

</dd>
<dt id="NoonRide.gpx"><b>NoonRide.gpx</b></dt>
<dd>

<p>This is the name of the original file. The processed file will be <i>NoonRide_processed.gpx</i>. If the result is good, it&#39;s best to rename this to something different, so if you rerun the <code>smoothGPX</code>, it doesn&#39;t get over-written.</p>

</dd>
</dl>

<h2 id="Multi-step-processing:-selective-smoothing">Multi-step processing: selective smoothing</h2>

<p>Here is an example where an urban route with reasonably sharp corners, except it followed an oval path around a park. The oval path came out of Strava Route Editor slightly ragged, so I wanted enough smoothing there to make it smooth, but the rest of the route, I wanted less smoothing. For this I used -smoothStart and -smoothEnd, to isolate the oval, but then to get smoothing on the rest of the loop as well, I needed to run the code twice:</p>

<p><code>processGPX -shiftSF 0 -lap -spacing 3 -zsmooth 10 -smooth 5 original.gpx -out - | processGPX - -copyPoint -lap -smooth 15 -prune -smoothStart 1540 -smoothEnd 270 -out processed.gpx</code></p>

<p>This uses a shell &quot;pipe&quot;, which is a way to run the program twice on the same data without saving to an intermediate file. although the intermediate file would be useful for debugging.</p>

<dl>

<dt id="shiftSF-0"><b>-shiftSF 0</b></dt>
<dd>

<p>The first call to processGPX specifies no S/F line shift (that will be done the second call, and I want to maintain the position of the start of the GPX for the first call).</p>

</dd>
<dt id="lap2"><b>-lap</b></dt>
<dd>

<p>It is a lap course.</p>

</dd>
<dt id="spacing-31"><b>-spacing 3</b></dt>
<dd>

<p>A fine spacing is used here, as the loop is only 1600 meters, and I&#39;ll rely on pruning to reduce the number of points later.</p>

</dd>
<dt id="zsmooth-10"><b>-zsmooth 10</b></dt>
<dd>

<p>This is moderate altitude smoothing. It&#39;s an urban course, but the climbs have fairly smooth transitions, and observing the gradient profile, there were some anomalies with using 5 meter smoothing. Strava Route Editor tends to produce abrupt gradient changes.</p>

</dd>
<dt id="smooth-5"><b>-smooth 5</b></dt>
<dd>

<p>This is a fairly small amount of smoothing, for urban corners with some rounding, or where the actual road is wider than the Magic Roads 8 meter road width, and wider lines are available.</p>

</dd>
<dt id="original.gpx"><b>original.gpx</b></dt>
<dd>

<p>This is the name of the original GPX file</p>

</dd>
<dt id="out"><b>-out -</b></dt>
<dd>

<p>This tells the code to write the resulting GPX to &quot;the standard output&quot;.</p>

</dd>
<dt id="processGPX"><b>| processGPX -</b></dt>
<dd>

<p>This tells the command line shell to &quot;send the standard output to the standard input of the next program&quot;, which is a sepearate call to processGPX. It&#39;s called a &quot;pipe&quot;. The &quot;-&quot; tells the code that this call takes its input from the pipe. So think of it as a virtual file, a direct line of communication from one call of the code to the next.</p>

</dd>
<dt id="copyPoint--lap"><b>-copyPoint -lap</b></dt>
<dd>

<p>Tell this call to the code that it&#39;s a lap, and I want to copy the first point to the last point to close the loop.</p>

</dd>
<dt id="smooth-15--smoothStart-1540--smoothEnd-270"><b>-smooth 15 -smoothStart 1540 -smoothEnd 270</b></dt>
<dd>

<p>Apply 15 meter smoothing this time, except start it at 1540 meters into the course, and end it as 270 meters into the course. The smoothing domain wraps around, because it starts after it finishes. So the end of the loop, and the beginning of the loop, will be additionally smoothed, while the rest will be kept unaltered, with a transitional range applied to avoid abrupt changes.</p>

</dd>
<dt id="out-processed.gpx"><b>-out processed.gpx</b></dt>
<dd>

</dd>
</dl>

<h2 id="Multi-step-processing:-snapping-after-spacing">Multi-step processing: snapping after spacing</h2>

<p>Snapping (making sure the course is aligned where it repeats itself) is performed before any point interpolation or smoothing. However, especially with short courses, it may not work well where straigh sections in the initial route have only two points, or elsewhere when the number of points is very sparse. A solution in this case is to run the program twice. This is an example:</p>

<p><code>processGPX -loop -copyPoint -shiftSF -50 -snapDistance 3 -spacing 2 -snap 1 -smoothz 10 -lap CritRGT.gpx -out Crit_step1.gpx</code></p>

<p><code>processGPX -loop -copyPoint -shiftSF 0 -snapSistance 1 -snapTransition 20 -prune -snap 1 -smooth 10 CritRGT_step1.gpx -out Crit_processed_v1.gpx</code></p>

<p>Here the first pass does a first pass of snapping, and afterwards it adds points to a very fine spacing of 2 meters, It shifts the start of the GPX back 50 meters. The goal here is to do the first crude point snapping on the low-resolution data,then reduce the point spacing for a second snap pass which will be done next, since the code snaps only before adding points. The result of the first pass is the file <i>Crit_step1.gpx</i>.</p>

<p>The second pass is not going to shift the start of the GPX any further: that was already done the first pass. Gross snapping was done the first pass, so a smaller snap distance is used here, since with the finer spacing of points after pass 1, some additional snapping may be needed here. The experimental &quot;-snapTransition&quot; option is used here. It makes sure points entering or leaving snap regions are aligned in altitude. This was a reason for the very fine point spacing used here: this course has a lot of repeated sections, and the goal is to keep the roads at similar altitude as they converge or diverge to avoid ridges in the asphault. Smoothing is done this step, with a 10 nm smoothing length. Note the snap transition was twice this value: we don&#39;t want smoothing to compromise our synchronization of altitude. The resulting file is <i>Crit_processed_v1.gpx</i>.</p>

<p>Some experimentation is needed with these options, but it helps to have an idea of what the requirements are of each specific course. The course shown here was special in taking multiple passes over the same roads (actually paths) and having a complicated altitude profile. This situation is particularly challenging with Magic Roads if you want the transitions to look good.</p>

<h2 id="adding-time-to-an-activity">adding time to an activity</h2>

<p>Suppose I wanted to add a time field to the result of the preceding example, because I want to upload the GPX to &quot;Relive.cc&quot; so I can generate an animation of the route to include in an event description of a race I&#39;m organizing on the course.</p>

<p><code>processGPX -startTime &quot;Feb 25 2021 07:00&quot; NoonRide_processed.gpx</code></p>

<p>Here I am telling the code to use its bike speed model to predict how long it will take a relatively fast rider to reach each point of the route, and to add a time (and &quot;duration&quot;) field to the GPX file, which will be accepted by the RideWithGPX website. The resulting file will be <i>NoonRide_processed_processed.gpx</i>.</p>

<dl>

<dt id="startTime-Feb-25-2021-07:00"><b>-startTime &quot;Feb 25 2021 07:00&quot;</b></dt>
<dd>

<p>This specifies that the time points begin on the listed data and time in the local time zone (local to the user, not the course). The format of the data and time are flexible, but try to be unambiguous. For example, rather than put &quot;01/02/03&quot; for a date, try &quot;02 Jan 2003&quot;.</p>

</dd>
</dl>

<h2 id="adding-gradient-signs">adding gradient signs</h2>

<p>This is an i&lt;experimental&gt; feature since RGT, the game which is the primary target of this code, does not at present include waypoint support.</p>

<p>The following shows a partial command line, so added to other elements of a command line:</p>

<p><code>-addGradientSigns -gradientThreshold 20 -gradientPower 2</code></p>

<dl>

<dt id="addGradientSigns1"><b>-addGradientSigns</b></dt>
<dd>

<p>Tells the code to add waypoints where gradient signs should be placed.</p>

</dd>
<dt id="auto1"><b>auto</b></dt>
<dd>

<p>This option will attempt to guess at some good settings based on the course.</p>

</dd>
<dt id="gradientThreshold-20"><b>-gradientThreshold 20</b></dt>
<dd>

<p>A 10% grade would need to gain or lose 20 meters to get a sign. The altitude required for other gradients depends on the next option.</p>

</dd>
<dt id="gradientPower-2"><b>-gradientPower 2</b></dt>
<dd>

<p>This is the default value, but is listed here for documentation purposes. It says the suitability of a climb for a gradient sign is proportional to gradient squared. So for example, if a 10% climb gets one if it climbs 20 meters, than a 5% grade would need to gain 40 meters. This also affects the placement of signs, since if a climb is gradual, then steeper, then gradual again, should a single sign be used to cover the entire climb, or should signs be prioritized to the steep portion, then possibly add addiitonal signs to the gradual portions if they meet the threshold? The higher gradient power, the greater the priority placed on steepness. The default of &quot;2&quot; seems to work well.</p>

</dd>
</dl>

<h2 id="specifying-metadata">specifying metadata</h2>

<p>GPX files have &quot;metadata&quot; which is various tags. You can change values of metadata with various options. This is an example:</p>

<p><code>processGPX -author &quot;Dan Connelly&quot; -keywords &quot;race, RGT&quot; -copyright &quot;Dan Connelly&quot; -name &quot;Crit Course&quot; crit.gpx -out critRGT.gpx -description &quot;the best crit course&quot;</code></p>

<p>This example specifies an author name, adds keywords, a copyright, a title, and a description, taking the trackpoints from the file &quot;crit.gpx&quot;, and writing the reslt to &quot;critRGT.gpx&quot;. The time the file was generated is automatically stored in the &quot;time&quot; metadata field. A &quot;processGPX&quot; keywords is additionally automatically added, to record this program was used,</p>

<h1 id="BUGS">BUGS</h1>

<dl>

<dt id="lane-shifting-and-sharp-corners"><b>lane shifting and sharp corners</b></dt>
<dd>

<p>If you apply more lane shift than the radius of the tightest corner, the corner could end up with a non-positive radius, which is not what you want. The code may in the future be enhanced to make sure lane shifting doesn&#39;t reverse the direction of any road segments. But if you want, for example, 4 meter lane shifting, then make sure smoothing is at least 5 meters.</p>

</dd>
<dt id="snapping-not-perfect"><b>snapping not perfect</b></dt>
<dd>

<p>The snapping algorithm makes certain assumptions to reduce computation time and can be conflused for sufficiently complicated routes. More testing is needed.</p>

</dd>
<dt id="snapTransition-is-suspect"><b>-snapTransition is suspect.</b></dt>
<dd>

<p>This option needs more debugging.</p>

</dd>
<dt id="No-way-to-add-turn-around-loops-in-the-middle-of-a-route"><b>No way to add turn-around loops in the middle of a route</b></dt>
<dd>

<p>Ideally I&#39;d be able to add turn-around loops not just at the beginning and/or end of a GPX file, but at abrupt turnarounds in the middle of the route. This is not presently supported. It it was supported, the code would look for turns close to 180 degrees (or two turns close 90 degrees each, on adjacent points) and createa loop of a specified radius there.</p>

</dd>
<dt id="RGT-ignores-gradient-signs-and-puts-in-its-own"><b>RGT ignores gradient signs, and puts in its own</b></dt>
<dd>

<p>This isn&#39;t the fault of this code: complain to RGT.</p>

</dd>
</dl>

<h1 id="AUTHORS">AUTHORS</h1>

<p>Daniel Connelly &lt;<i>djconnel!at!gmail.com</i>&gt;</p>

<h1 id="LICENSE">LICENSE</h1>

<p>This application is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>


</body>

</html>


